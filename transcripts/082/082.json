{"text": " Hello Jeroen. Hello Dillon. You know, I've always wanted to map Haskell concepts to Elm and well I guess it would be f-mapping then, wouldn't it? Well, it really depends on whether you have a list of things that you want to learn or if you have other things you want to learn. I guess you could say maybe this episode would be like a type of class, you could say. Well, today we've got Flavio Korfa joining us. Flavio, thanks so much for coming on the show. Hello, my pleasure. So Flavio, you wrote a really nice set of blog posts about Haskell for Elm and you named the series Giving Names to Stuff. And I like that name and if we could just start with why did you title the series Giving Names to Stuff? It seems like there's something important to you that you wanted to convey to Elm developers with your Haskell background about names and how names relate to type classes. So why do you think names are important and why are they important for your blog series? That's a very interesting question. I always wanted for someone to ask me about the name of the series. And I was also waiting for your puns at the beginning of the episode. I keep forgetting that he's going to do some until he's saying, I'm like, oh yeah, I didn't prepare anything. Get your cringe phrase ready. It's a pretty recent thing. He didn't do this in the beginning. And now he just can't stop. So it's a new thing or it's a modern thing in the podcast then, the puns. I'd say so. So related to Giving Names to Stuff, I first learned Haskell and it took me a while because it's quite a big language to learn and a bit wide. And then at some point I had some front-end experience and JavaScript experience prior to that. At some point I realized that I wanted to try out Elm and that I already knew Elm because the syntax is so similar to Haskell. And the Elm compiler is made in Haskell. So when you learn Haskell, they sort of teach you the other way around. They teach you the names first and then the patterns that you use. But in Elm, it's amazing because you don't really need to know the names of things. You just use them and you gain an intuition for them. And you see them in practice. How are they useful? How they make you a better programmer or why would you need such patterns? So while trying to explain a little bit of Haskell to my Elm friends, I just noticed you just need to know the names for stuff you already use. That's why I chose the name, basically. I love that. So did you think it was important for Elm developers to know the names for these things if they want to try Haskell? Or do you think that there's also value to giving names to these things for an Elm developer, even just working with Elm? Yeah, that's a good question because what happened to me before is that before even learning Haskell, as I mentioned, I was a JavaScript developer. So I tried to learn ReasonML, this new language that Facebook was creating. You know, the creator of React, Jordan Wolk. And then I started to learn some Reason and underneath it was OCaml and I did not know about it. And I knew that or I learned that Reason had something called functors. But when I tried to learn what these functors were, they were basically different from the Haskell functors or the JavaScript functors I already had read about. So it was really, really confusing to me. This name collision in my head that was making me feel anxious, so to speak. So I'd say that learning the names or at least getting familiar with the semantics or what they try to convey makes sense. Even if you want to jump to F-sharp, OCaml, whatever other functional language, it is useful in itself. But the same things are sometimes called different names, unfortunately, in different languages, and so it's a bit confusing, all of it. And naming these things is so hard because I think what I've started to realize is that our initial inclination may be... I imagine many people initially learn an imperative or an object-oriented language. And we tend to think of concepts in terms of what you do with them. Like, what's the inheritance chain? Or this is like a list or this is a sequence or this is a thing that you await that can be done sequentially. And it's like, well, what if we weren't talking about the kind of data something was or the kind of thing something represented, but rather how you transform data in something, right? So actually, you know, we can talk about a list and a task and a JSON decoder in the same way. What do those things have in common? Well, you can manipulate data in a similar way. How do you put a name to that idea? It's very difficult and it's very abstract, but it's a very productive way to work with things. And once you gain that intuition, you can be really productive, it feels like. But it's hard to develop that intuition. And it's an interesting question whether somebody develops that intuition faster when they're given the names first, learning Haskell, or when they're not given the names and just use these concepts in Elm. Yeah, definitely. I remember while doing or learning React in 2013, 2014, I was coming from AngularJS. So, for example, I just wanted to do a very simple thing. I wanted to iterate on a list. And you used to have these ng4, ngRepeat directives, you know, in the code. I was looking for that in React. And then obviously I learned about the function map, you know, and it's like, oh, so there is no special directive to do this. It's just you use a language construct, which is just list.map, so to say. And then you do what you want with the list. But this concept, learning it as a JavaScript developer, was so useful. And then it replicated in all the following languages I learned after that. And it was really, really practical and useful to get acquainted with that. Now I really want to know what was different with the Reason functor. Oh, yeah. So in OCaml and by extension in Reason, so basically one file is not one module as in Elm, as in Haskell as well. You can have multiple modules in one file. So there is a case in which you want to parametrize a module and call it with a specific generic type and use that module with a different type. So these parametrizeable modules, so to speak, how they call them, they call them OCaml functors. But it's a completely different thing as in what we know in Elm and Haskell as a functor. So it was kind of, yeah, mind-boggling to learn this. Gotcha. I can understand the confusion. Yeah, it was very confusing. Okay. So, well, let's dive into it. In your blog series, you wrote about basically three different type classes. You want to kind of enumerate those for us? Sure. Well, I started with the easiest one, I thought. We're talking about functors for a while now. But I started with functor because I think it's one of the most intuitive to think about once you understand the concept of mapping. And we use them every day in Elm in all sorts of code. As soon as you map any kind of data structure, you know that you are using functors underneath. So the next thing that you kind of get to or need to understand is that there is something called applicative functors for when you need to map two or map three, map four, etc. I read a really nice post by, I think it was Joel that also was a guest in a previous episode. It was on this topic. Exactly. So what happens when you run out of maps, right? When you don't have enough map n numbers. And then you can build yourself like using this and map thing. You can basically use the pipe operator and this and map and use as many as you want. And the concept behind these things, the concept that you can apply functors to each other, are called applicative functors. And it's kind of weird. The intuition is not as easy to understand as with functors. But when you learn about them, you start seeing them everywhere. And it's interesting because it's an intermediate step that you need to learn to go to the third step, which is monads. The thing everyone talks about and there are a thousand blog posts about this scary monad thing. Except in the Elm community where we basically don't talk about it. We don't use the M word. In fact, we'll beep out every use of our word monad in the text. Exactly. We will censor it so no one hears the M word anymore. Keep our PG rating. Actually, the only people who talk about monads are the ones who try to convey that information from Haskell to Elm. Yeah, but it's funny because it's also such a common pattern that happens all the time as soon as you want to work with the fakes. Monads are everywhere, even if we ignore them. But when I became a more serious Elm developer, I understood why Evan would choose to just ignore those names. Because they tend to be confusing. And you don't need to know the names to use the patterns. Definitely. Yeah, I find it confusing. Even the term fmap. Does that mean functor map? Is that why it's called fmap? Yeah, because since Haskell started as a research language, it didn't even have a way to do I-O at the beginning. It lived in the world of purity, so you could literally do nothing useful with it, according to its author. So they started to develop some patterns to call things. And sometimes things have a weird name. For example, there's a map function, but it only works for lists. So then once they generalized the functor pattern, so to say, or the functor type class, they said, Hey, map is already taken for lists. So what do we do? Okay, we will just call it fmap. Or something along those lines. Actually, do you know what the history is here? Is it like, these terms come from mathematics, and they were ported to Haskell? Or were they mostly found out in Haskell or other ancestor languages to that? And then people say, Oh, it's just mathematics. Yeah, I can be wrong answering this, but I will give you what I know from my understanding. There is a word, there are a few words that we don't want to say in Haskell as we don't want to say in Elm, which are category theory. What? You know. Oh, really? Do you know about category theory? Yes. I mean, I know of it. I don't know about it. What do you mean Haskell developers don't want to talk about that? That's, isn't that just the whole thing around functors and monads and all those things? Exactly. Yeah, but we try to speak the least possible amount about category theory, because obviously, since it influences all of these crazy names. But sometimes, for example, if you talk to a mathematician who happens to be an expert in category theory, they can tell you that the functor defined in Haskell or the monad defined in Haskell is not actually 100% right. So that's why I don't want to get too much deep into that forest. So for a category theory purist, Haskell is not pure enough for a category theory purist. I see. Exactly. I see. Elm is not pure enough for a Haskell purist. Okay, I see. And O'Camel was right the whole time. Yeah, actually, I think there's an argument to be made for the O'Camel functor. It's just that I don't know the argument. But probably someone with more experience than me that will probably explain why it's called a functor and what it has to be with a category theory functor. Yeah, I'm guessing they didn't come up with that word out of nowhere. Like, oh, let's find a word for this. Functor sounds nice. I think only one person did that ever. And then that's the functor that we hear about everywhere. Yeah, I think while researching or while developing Haskell and learning about all these patterns, obviously, you know that FB has a solid foundation in math. So you turn to something to look up for names, right? And they said, hey, so there is this really abstract branch of mathematics called category theory that happens to have all those fancy and cool names we're looking for. Why don't why not? We can start using them right away. That's my guess. My wild guess. Yeah, I mean, and they, they, there certainly are useful ideas here. It's just like, it feels like there's such a large barrier to entry. But, you know, I have I have thought, like, sometimes you'll see an Elm API that, you know, maybe it has like map two and map three, but it doesn't expose an end map, which you can derive, you know, as Joel talks about in his post running out of maps, you can derive it from those building blocks. But we sometimes don't have the conventions for which of these things should go together. Like if something is applicative, what building blocks should we have? You know, the idea has crossed my mind. What if we had like an Elm review package, some community standard and came up with a set of conventions? And we said, okay, well, like what? Because really, sometimes even just the terms that we use for these ideas, like, is it called concat map? Or is it called and then or is it called or whatever? Exactly. And you find you find instances of these different terms in different packages. And you have to look at the type signatures and know this is sort of the same type of thing that I can do, or have a little bit of a background in Haskell or category theory or whatever, and kind of squint your eyes at it. And you see it's the same thing. But wouldn't it be interesting if we had a community standard and an Elm review package that said, well, what's the name for this group of things? What are the standard function names and signatures? I'm not sure if Elm review, would Elm review be able to look at the type signatures of something in order to do that? Yeah, you can do that. Okay. You can look at the type signatures as long as they're written in the code. Yeah. So then it should be possible to say like, this is a mappable thing. And then it could, it could verify it could give you an error if it doesn't have something called map that has the appropriate signature, right? Yeah. There's also the opposite thing, where, for instance, in Elm review simplify, I tried to simplify code that uses maps. But if I don't know what the type is, then I can't do the simplification. Like if I see list on map used in a certain way, like on an empty list, then I can know, okay, well, this is useless, I can just simplify it to an empty list. But if I have a map function that whose type I don't know, well, I have no clue whether that will, in fact, respect the laws of functors as they do it in Haskell. So, so we like we have a name we have a that is pretty standard, but we don't have all the guarantees that go with it. Like potentially, it's just a map that creates something, or maybe it's a map that has the same signature, but it does something entirely different. And that's, that's a bit annoying, but we don't have that information of does this follow those rules, those laws, because we could do something, a few things that would be quite nicer, I think. But that is the case in Haskell, right? So that's some type says, well, I'm implementing or deriving or whatever, or what the term is, a functor. And therefore, this map now has to prove, does it have to prove that it follows some rules? Or does it not have to? Yeah, you can check if it follows some rules. There are well, you can use one of the most used libraries is QuickCheck for property-based testing. And it comes by default for example, for checkers for the functor laws or the applicative laws or monad laws, and you can you can check. But if you use, for example, the deriving mechanisms from GHC, from the main Haskell compiler, whatever the GHC derives as a functor instance, you can be pretty sure that it's going to be a correct functor. Unless there's more than one way to implement something which happens with some other instances, like with monoid instances, for example, or certain operators or for certain operations, there can be more than one valid implementation, then you need to disambiguate. But it's not so common with functors, I would say. Yeah. So one thing that I was wondering about is like, you made this suite of blog posts for Haskell for Elm developers. Why specifically Elm developers? Is it because all of your colleagues are Elm developers? Or is it because like, we're doing something wrong? Or, well, we are the closest ones to be able to reach for this information, like JavaScript developers, they're not close enough, but Elm developers, they just have to know the names. And it's good. Yeah, exactly. I think knowing Elm makes you closer to Haskell than knowing any other language. Because you could consider to some point Elm to be some kind of subset of the Haskell language, like a very small subset. And then I'm a little lazy as a functional engineer, you know, and then I was wondering, hey, I really want to teach Haskell. What's the best audience to teach Haskell to? Because they have very little to learn, actually, if they want to, to learn Haskell. And also it happened to be that yes, my previous job was was Elm. And I was finding more and more Elm developers in Twitter, especially on Slack, interested into the Haskell language. I was, for example, part of the Haskell channel in the Slack. And there were many questions. So I could see there was some some kind of community or a pool of people that were trying to learn Haskell. And I thought, okay, I'm going to try to teach them. And I thought, hey, I might have something to say in this domain, that might be useful for someone else. And I really, it got me excited, because I love Haskell. And I love Elm. And I said, hey, if whatever I struggled to learn all those years, is useful for somebody else and wants to have a head start on Haskell, I'm happy to write those, you know. Do you think with hindsight, that you would have preferred learning Elm before Haskell? Would that have made it easier? Yeah. Yeah, for sure. Because it's like starting small, and then using stuff and getting proficient with things and then having the next jump. But in retrospective, I cannot regret my decision too much, because I'm hearing from some Elm developers that the gap is actually bigger than I expected when they tried to actually learn Haskell. So going the hardcore path first of trying to learn Haskell, it paid the dividends in the end, you know, it was it was worth it, because I learned Haskell, I learned Elm, and I also got to understand OCaml and Reason and many other functional languages, Fshare, for example, I was trying Fshare for some time. And I could feel that the hardest part of the language I already understood, which was incredible for me. So it was time well spent, definitely. Gotcha. I've always found Haskell to be intimidating, personally. And I mean, I think some of it is like, some of the names and operators seem cryptic to me. And it just is like a lot of concepts that are hard to make sense out of. But I'd be curious to hear your thoughts on like, for an Elm developer, what types of things might they do with Haskell? And if they, you know, if they paid that cost of learning Haskell, what are the cool things that you can build with Haskell? Except an academic career. Exactly. So, you know, now there's all this fuss going on about probably having Elm in the backend. We don't know yet, right? But there's some expectation. But before that, we don't actually know what's going to happen. Hopefully, we will have some news regarding that. But if you wanted to experience this feeling of you being in control of your code, of the compiler assisting you, of checking every possible case of your code, etc. If you wanted to have the same experience you have with Elm, but in the backend, or for something, for a more general purpose programming language that could pretty much do anything, then you needed to look for alternatives. For example, Haskell is one of them. And yeah, even though the learning curve is a little bit different, but you could do what's no Red Ink does, for example, using a small subset of Haskell as well and have packages and imports look like Elm code. And their Haskell pretty much resembles Elm. So that's a very interesting approach as well. Is it called like cherry prelude? Is that what their helper is called that gives you like an Elm-like core? I think I've looked at nri prelude is what they use like a Haskell package that turns your Haskell prelude into an Elm-ish kind of looking prelude. So that's interesting, but maybe they do something else as well. Yeah, Teresa has a package called cherry core, which is a set of basic functions, but maybe they are influenced by each other. I think at some point they may have been using Teresa's cherry core. Interesting. First time I hear about it. So one of the things that always seemed really cool to me, but also a little bit cryptic is the do notation. So maybe we should first talk a little bit about monads. We have talked about them on previous episodes, but do you want to do your best monad elevator pitch? In 10 words or less. Wow, that's gonna be difficult. Well, basically monads allow you to conditionally chain computations, basically. So when you need something like an fmap or a mapping function, but you need to have more power over what to do next, and you end up having to use monads. That's why Elm has something called and then, which reads quite nicely and it's easy to understand. But surprisingly, or the list data type, it's called concat map. So Elm was not consistent with that and then name just for lists, because it's easier to understand that you might want to flat map a list or might want to concat map something. But it's the only case in which it is not consistent. Yeah, Elm does tend to use more domain terms for naming things when possible. But then certain things like mapping, sometimes you can have a more domain like term for mapping, but usually it's just map and it's easier to just in the case of map, it's a pretty clear case where you just say, yeah, you're just mapping this data. Let's just learn the concept that you can map things. But yeah, in the case of like, and thening a list, that could be confusing. I will say since our conversation with Joelle, where we talked about some of these category theory ideas, and I expressed my difficulty with reasoning about and thening a maybe type, I now feel more confident doing that and more comfortable. It feels more intuitive. So having the discussion about some of these things has helped me a little bit with building up an intuition for this a little bit more. So I think there's definitely value to it. So yeah, so in Elm, you can end then in a JSON decoder and you can then have access to the actual decoded value in the chain so far and do something based on that. You can succeed or fail or do another JSON decoder conditionally based on that. Or in a task, you can have access to time.now, task.endthen, and then now you have the time. So Elm developers will be familiar with that general concept of and thening something. Yeah, and interestingly, it comes up a lot while trying to use effects, right? Like side effects, like for example, in I think when Elm developers use the task data type, they probably are going to eventually end up using and then, task and then, and that happens very frequently as well. I will want to go back to talk about effects afterwards, but I think Dillon wants to continue on the do notation. Sure, no problem. Well, I wonder if you can demystify that for me a little bit because I've always whenever I see a little Haskell snippet and it uses the do notation, I'm always thinking like that seems very helpful and interesting, but I don't quite understand what does it do, you might say. And I wonder if you could demystify that for me. Yeah, without showing code is kind of difficult, but I will try my best. Basically, when you want to and then a lot of things, and this happened also in some Elm code, right? For example, I'm looking at the implementation of the map five for task. It has like, task XA, task XB, like a bunch of tasks. And when you want to chain those with and then you end up having lots of nested. And how do you call the indentation? Indentation hell. Indentation, yeah. You have like a callback hell, like an indentation hell. Right, right, totally. And you cannot skip it. And I remember, for example, Martin Janicek opening an Elm format issue saying, hey, is there some way to prevent Elm format to do this indentation thing? And it's not the scope of Elm formats to fix that because it's actually code that needs to be indented semantically, right? So do notation is just the nice thing about it is that it's basically just syntactic sugar. So instead of having to indent every single lambda expression after the bind operator, it lets you a way of opening some block of code. And F sharp has this as well. But it is literally like you open a block of code in Haskell, it starts by two, and then you start to bind things into names that are going to be the result of applying that bind operator and the lambda expression. So instead of all your code going deep and deep into indentation, it allows you to have a more flat, like a vertical align kind of code that basically does the same underneath. The Haskell compiler will desugar this into all the bind and lambda expression function calls. But it just looks more natural or easier for the developer to look at the code with do notation sometimes, because people apparently in the Haskell community, some of them are not all of them are not big fans of do notation. That's a completely different topic. So is the do notation something that you would like to see in Elm as well? Or do you think it's actually better not to have it? Well, that's a that's a good question. I think it would not hurt to have it because it's like a syntactic choice. But you know that Elm is so simple that it doesn't often offer you various ways to do the same thing. It prefers one single approved way of doing things. And this makes in the end things simpler. But for example, people building like for example, Martin Janicek building this Elm in Elm compiler and having all these nested lambda expressions, these people would argue that maybe it might be useful. But being an Elm developer by myself, I've come across in a very few occasions of the need of saying, hey, I would, I would really love to do have you do notation right now. It's like you don't often nest your code that much. I know there, there's a case to be made against well, in favor of people really needing this. So I think it wouldn't hurt. But I understand why it's not included in the language. As someone who has to analyze Elm source codes, like the least amount of options that are available, the nicer it is for me. So exactly. The less amount of work. So I will actively give Evan money to not implement a new feature like that. Some people would say a happy medium would be a formatter that allows you to do that a chain of and then lambdas without the indentation increasing every time you nest a lambda. But yeah, so the do notation gives you a way to sequence things if you're comfortable putting the term sequence. Monads don't necessarily always mean a sequence because they could be a list or whatever. But it's a way of if it were tasks and you said task A, you're basically saying task A returns this value A, task B returns this value B, task C returns this value C. So given the return values for each of these, do task A, then give me the return value of it. Do task B, then give me the return value of it. And then you can combine all of those after the do. So you're basically just grabbing a return value from a sequence of and thenable things. And then you can combine them in an expression at the end of that. So now it is one thing that does stick out to me is and actually you mentioned the implementation of task map five. When I think of task map five, I actually think, well, if it's map five, wouldn't it be nice if I didn't have to end then each of them? Wouldn't it be nice if I could do it applicatively? Because you think like an applicative chain, like end map, you think parallel because you can do a sequence of things and then combine them at the end. Whereas end then you get the value and then you can continue with another value of the same type. So if you do task dot and then you need to resolve that task before you can know how to continue. Whereas in an applicative pipeline, you don't need that. So is that a point of controversy in do or a downside in do? Yeah, that's a very good point because in Haskell, there is a language extension called applicative do. So just as you said, so you can use if you toggle on this extension, you can use do notation with applicatives without needing monads. And I know lots of people when you do not need the sequencing aspect of it, like you don't need to make sure that one happens after the other. They will just turn on applicative do and have do blocks with just applicatives, which is also very useful. Hmm, interesting. Okay. Kind of feels like a cheat, like, yes, I can't do this thing in Haskell. Well, you can just enable this extension. Exactly. That's totally how doing Haskell feels like you want to do all sorts of fancy or tricky type things. You ask somewhere around and they tell you, oh, actually, you know, you can do that with that syntax. You think it should be doable, but you need to enable this and this language extension and then it works. It happens really often. Now we're back at the JavaScript babble days where everybody has their own JavaScript syntax. Exactly. Well, this is actually something I was wondering about. Is all the language extensions a problem for Haskell or is it something that introduces a lot of complexity that people try to reduce their usage of? Or is it like, no, everything enable as many as you can. You will thank me later. Yeah, this is a really controversial topic because there are hundreds of extensions and some of them are widely used. And most Haskell developers are using the same, let's say, 30 to 40 extensions. So interestingly, being a JS developer, Haskell is going the JavaScript way now in the sense that they're gathering as a standard to decide on a standard per year. For example, they gathered on GHC 2021, the committee, and they came up with a language extension called default language, rather. That was GHC 2021 that enables this list of like 20 extensions. For all files? Yes, for all files. And you can enable this in your cabal file, which is like your package.json file in Haskell, and then you can basically remove all these language extensions in from your comments in your files. Because now you're using that version of Haskell, so to speak, quote unquote, with all those language extensions enabled by default. But it is an issue because it adds complexity and some of them are a bit frowned upon if you use them. Because, for example, there is one extension called allow-ambiguous-types, which sometimes is not what you want. It doesn't sound great. Yeah, it doesn't sound great. Just for some crazy compiler logic, people who use this, they know what they're doing, but I would not know what I was doing by enabling that extension. And all these language features, is that coming from the academia world? So, from what I understand, Haskell was developed in academia, where people were trying out a lot of things like how would the language work if we did this, if this feature was in there, and all those kinds of experiments. And so Haskell is just, by default, a language that is supposed to be extensible so that researchers can try out things. Is that correct? Yeah, this is what is happening. It started in academia, but then it made its way to industry. And now it's a language that has a really difficult path ahead because it needs to accommodate both communities. So it's still used in academia, for example, it's used for researching algebraic effects and dependent types and really crazy things like the next generation of programming languages. But also there are companies like mine, like Scribe, which is using it to digitally sign contracts and it needs to work and it needs to be 100% correct. So you need to accommodate both audiences in the same language. Yeah. But it's a nice challenge. So we talked about the I-O monad briefly, we touched on that. Could you tell us a little bit about the role of I-O in Haskell and what that is? So you mentioned that originally the Haskell language, you couldn't really do anything in the real world because it was just a pure thing. And then I-O changed that. So what does I-O introduce that lets you do things in the real world? Well, I-O is like a very special monad and it's used for input, output and performing side effects, basically. So once you use code or with the I-O monad, you know that things can go wrong. So it's like when you see the CMD part of your Elm application, it's that special hole in the language that allows you to do things that can crash. And for example, people use it expecting it to be like a pure monad, but suddenly there are exceptions in Haskell and they can throw exceptions within the I-O monad. And people do not expect a language to be able to throw exceptions. But as soon as you are in the I-O monad realm, many, many things can happen. So it's interesting. It allows you on one side, you cannot do a program that does stuff without input output. So you need to eventually use the I-O monad. But as soon as you start doing things with it, you know that you need to be extra careful because that's where the whole realm of side effects and unwanted things can happen. Right, right. Yeah. So there's this kind of advice with all of these things, whether you're using the terms of monads and functors or not, just using an Elm application. There's this advice to do as much work as you can in the land of simple functions that don't know about these complicated things because that's where failures can happen. I mean, really, it's the same idea as we talked about in a previous episode about Richard's talk, Scaling Elm Applications, the general idea that the more guarantees you can have about a function, the better. So like the less things that something can return, the more narrowly scoped, the more narrowly scoped the inputs, the less your brain has to worry about what could go wrong. But I-O, it can do anything, including catastrophically failing. Exactly. Yeah, so you use it with care. But now when you say exceptions, do you mean, of course, the first thing many people will think with exceptions would be something like a JavaScript exception where it's a control flow mechanism. It changes the way the language works. You can throw and you can catch. What does an exception mean in the context of Haskell and I-O? Yes, it means exactly the same. So you have the control flow of your application. You can deliberately throw and catch exceptions. But for example, because of Haskell's legacy, for example, the list.head function is partial, meaning it's not as in Elm that it returns a maybe. If you accidentally called head on an empty list, it will throw an exception. It will crash. So this is an issue. And Haskell has in the prelude a few partial functions that will crash if you're not careful. And that's why people also created new preludes, standard preludes that don't have these issues that provide you, for example, with a non-empty list, a data type and all sorts of useful stuff. But yeah, if you come to the language thinking about, oh, this is everything going to be pure and perfect, then you're up for a surprise. Right. I mean, Haskell is the other pure language, right? Exactly. And then you don't know. No, it's not that pure. Yeah. And I guess PureScript is also somewhere in that realm, but I don't know how it works. I know even less of PureScript compared to Haskell. Yeah, I know very little about PureScript as well. But interestingly, one thing I like, which is quite mind boggling about Haskell compared to Elm, is that Elm is eager and Haskell is lazy. Ah, I was going to ask about that. So I think it's the only lazy functional programming language that is actually used and it's not useless, you know. But the whole concept of it being lazy and having different algorithms for benefiting from this laziness, it's very mind boggling as well, very surprising to me. Okay. Can you explain what lazy is and what eager is as well? And yeah, what can you do with it or why is it useful? Wow, it's a very philosophical question and hard to explain, but I will do my best. So basically in Haskell, you can define functions that are recursive. For example, you can define recursively the Fibonacci sequence and you can define things that should not compile because they depend on each other. If the compiler tries to parse all of that, it should absolutely crash, but it's lazy in the sense that it doesn't compute things until you willingly request it to do so. So Elm chose to be eager for some reason, because I think technically for HTML on the front end was needed, but Haskell is not. So for example, you define your lazy Fibonacci sequence and you say, take five on this Fibonacci sequence and you're making it just to compute up until number five. It will not compute the rest, it will not crash or it will not recurse infinity until infinity. So, yeah, from what I understand is you can create infinite lists, like all the integers, for instance, which is impossible in practice. But because those are actually not computed eagerly, you can do computations on it and just hope that you're not reaching out to infinity because then you have a problem. And I'm guessing there's some performance overhead with that as well. Yes, like there are some functions that, for example, there is foldAl, l, and foldR. So depending on whether you want to fold from left or right. And in Haskell, foldAl is known to have a performance impact because it being lazy, what it will do is just create thunks and thunks and thunks of code. And because it doesn't eagerly evaluate them until it's at the end, it can cause very huge space leaks. Yes, so a thunk is a delayed computation in a function, right? Yes. And presumably it would be a closure, meaning it carries context with it. So it prevents those things from being released in memory. So there are performance implications to that. Yes, so that's why by default Haskellers tend to use more foldR, surprisingly, when they're just folding lists and they don't care about the associativity. But also there are versions of the function which are called very weirdly foldL', which won't cause a space leak. So they're very bad at naming things. Interesting. I'm kind of confused because you say like people tend to not like the list at foldL because that creates all those thunks and performance issues. So they prefer foldR. But if you do that on an infinite list, then are you trying to get to infinity before you get to number one? Right. Or is it just like people won't do that in that case? Yeah, obviously, folding R on infinity will not work. But for finite lists of things, it definitely will work. But if you see the explanation, for example, there's a blog post from Lexi Lambda, which is really great. She was explaining why foldL is so dangerous to a colleague and it ended up being like a full blog post. And it's so interesting the way this laziness thing enables this to happen and why Haskell is the way it is. So I will probably send you a link afterwards so that you can have a look at it. It's really interesting. Yeah, we'll put it in the show notes. So what are other pitfalls that you can have with laziness and also maybe like cool things that you can do that we can't benefit from in Elm? So from my experience, for example, when you are learning algorithms and you see like the mathematical implementation of an algorithm that deals with infinite lists, for example, or infinite sequences of things. If you see the equations, you can pretty much translate those straight from math notation into Haskell and it will work, which is amazing. But it's not really doable in many other languages. But yeah, I think the huge or the main con against laziness is the space leaks thing. But it enables all sorts of also different way of thinking about algorithms that are only like it's a specialized case for lazy languages that they need to think in a different algorithms to solve the same problems that we that we're used to solving with eager algorithms, interestingly. Okay, so if you learn Haskell, if you go from JavaScript to Haskell, you first have to learn about no mutation, you have to learn about recursion, and now you also have to think about well, laziness is a thing you need to. Okay, yeah, that's that sounds like a lot of things to learn. Yes. And also, yeah, coming back to the Elm question, for example, while doing Elm, you learn about carrying and partial application and higher order functions. And these are functional concepts that are great, and you learn them and you use them instantly. But if you come from JavaScript, you might need to learn all those plus, as you said, the laziness and all the crazy Haskell stuff. So you have like a huge pile of things to learn when you want to get into Haskell from JavaScript. The one place in Elm where I can think of this eager thing coming into play is in tests where you you say test and then give it the test name as a string and then you give it you know, usually you give it a left pipe to avoid parentheses and then you give it a lambda with unit. And so that's just a way of creating laziness explicitly that and that's why the API has that because if you did your test cases without that being in a little lambda with with no data with a unit type argument, then the test runner wouldn't be able to defer execution on a test or, you know, choose to parallelize tests by selectively running different ones on different threads. There are optimizations like that. And also, if you have a test that has an infinite loop in it, you can't control which tests you want to run and say, well, I just want to try running this one. Okay, this one doesn't have an infinite loop. This one is green. Try running these other ones. These ones are red. They halt. They complete. And oh, I tried running this one and it infinitely loops. So you wouldn't be able to do that if it was eager because you'd run your test suite and they all just start running and it's an infinite loop and you don't get any feedback. The one place where I would see this be very useful, at least I would see it, I would use it a lot, is when I want to potentially compute something only once. If I have a value that I need to compute, that is pretty expensive. I have the choice in Elm to either do it once, and then it's done for forever, but at the risk of it being computed unnecessarily. If this is done, if this value is passed to a map, for instance, then it's computed once, even if no one will ever reach for it. The other option is to compute it every time that I need it, which means that if I never need it, I will never compute it. But if I do need it multiple times, then I will compute it multiple times. I feel like laziness here really helps because it will only be computed once it's needed. So that feels quite nice. This is something that I've thought about suggesting for the Elm language as well, but I have not come up with a good enough proposal. Interesting. Also, maybe Evan explained why Elm is eager by default, but I'm sure there are some technical reasons why he chose to, and it would be interesting to read all of those. I'm guessing because it compiles to JavaScript, that's a big part. JavaScript is eager as well. So if you want to make it lazy, then you have to add a whole lot of lazifying layer. Yeah. And a lot of the Elm philosophy is reducing the barrier to entry and being very simple and obvious. And lazy is just, it's like a powerful thing, but a sharp knife that comes with a lot of caveats and things to be careful about. And that's just kind of counter to the Elm philosophy. So I think it fits in the Elm philosophy to be avoiding that. Because I've heard a lot of people talking about gotchas with lazy. So it comes with its fair share of caveats and things to be careful about. Okay. Effects. So you mentioned effects before. I know that there are some effects in Elm as well, like in the implementation of things like platform.command, maybe of task as well. And people who do Haskell seem to be familiar with that. And I have no clue what it is. I do think there was a blog post explaining that a few years ago for Elm, which was really good, but I've forgotten everything that it said. I should reread it. But yeah, can you explain to me what effects are and what are they for? Well, actually it's kind of an interesting topic because for me, effects are just like things or computations that happen on, for example, like on an input output or on a side effect kind of world. But I know that when people refer to effects, they are mostly talking about either effect systems or algebraic effects, which is something that also looks to me really scary and abstract. And Haskell, I know there are a few Haskell libraries that try to implement this concept of algebraic effects, but to my knowledge, none of them is like a hundred percent solved all the edge cases and things to deal with those effect systems. But yeah, for example, there is one effects library called Effectful. It's gaining some traction in the Haskell community and the creator happens to work in the same company I do. So my company is fully switching to, instead of using monad transformers, which is like a way of trying to compose and combine monads, is the de facto standard in Haskell. And then they are switching from this monad transformer stack to Effectful to try to use this effect system in a simple way and in a way that the code looks actually readable and usable without understanding all the machinery behind it. But to be honest, since I haven't dwelled too much into it, I am not an expert in effects at all. So I feel as lost as you both. That's fair. That's fair. Is it the same general idea as it is when we use the term effect in Elm, where it's creating a data type that represents a possible effect without executing it? Like a command, if you pass it to update or init in Elm, a command will do something, whereas an effect needs to be given a perform function to turn it into a command. Is it the same concept or is it a different concept? Yes, I know there is something along those lines, like declaratively dealing with effects and computations. But it's a term that is also used with the same name in different languages for different things. So it's quite confusing as well. Oh no, OCaml, what have you done again? Exactly. So on the topic of effects, back to I-O a little bit. One thing that I've wondered, so I've been implementing some effect-y, I-O-y things in Elm Pages. There's a backend task similar to an Elm task, but in Elm Pages v3, it's full stack, so you can do things in a backend context. And so one of the things as I was designing it was I was thinking about Haskell I-O, and I was like, why is there one type variable in I-O? So in Haskell, you can chain I-O to, I guess, like read from a file, and then given the thing you read from a file, you can map that into something. But if an error happens, you don't know what type of error data, if I'm understanding correctly, that is erased from the type. The possible error data is erased in the I-O type, whereas if you look at the Elm core task type, it's task error value, and you can map error. And you can task.perform says it takes a task that never errors, and you can recover from errors in this, you know, I don't want to say monadic style, because I know it's not technically following monadic laws, but that sort of explicit way of chaining things together and knowing the types based on the type signature. So what's the deal with that in Haskell? Why does I-O not have an error type represented in its type variables? So I know that I-O has this type variable because obviously like a monad needs to have it. Right? Because you think about maybe or either, well, which is called result in Elm, it needs to have something to wrap around because it's a wrapper in the end. That's why all the memes of monad being burritos comes from. But basically, for example, the simplest example of people using the I-O monad to perform side effects or to do stuff like, for example, printing to the command line, they're using I-O and then open and close bracket, like the unit type. So it's like, it's an I-O that is going to perform nothing effect. And you will see these in type signatures all across many Haskell code bases. Why it doesn't have more than one type variable? I really don't know, but it's an interesting question. Yeah. Well, so if you can throw an exception, like when you catch an exception, do you know the type of the exception? Do you catch it? Do you catch it through the monad, the I-O monad interface? Or is it just a completely separate thing that is not specific to I-O to deal with exception handling? Yes, it's specific to I-O and all exceptions are typed. So when you catch an exception, the I-O or Elm, you get lots of information from that exception and you can use it to your will as well. You can then use it to your needs. Interesting. Okay. Well, that's nice that they're typed. That's always like the most frustrating thing for me in TypeScript is that you catch an exception and it just completely forgot what might have happened along the chain. You know nothing about it nearly, right? Right, right. Are you forced to acknowledge that something could throw an exception? And I'm guessing no, anything can just throw an exception and you don't have to annotate it or allow it to fail in any way. Yeah, that's the thing, like the Haskell etiquette or the standards that we try when we do pull request reviews and all that. Obviously, you should know do things without signifying this in type signature. But it's kind of like a paradox or like strange that some prelude functions because of legacy or inherited reasons do throw exceptions when you don't. But it's like, okay, there's a few catches. People know about those functions. They are known to be dangerous. So either they use them with care or they don't use them at all and they use some safe alternative from a well-established library. But obviously, yeah, you are doing Haskell for the same reason you would like to do Elm. You would like to trust 100% in purity and not having to worry about strange stuff. But for example, there is a placeholder called undefined, which is like the debug.todoElm thing that you can just give a name and don't implement thing. So that's a keyword called undefined. Undefined takes a string. Is that it? No, no. Undefined is a value on itself. But it's not a function. Yeah, no, it's not a function. Undefined is not a function in Haskell. But there is an undefined and it's considered to be the bottom value is, you know, you're not meant to to ship code using it. But you can signal that something is not implemented by just putting an undefined there in the code base. Gotcha. OK. Yeah, that's useful. You're not meant to ship code with that, but you could ship code with that. Exactly. I think so. Like there's no checking the package registry or something that prevents you from shipping code with undefined. It's so interesting because like in a way you would you would tend to think of like Haskell as the purists, not Elm. But in a way like Elm really the thing that Elm is a purist about is purity. And Haskell is like less of a purist about that, but maybe more of a purist about like category theory. I mean, I guess to some extent, if it's roots in academia, right. And researchers, they try to design a language with language extensions. Well, they don't have to think about all the edge cases. They care mostly about some area of computation of some area of research. And whether you handle all the edge cases is doesn't really matter. So it's fine to have a few undefined in a language if you're only trying to to figure out to answer a specific question where this is not going to happen. And Elm is really more pragmatic or meant for production. So it makes sense that we have it there, though, I guess some people would say, well, if you can't just call JavaScript through FFI, then you're not very pragmatic. But that's a topic. Yeah. Also, I think there is some kind of check in the Elm package registry that prevents you from publishing code with debug.to on it. Right. So it's not happening, basically. So there are security guards against that. Yeah. Thankfully. I don't know when it appeared, though. I'm guessing it was pretty recent. But because you could at least have applications with debug.crash in 0.18 or 0.17. Right. Yeah, I remember that, actually. Yeah. But I don't know if you could have them in packages. That I don't remember. I was worried about it because recently I contributed to Elm format. I added a few linear parser things. And then someone told me, hey, you are parsing this fat arrow into this slim arrow lambda thing. But prior to Elm 19, someone could have an infix operator being a fat arrow. And I was so scared about my PR not being correct, because the only version of Elm I've used is just 0.19 onwards. And it's like, wow. So I really do need to extend now my PR and add a test for this specific case that I wasn't expecting. I remember the convention was to define the fat arrow as creating a tuple. So you could have key value pairs. And instead of doing, you know, like if you did dict from list with a literal list, and then you give a list of tuples, instead of doing dict from list, a list with tuple, some value, comma, some value, next tuple, some value, comma, some value, you would do list value, fat arrow value, comma, key, fat arrow value. Yeah. So it would be like tuple.pair? Yep, it was exactly like that. Wasn't there like the daughter sign for the same purpose? Like, I remember that people did a model daughter sign command at none or something, quite a lot. Oh, gosh, I'd forgotten about that. It's completely left my memory now. But there was something about getting something with no command or whatever. Yeah. Actually, I think, Flavio, in one of your blog posts, you say something like, oh, in Haskell, you can use the comma operator to make a tuple. Well, I think it was there in Elm, and it was the daughter sign, which I guess was even more confusing for people who use Haskell because the daughter sign is something very different. I think it's the function composition. The daughter sign is the left pipe in Elm. Oh, it's a pipe, yeah. Yeah, daughter is used a lot. Yeah. To prevent the usage of parentheses. Right, right. Yeah, and there also used to be the parentheses comma parentheses operator to create a tuple in Elm. As well? Or with two commas to create a triple. Hmm. That used to be there, and now it's tupled up here. But yeah, so all these things, I mean, it is a very different, like, what makes idiomatic Haskell is so different. And it definitely seems like in the Haskell ecosystem, people really like being able to express things tersely with operators. And in Elm, we shy away from that. Yeah, we don't use those Greek letters as well. Right. One thing you mentioned in your blog post on Functors Flavio is about function composition and about how any chain of list.map with functions or any sort of chain of maps can be turned into a single map with the composition operator. Like greater than, greater than operator, or less than, less than operator, if you're into that sort of thing. But some people in Elm I've noticed shy away from the composition operator. And sometimes I myself find it difficult to reason about things in a pipeline versus a lambda. So I'll opt for doing a lambda. What are your thoughts on this sort of like point-free style? From what I understand, that's very common in Haskell. Yeah, even within Haskell, there is like a fight, you know, that people prefer Terrace programming or Taft programming. Some of them prefer point-free and some of them don't. But personally, I'm a bit of a point-free freak. So I need to refrain myself from using too much point-free code. And I have this issue with Elm as well. So I reach for the composition operators very often, and only when I get some complaints from my Elm colleagues saying this is unreadable or this is not maintainable or blah, blah, blah. Then I will change the code to use Python, for example. But yeah, the thing I wanted to say or to convey in my post that I think I a little bit failed is when you cannot talk about functors or applicatives or monads without speaking about laws. So they must fulfill certain laws. And one of the very simple laws for functors is that they need to preserve composition. So if you compose things that do nothing, for example, if you compose with the identity function, nothing should happen. It's equal to doing basically nothing. And this little law is what makes possible that you can either map n times or just compose n times and then map once, which in JavaScript tends to be like a performance optimization. But it depends on how your language implements these things. Right. Right. So what would be your pitch to somebody to consider using point-free style or something closer to point-free style more often? Well, it depends on the case by case scenario. But, for example, when you're using mapping functions or functions that return a Boolean, like in a condition to some other function, sometimes I feel like by adding a lambda with an extra argument adds a little bit of noise. And if you get used to composition and you, for example, in Elm, the composition operators read really nicely because you can either do left to right composition or right to left composition. And when you see the functions, you clearly you can read in the code, oh, we are running this function, then the next one and then the next one. And I don't really care what the name of the argument or of the lambda is, because I just don't care because it's a function that expects a function. So I would find that sometimes it reads a little bit better, but it's totally a personal choice and a matter of usage and about a personal intuition. So I would not force it on my colleagues where they are learning functional programming, for example. You need to be very, very soft and very not strict about it. I see. So you think that giving names to parameters in anonymous functions is pointless or point free? It's pointless. Only if you're a point freak. Exactly. All the puns were coming. Yeah, it depends on the scenario. But yeah, I think sometimes the lambdas add a little bit noise and they are a bit pointless. So then I prefer point free. I see. That's interesting. Yeah, I think that makes sense. I would say on the other side of that, you know, sometimes I think about like certain designs and idioms resist refactoring. I remember in my Ruby days, people talked a lot about this with certain language constructs that like using unless instead of if. And it's just like, well, OK, you can use unless, but you're introducing potentially a lot of churn if that condition changes in the future. Or if you add an else clause, now are you going to have an unless else? That's just weird. So some people just say, let's just not use unless because it's prone to churn. And one thing that I've found is that like using the composition operator greater than greater than is convenient in some cases. And in some cases I do reach for it. But I do find myself flipping that to a lambda with an explicitly named argument pretty often, and it creates a little bit of churn in the code when I'm refactoring. So that would be one argument against it. Also, it's like there's a certain point where you're like, well, I'm having to think pretty hard about what this is doing when you're chaining like enough things together. And you're like, if I just if this was just like a lambda, I wouldn't have to think quite so hard. So I think like that's one argument I've heard in the opposite direction. I think I think there's a reason for both sides. Maybe the right answer is somewhere in the middle. Yeah, for me, it was there's a talk called Tacit Programming Point Free or Die or something like that that was given at Strange Loop some years ago. And it is more reasonable than the title makes you think. But it is basically Haskell code. And for example, you want you you're used to seeing JavaScript code when people will just open a lambda, say X lambda, then console log of X. Right. So functions with one point, you see that and you say, oh, the point is pointless. So the X is pointless. And you can just say console log as a function. Right. But when it gets crazier in Haskell is when you do not have one function argument, you have two. And they're passed as they are giving A and B to the next function A and B. And you cannot you cannot do this the same way. But there is an operator called the Blackbird operator, which I just learned about like a month ago that allows you to pass these two point function the next function. But the code starts to get really, really messy and really crazy. And that's why it says, you know what, do what's readable. If if that's the programming reads better, sometimes just use it. If it doesn't, please don't overuse it. Basically, but it's a really great talk. Right. Yeah. I mean, at the point that you start reaching for for flip, then you might consider just naming that argument in a lambda. Yeah. Yeah. I miss flip a lot of times in Elm. Yeah, but it's because of me being a pointless freak. Right. I guess that's why carry and uncarry and flip were removed from the prelude of Elm, you know. Right. Now, OK, why don't you go ahead and define those for those of us who haven't used them? I don't think I ever used I don't think I ever used any of those, actually, even back in the 18 days when it was around. I'm sure I did either. But I started basically with 0.19 as well, even though I did it back a little bit back in 0.16. Flip is a function that, for example, expects a function that takes is a function that expects a function that takes two arguments and then returns a result. So you have a B and the result would be C. So sometimes the order of the arguments you expect for a certain function is B, A and then X. But you you cannot change the order because of the way your code works or whatever. So this flip function is very convenient because it lets you flip the arguments of the function you're calling. And it's also a mathematical concept because you can also flip functions mathematically. But it is kind of magic that this does that this works. But if you see the function implementation, it's not magic at all. You know, right. So flip does that. And there there's uncarry. You know that all the functions are carried in Elm, which means that they all receive just one argument and return a function that also returns expects one argument and returns one. And there is a case in which you might want to uncarry a function so that it receives all of the arguments at the same time. And the only way to do this in Elm is to use uncarry. And now instead of expecting arguments one by one, it will just expect a tuple of arguments. And then it will give you a result. Right. Interesting. And most mostly useful for for chaining things in a point freestyle. Yes, I tend to reach for those basically when you are doing crazy point free stuff. You find that you haven't defined your functions in the best order possible because for composition to work properly, the functions need to be data last. Right. And for functions that have expect more than one argument, you sometimes do not choose the correct or the order that you were expecting. And you end up flipping lots of functions. Yeah. Things like dig.union or set.diff. Probably more the diff than union. For diff is really tricky because you think that you're doing the same thing, but depending on the order, you might be diffing two completely different, getting two out. Yeah. So that one definitely I tried to avoid using composition because it's difficult enough already. Yes, it's true. So maybe to round off, we've seen that Elm and Haskell are very similar languages where they look a lot like each other. So it's pretty easy to jump from Elm to Haskell relatively compared to other languages at least. And Haskell has quite a large learning curve. So we've talked about category theory. We've talked about laziness. We've talked about language extensions. Well, we kind of did talk about category theory and you also told us to shut up about that. But yeah, what other concepts are useful to learn in Haskell? Or would someone who goes from Elm, who would go to Haskell, what would they need to learn on top of these? Or in other words, what could your next blog post be about? Nice. So there are a couple of things. For example, we talked a little bit, well, I talk in my posts about infix operators. Elm has some of those, but you cannot user define them anymore. So the most famous ones in Haskell are the ones in the Lens library, which is a library that is very famous because it produced a set of Lens libraries for many other languages. A Lens is basically something that allows you to, it's a functional getter and setter that allows you to manipulate data on a deeply nested data structure, basically. And they come from Haskell and they are useful in JavaScript, for example, to traversing JSON, really huge nested JSONs and doing things on the level you want. And we don't have, unfortunately, per se, Lenses in Elm, but I know that there are people who build their own Lens libraries or they're building code generators for Elm that are able to use Lenses in Elm. But it's not like a common pattern that it's used in the Elm community. There are a few packages out there. At least a couple, right? At least a couple, which is a lot for the Elm community. In terms of packages and for something that is sometimes frowned upon. You have your set of choices. So Lenses would be one thing. Well, getting acquainted with a lot of crazy infix operators is another thing. And also just knowing that there are many ways to do the same thing. Like, for example, there are two or three ways of doing pattern matching in Haskell, whereas in Elm there's only one. The case of syntax. There are pattern guards and pattern synonyms, which are things that are meant to help you simplify pattern matches. And many other constructs that we don't have, but I would bet you don't really actually need in Elm. Also, I'd like to say that even though it's not language related, but ecosystem related. Because of the Haskell academia nature, there is no formatter that came by default with the language as we do have with Elm format. And in the build tool, which is Cabal, there's also a war. There's one called Cabal and one called Stack. And both of them work, but both of them have serious deficiencies. So it's such a bless to have something like the Elm compiler or something that is curated and that comes by default with a formatter with one single style to rule them all. And it's something I really, really, really miss in Haskell sometimes. I would be invited on a Haskell podcast to teach Elm for Haskellers. Flavio would be a much better person to be on that podcast episode as well. I mean, the episode would be pretty short. Like, take Haskell, remove everything, and you've got Elm, basically. And please use a formatter. You know functions? Yeah, we have those. Functions over data? Yeah, that's Elm. I guess something I hear a lot is GADTs, but I don't know if that's a language extension. Yeah, it is a language extension. Generalized algebraic data types. Which is like our custom types, but more powerful. It's a custom type, but it's a polymorphic custom type that you can parametrize just as OCaml functors. So I haven't really reached for GADTs in Haskell, because they come up when you really need to do really abstract, really complex stuff. But for many library authors and compiler creators as well, I know they reach for GADTs very often. And I know there are some measures, some things similar to GADTs in OCaml as well. And people are really crazy about GADTs. But for the average programmer, even the concept of it, even for me, it's crazy. It's very hard to grasp, very hard to use, and very hard to understand. But yeah, there are GADTs. Gotcha. I'm sure Dillon would use GADTs in Elm pages or in the Elm GraphQL for sure. I've definitely thought about some of these things. There are definitely certain compromises to Elm's simplicity. And it's actually impressive how often we can get by without running into limitations with the number of language features that Elm gives us and their simplicity. Like a custom type is such a simple thing. And there's an extreme elegance to just how little there is to that concept. But I definitely have thought as a package and framework author, at times I'm like, hmm, yeah, if there was some way to have a more general way to deal with this, like to be able to let users have a more customizable custom markdown block type. We don't have a lot of tools for extensibility. So we end up using a lot of code generation as framework and tooling authors to create extension points or very clever design. But we've actually managed to figure out a lot of clever tricks to do these things and give a pretty good experience to the user at the end of the day. But it takes a lot of love as a designer of these tools. Yeah. I'm guessing in your case, a Haskell person would come in and say, hey, I have a language extension for this. Or it's just baked in that a type class would solve this problem for you maybe. Exactly. Yes. How could I forget about type classes? This is the main thing that you need to learn from Haskell, for Haskell if you are coming from Elm, basically. And it's also the crown of Haskell, right? Type classes. And it's an idea that I think it was born with Haskell, and it's extended to traits in Rust, and it influenced greatly many other languages. Because it's such a great thing as well. Right. So would a type class allow you to say that this function takes a data structure that you can index into, but you could use an ordered dictionary or an unordered dictionary, and it would support operations on both because it needs a certain class of functions? Exactly. Yeah. Some people compare them to interfaces in object-oriented programming, but they're a little bit more powerful than interfaces. So, for example, we've discussed about monad and functor and applicative functor. Those are basically type classes in Haskell. You can define them, define the methods that they need to implement to be considered instance of a certain type class. And also we have type class tests and property tests that we can check against to make sure that a type is a semi-group, a monoid, or whatever type class. Yeah. So much stuff to discuss. So if somebody wants to do a deeper dive into Haskell, do you have any favorite resources to point them to? I think there's the Elm Guide, which is a good introduction. Definitely. Actually, for me, the ideal learning path would be, for example, learning JavaScript. And then, for example, I read Richard Feldman's Elm in Action, which I think it does a pretty good job teaching Elm to a JavaScript mindset. And then from Elm to Haskell, well, I obviously would recommend my blog posts, my series of blog posts. Yes. But as well, this Haskell book, Learning Haskell from First Principles, it's an excellent resource, even though it's a little bit long. But it just does a perfect job of explaining from almost ground zero what you need to know. It almost teaches you what the string is and a function is before dipping dive into... diving deep, sorry, into Haskell. Is it one of those books where Hello World is chapter 12? Exactly. Yes. Or chapter 20. Yes. Okay. I think Monads, I think Functors is chapter 12, and then Applicatives 13, and then Monads is chapter 16 or something like that. I have to confess, I read chapter one of this book years ago, like six years ago, about lambda calculus. And I diligently went through... Skip chapter one. You can skip it. I diligently went through all of it. I had my pencil and paper and I did those lambda calculus exercises and I understood lambda calculus a little better. And then I'm like, okay, I think that's all. That's it. Exhausted my energy for going through it. Yeah, I think I kind of understand why they decided to put lambda calculus on the first chapter. But I know that many people haven't gone through the first chapter. So it's a terrible entry barrier. You can pretty much read the book without reading the first chapter. But it's basically like we do in Elm, programming with expressions, not statements. So this is an invaluable skill, in my opinion, that will get you really, really far, understanding the whole expressions thing. Right. Yeah. Well, great stuff. And Flavio, thanks again for joining us. And thanks for your blog posts. And looking forward to hearing more in the future. My pleasure. Thank you. Thank you both for having me. Thank you for coming. And Jeroen, until next time. Music.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 2.0, "text": " Hello Jeroen.", "tokens": [2425, 508, 2032, 268, 13], "temperature": 0.0, "avg_logprob": -0.28693933770208074, "compression_ratio": 1.6682027649769586, "no_speech_prob": 0.5429171323776245}, {"id": 1, "seek": 0, "start": 2.0, "end": 3.0, "text": " Hello Dillon.", "tokens": [2425, 28160, 13], "temperature": 0.0, "avg_logprob": -0.28693933770208074, "compression_ratio": 1.6682027649769586, "no_speech_prob": 0.5429171323776245}, {"id": 2, "seek": 0, "start": 3.0, "end": 11.0, "text": " You know, I've always wanted to map Haskell concepts to Elm and well I guess it would be f-mapping then, wouldn't it?", "tokens": [509, 458, 11, 286, 600, 1009, 1415, 281, 4471, 8646, 43723, 10392, 281, 2699, 76, 293, 731, 286, 2041, 309, 576, 312, 283, 12, 1696, 3759, 550, 11, 2759, 380, 309, 30], "temperature": 0.0, "avg_logprob": -0.28693933770208074, "compression_ratio": 1.6682027649769586, "no_speech_prob": 0.5429171323776245}, {"id": 3, "seek": 0, "start": 11.0, "end": 17.0, "text": " Well, it really depends on whether you have a list of things that you want to learn or if you have other things you want to learn.", "tokens": [1042, 11, 309, 534, 5946, 322, 1968, 291, 362, 257, 1329, 295, 721, 300, 291, 528, 281, 1466, 420, 498, 291, 362, 661, 721, 291, 528, 281, 1466, 13], "temperature": 0.0, "avg_logprob": -0.28693933770208074, "compression_ratio": 1.6682027649769586, "no_speech_prob": 0.5429171323776245}, {"id": 4, "seek": 0, "start": 17.0, "end": 24.0, "text": " I guess you could say maybe this episode would be like a type of class, you could say.", "tokens": [286, 2041, 291, 727, 584, 1310, 341, 3500, 576, 312, 411, 257, 2010, 295, 1508, 11, 291, 727, 584, 13], "temperature": 0.0, "avg_logprob": -0.28693933770208074, "compression_ratio": 1.6682027649769586, "no_speech_prob": 0.5429171323776245}, {"id": 5, "seek": 2400, "start": 24.0, "end": 32.0, "text": " Well, today we've got Flavio Korfa joining us. Flavio, thanks so much for coming on the show.", "tokens": [1042, 11, 965, 321, 600, 658, 3235, 706, 1004, 21690, 11771, 5549, 505, 13, 3235, 706, 1004, 11, 3231, 370, 709, 337, 1348, 322, 264, 855, 13], "temperature": 0.0, "avg_logprob": -0.19216909113618516, "compression_ratio": 1.5787037037037037, "no_speech_prob": 0.004345013294368982}, {"id": 6, "seek": 2400, "start": 32.0, "end": 33.0, "text": " Hello, my pleasure.", "tokens": [2425, 11, 452, 6834, 13], "temperature": 0.0, "avg_logprob": -0.19216909113618516, "compression_ratio": 1.5787037037037037, "no_speech_prob": 0.004345013294368982}, {"id": 7, "seek": 2400, "start": 33.0, "end": 43.0, "text": " So Flavio, you wrote a really nice set of blog posts about Haskell for Elm and you named the series Giving Names to Stuff.", "tokens": [407, 3235, 706, 1004, 11, 291, 4114, 257, 534, 1481, 992, 295, 6968, 12300, 466, 8646, 43723, 337, 2699, 76, 293, 291, 4926, 264, 2638, 28983, 426, 1632, 281, 31347, 13], "temperature": 0.0, "avg_logprob": -0.19216909113618516, "compression_ratio": 1.5787037037037037, "no_speech_prob": 0.004345013294368982}, {"id": 8, "seek": 2400, "start": 43.0, "end": 51.0, "text": " And I like that name and if we could just start with why did you title the series Giving Names to Stuff?", "tokens": [400, 286, 411, 300, 1315, 293, 498, 321, 727, 445, 722, 365, 983, 630, 291, 4876, 264, 2638, 28983, 426, 1632, 281, 31347, 30], "temperature": 0.0, "avg_logprob": -0.19216909113618516, "compression_ratio": 1.5787037037037037, "no_speech_prob": 0.004345013294368982}, {"id": 9, "seek": 5100, "start": 51.0, "end": 64.0, "text": " It seems like there's something important to you that you wanted to convey to Elm developers with your Haskell background about names and how names relate to type classes.", "tokens": [467, 2544, 411, 456, 311, 746, 1021, 281, 291, 300, 291, 1415, 281, 16965, 281, 2699, 76, 8849, 365, 428, 8646, 43723, 3678, 466, 5288, 293, 577, 5288, 10961, 281, 2010, 5359, 13], "temperature": 0.0, "avg_logprob": -0.21718326246882058, "compression_ratio": 1.6621004566210045, "no_speech_prob": 0.0005728654796257615}, {"id": 10, "seek": 5100, "start": 64.0, "end": 69.0, "text": " So why do you think names are important and why are they important for your blog series?", "tokens": [407, 983, 360, 291, 519, 5288, 366, 1021, 293, 983, 366, 436, 1021, 337, 428, 6968, 2638, 30], "temperature": 0.0, "avg_logprob": -0.21718326246882058, "compression_ratio": 1.6621004566210045, "no_speech_prob": 0.0005728654796257615}, {"id": 11, "seek": 5100, "start": 69.0, "end": 71.0, "text": " That's a very interesting question.", "tokens": [663, 311, 257, 588, 1880, 1168, 13], "temperature": 0.0, "avg_logprob": -0.21718326246882058, "compression_ratio": 1.6621004566210045, "no_speech_prob": 0.0005728654796257615}, {"id": 12, "seek": 5100, "start": 71.0, "end": 76.0, "text": " I always wanted for someone to ask me about the name of the series.", "tokens": [286, 1009, 1415, 337, 1580, 281, 1029, 385, 466, 264, 1315, 295, 264, 2638, 13], "temperature": 0.0, "avg_logprob": -0.21718326246882058, "compression_ratio": 1.6621004566210045, "no_speech_prob": 0.0005728654796257615}, {"id": 13, "seek": 7600, "start": 76.0, "end": 81.0, "text": " And I was also waiting for your puns at the beginning of the episode.", "tokens": [400, 286, 390, 611, 3806, 337, 428, 4468, 82, 412, 264, 2863, 295, 264, 3500, 13], "temperature": 0.0, "avg_logprob": -0.2999731699625651, "compression_ratio": 1.5515463917525774, "no_speech_prob": 0.00039462291169911623}, {"id": 14, "seek": 7600, "start": 81.0, "end": 92.0, "text": " I keep forgetting that he's going to do some until he's saying, I'm like, oh yeah, I didn't prepare anything.", "tokens": [286, 1066, 25428, 300, 415, 311, 516, 281, 360, 512, 1826, 415, 311, 1566, 11, 286, 478, 411, 11, 1954, 1338, 11, 286, 994, 380, 5940, 1340, 13], "temperature": 0.0, "avg_logprob": -0.2999731699625651, "compression_ratio": 1.5515463917525774, "no_speech_prob": 0.00039462291169911623}, {"id": 15, "seek": 7600, "start": 92.0, "end": 95.0, "text": " Get your cringe phrase ready.", "tokens": [3240, 428, 47081, 9535, 1919, 13], "temperature": 0.0, "avg_logprob": -0.2999731699625651, "compression_ratio": 1.5515463917525774, "no_speech_prob": 0.00039462291169911623}, {"id": 16, "seek": 7600, "start": 95.0, "end": 101.0, "text": " It's a pretty recent thing. He didn't do this in the beginning. And now he just can't stop.", "tokens": [467, 311, 257, 1238, 5162, 551, 13, 634, 994, 380, 360, 341, 294, 264, 2863, 13, 400, 586, 415, 445, 393, 380, 1590, 13], "temperature": 0.0, "avg_logprob": -0.2999731699625651, "compression_ratio": 1.5515463917525774, "no_speech_prob": 0.00039462291169911623}, {"id": 17, "seek": 10100, "start": 101.0, "end": 106.0, "text": " So it's a new thing or it's a modern thing in the podcast then, the puns.", "tokens": [407, 309, 311, 257, 777, 551, 420, 309, 311, 257, 4363, 551, 294, 264, 7367, 550, 11, 264, 4468, 82, 13], "temperature": 0.0, "avg_logprob": -0.2338306341278419, "compression_ratio": 1.5355450236966826, "no_speech_prob": 0.00023511586186941713}, {"id": 18, "seek": 10100, "start": 106.0, "end": 110.0, "text": " I'd say so.", "tokens": [286, 1116, 584, 370, 13], "temperature": 0.0, "avg_logprob": -0.2338306341278419, "compression_ratio": 1.5355450236966826, "no_speech_prob": 0.00023511586186941713}, {"id": 19, "seek": 10100, "start": 110.0, "end": 122.0, "text": " So related to Giving Names to Stuff, I first learned Haskell and it took me a while because it's quite a big language to learn and a bit wide.", "tokens": [407, 4077, 281, 28983, 426, 1632, 281, 31347, 11, 286, 700, 3264, 8646, 43723, 293, 309, 1890, 385, 257, 1339, 570, 309, 311, 1596, 257, 955, 2856, 281, 1466, 293, 257, 857, 4874, 13], "temperature": 0.0, "avg_logprob": -0.2338306341278419, "compression_ratio": 1.5355450236966826, "no_speech_prob": 0.00023511586186941713}, {"id": 20, "seek": 10100, "start": 122.0, "end": 127.0, "text": " And then at some point I had some front-end experience and JavaScript experience prior to that.", "tokens": [400, 550, 412, 512, 935, 286, 632, 512, 1868, 12, 521, 1752, 293, 15778, 1752, 4059, 281, 300, 13], "temperature": 0.0, "avg_logprob": -0.2338306341278419, "compression_ratio": 1.5355450236966826, "no_speech_prob": 0.00023511586186941713}, {"id": 21, "seek": 12700, "start": 127.0, "end": 134.0, "text": " At some point I realized that I wanted to try out Elm and that I already knew Elm because the syntax is so similar to Haskell.", "tokens": [1711, 512, 935, 286, 5334, 300, 286, 1415, 281, 853, 484, 2699, 76, 293, 300, 286, 1217, 2586, 2699, 76, 570, 264, 28431, 307, 370, 2531, 281, 8646, 43723, 13], "temperature": 0.0, "avg_logprob": -0.17528984326274455, "compression_ratio": 1.7411764705882353, "no_speech_prob": 9.735295316204429e-05}, {"id": 22, "seek": 12700, "start": 134.0, "end": 137.0, "text": " And the Elm compiler is made in Haskell.", "tokens": [400, 264, 2699, 76, 31958, 307, 1027, 294, 8646, 43723, 13], "temperature": 0.0, "avg_logprob": -0.17528984326274455, "compression_ratio": 1.7411764705882353, "no_speech_prob": 9.735295316204429e-05}, {"id": 23, "seek": 12700, "start": 137.0, "end": 141.0, "text": " So when you learn Haskell, they sort of teach you the other way around.", "tokens": [407, 562, 291, 1466, 8646, 43723, 11, 436, 1333, 295, 2924, 291, 264, 661, 636, 926, 13], "temperature": 0.0, "avg_logprob": -0.17528984326274455, "compression_ratio": 1.7411764705882353, "no_speech_prob": 9.735295316204429e-05}, {"id": 24, "seek": 12700, "start": 141.0, "end": 144.0, "text": " They teach you the names first and then the patterns that you use.", "tokens": [814, 2924, 291, 264, 5288, 700, 293, 550, 264, 8294, 300, 291, 764, 13], "temperature": 0.0, "avg_logprob": -0.17528984326274455, "compression_ratio": 1.7411764705882353, "no_speech_prob": 9.735295316204429e-05}, {"id": 25, "seek": 12700, "start": 144.0, "end": 148.0, "text": " But in Elm, it's amazing because you don't really need to know the names of things.", "tokens": [583, 294, 2699, 76, 11, 309, 311, 2243, 570, 291, 500, 380, 534, 643, 281, 458, 264, 5288, 295, 721, 13], "temperature": 0.0, "avg_logprob": -0.17528984326274455, "compression_ratio": 1.7411764705882353, "no_speech_prob": 9.735295316204429e-05}, {"id": 26, "seek": 12700, "start": 148.0, "end": 151.0, "text": " You just use them and you gain an intuition for them.", "tokens": [509, 445, 764, 552, 293, 291, 6052, 364, 24002, 337, 552, 13], "temperature": 0.0, "avg_logprob": -0.17528984326274455, "compression_ratio": 1.7411764705882353, "no_speech_prob": 9.735295316204429e-05}, {"id": 27, "seek": 15100, "start": 151.0, "end": 158.0, "text": " And you see them in practice. How are they useful? How they make you a better programmer or why would you need such patterns?", "tokens": [400, 291, 536, 552, 294, 3124, 13, 1012, 366, 436, 4420, 30, 1012, 436, 652, 291, 257, 1101, 32116, 420, 983, 576, 291, 643, 1270, 8294, 30], "temperature": 0.0, "avg_logprob": -0.22799337477911086, "compression_ratio": 1.5333333333333334, "no_speech_prob": 0.00036753652966581285}, {"id": 28, "seek": 15100, "start": 158.0, "end": 167.0, "text": " So while trying to explain a little bit of Haskell to my Elm friends, I just noticed you just need to know the names for stuff you already use.", "tokens": [407, 1339, 1382, 281, 2903, 257, 707, 857, 295, 8646, 43723, 281, 452, 2699, 76, 1855, 11, 286, 445, 5694, 291, 445, 643, 281, 458, 264, 5288, 337, 1507, 291, 1217, 764, 13], "temperature": 0.0, "avg_logprob": -0.22799337477911086, "compression_ratio": 1.5333333333333334, "no_speech_prob": 0.00036753652966581285}, {"id": 29, "seek": 15100, "start": 167.0, "end": 171.0, "text": " That's why I chose the name, basically.", "tokens": [663, 311, 983, 286, 5111, 264, 1315, 11, 1936, 13], "temperature": 0.0, "avg_logprob": -0.22799337477911086, "compression_ratio": 1.5333333333333334, "no_speech_prob": 0.00036753652966581285}, {"id": 30, "seek": 15100, "start": 171.0, "end": 173.0, "text": " I love that.", "tokens": [286, 959, 300, 13], "temperature": 0.0, "avg_logprob": -0.22799337477911086, "compression_ratio": 1.5333333333333334, "no_speech_prob": 0.00036753652966581285}, {"id": 31, "seek": 17300, "start": 173.0, "end": 183.0, "text": " So did you think it was important for Elm developers to know the names for these things if they want to try Haskell?", "tokens": [407, 630, 291, 519, 309, 390, 1021, 337, 2699, 76, 8849, 281, 458, 264, 5288, 337, 613, 721, 498, 436, 528, 281, 853, 8646, 43723, 30], "temperature": 0.0, "avg_logprob": -0.18677387442640078, "compression_ratio": 1.670995670995671, "no_speech_prob": 5.827117638546042e-05}, {"id": 32, "seek": 17300, "start": 183.0, "end": 191.0, "text": " Or do you think that there's also value to giving names to these things for an Elm developer, even just working with Elm?", "tokens": [1610, 360, 291, 519, 300, 456, 311, 611, 2158, 281, 2902, 5288, 281, 613, 721, 337, 364, 2699, 76, 10754, 11, 754, 445, 1364, 365, 2699, 76, 30], "temperature": 0.0, "avg_logprob": -0.18677387442640078, "compression_ratio": 1.670995670995671, "no_speech_prob": 5.827117638546042e-05}, {"id": 33, "seek": 17300, "start": 191.0, "end": 199.0, "text": " Yeah, that's a good question because what happened to me before is that before even learning Haskell, as I mentioned, I was a JavaScript developer.", "tokens": [865, 11, 300, 311, 257, 665, 1168, 570, 437, 2011, 281, 385, 949, 307, 300, 949, 754, 2539, 8646, 43723, 11, 382, 286, 2835, 11, 286, 390, 257, 15778, 10754, 13], "temperature": 0.0, "avg_logprob": -0.18677387442640078, "compression_ratio": 1.670995670995671, "no_speech_prob": 5.827117638546042e-05}, {"id": 34, "seek": 19900, "start": 199.0, "end": 204.0, "text": " So I tried to learn ReasonML, this new language that Facebook was creating.", "tokens": [407, 286, 3031, 281, 1466, 39693, 12683, 11, 341, 777, 2856, 300, 4384, 390, 4084, 13], "temperature": 0.0, "avg_logprob": -0.1953310064367346, "compression_ratio": 1.717557251908397, "no_speech_prob": 6.382225546985865e-05}, {"id": 35, "seek": 19900, "start": 204.0, "end": 207.0, "text": " You know, the creator of React, Jordan Wolk.", "tokens": [509, 458, 11, 264, 14181, 295, 30644, 11, 10979, 19925, 74, 13], "temperature": 0.0, "avg_logprob": -0.1953310064367346, "compression_ratio": 1.717557251908397, "no_speech_prob": 6.382225546985865e-05}, {"id": 36, "seek": 19900, "start": 207.0, "end": 213.0, "text": " And then I started to learn some Reason and underneath it was OCaml and I did not know about it.", "tokens": [400, 550, 286, 1409, 281, 1466, 512, 39693, 293, 7223, 309, 390, 422, 31030, 75, 293, 286, 630, 406, 458, 466, 309, 13], "temperature": 0.0, "avg_logprob": -0.1953310064367346, "compression_ratio": 1.717557251908397, "no_speech_prob": 6.382225546985865e-05}, {"id": 37, "seek": 19900, "start": 213.0, "end": 217.0, "text": " And I knew that or I learned that Reason had something called functors.", "tokens": [400, 286, 2586, 300, 420, 286, 3264, 300, 39693, 632, 746, 1219, 1019, 5547, 13], "temperature": 0.0, "avg_logprob": -0.1953310064367346, "compression_ratio": 1.717557251908397, "no_speech_prob": 6.382225546985865e-05}, {"id": 38, "seek": 19900, "start": 217.0, "end": 227.0, "text": " But when I tried to learn what these functors were, they were basically different from the Haskell functors or the JavaScript functors I already had read about.", "tokens": [583, 562, 286, 3031, 281, 1466, 437, 613, 1019, 5547, 645, 11, 436, 645, 1936, 819, 490, 264, 8646, 43723, 1019, 5547, 420, 264, 15778, 1019, 5547, 286, 1217, 632, 1401, 466, 13], "temperature": 0.0, "avg_logprob": -0.1953310064367346, "compression_ratio": 1.717557251908397, "no_speech_prob": 6.382225546985865e-05}, {"id": 39, "seek": 22700, "start": 227.0, "end": 229.0, "text": " So it was really, really confusing to me.", "tokens": [407, 309, 390, 534, 11, 534, 13181, 281, 385, 13], "temperature": 0.0, "avg_logprob": -0.21421752505832248, "compression_ratio": 1.513157894736842, "no_speech_prob": 0.000540546199772507}, {"id": 40, "seek": 22700, "start": 229.0, "end": 236.0, "text": " This name collision in my head that was making me feel anxious, so to speak.", "tokens": [639, 1315, 24644, 294, 452, 1378, 300, 390, 1455, 385, 841, 15166, 11, 370, 281, 1710, 13], "temperature": 0.0, "avg_logprob": -0.21421752505832248, "compression_ratio": 1.513157894736842, "no_speech_prob": 0.000540546199772507}, {"id": 41, "seek": 22700, "start": 236.0, "end": 243.0, "text": " So I'd say that learning the names or at least getting familiar with the semantics or what they try to convey makes sense.", "tokens": [407, 286, 1116, 584, 300, 2539, 264, 5288, 420, 412, 1935, 1242, 4963, 365, 264, 4361, 45298, 420, 437, 436, 853, 281, 16965, 1669, 2020, 13], "temperature": 0.0, "avg_logprob": -0.21421752505832248, "compression_ratio": 1.513157894736842, "no_speech_prob": 0.000540546199772507}, {"id": 42, "seek": 22700, "start": 243.0, "end": 250.0, "text": " Even if you want to jump to F-sharp, OCaml, whatever other functional language, it is useful in itself.", "tokens": [2754, 498, 291, 528, 281, 3012, 281, 479, 12, 2716, 6529, 11, 422, 31030, 75, 11, 2035, 661, 11745, 2856, 11, 309, 307, 4420, 294, 2564, 13], "temperature": 0.0, "avg_logprob": -0.21421752505832248, "compression_ratio": 1.513157894736842, "no_speech_prob": 0.000540546199772507}, {"id": 43, "seek": 25000, "start": 250.0, "end": 258.0, "text": " But the same things are sometimes called different names, unfortunately, in different languages, and so it's a bit confusing, all of it.", "tokens": [583, 264, 912, 721, 366, 2171, 1219, 819, 5288, 11, 7015, 11, 294, 819, 8650, 11, 293, 370, 309, 311, 257, 857, 13181, 11, 439, 295, 309, 13], "temperature": 0.0, "avg_logprob": -0.22551556851001495, "compression_ratio": 1.6334661354581674, "no_speech_prob": 6.198848859639838e-05}, {"id": 44, "seek": 25000, "start": 258.0, "end": 267.0, "text": " And naming these things is so hard because I think what I've started to realize is that our initial inclination may be...", "tokens": [400, 25290, 613, 721, 307, 370, 1152, 570, 286, 519, 437, 286, 600, 1409, 281, 4325, 307, 300, 527, 5883, 37070, 2486, 815, 312, 485], "temperature": 0.0, "avg_logprob": -0.22551556851001495, "compression_ratio": 1.6334661354581674, "no_speech_prob": 6.198848859639838e-05}, {"id": 45, "seek": 25000, "start": 267.0, "end": 273.0, "text": " I imagine many people initially learn an imperative or an object-oriented language.", "tokens": [286, 3811, 867, 561, 9105, 1466, 364, 32490, 420, 364, 2657, 12, 27414, 2856, 13], "temperature": 0.0, "avg_logprob": -0.22551556851001495, "compression_ratio": 1.6334661354581674, "no_speech_prob": 6.198848859639838e-05}, {"id": 46, "seek": 25000, "start": 273.0, "end": 279.0, "text": " And we tend to think of concepts in terms of what you do with them.", "tokens": [400, 321, 3928, 281, 519, 295, 10392, 294, 2115, 295, 437, 291, 360, 365, 552, 13], "temperature": 0.0, "avg_logprob": -0.22551556851001495, "compression_ratio": 1.6334661354581674, "no_speech_prob": 6.198848859639838e-05}, {"id": 47, "seek": 27900, "start": 279.0, "end": 282.0, "text": " Like, what's the inheritance chain?", "tokens": [1743, 11, 437, 311, 264, 32122, 5021, 30], "temperature": 0.0, "avg_logprob": -0.18448876760092126, "compression_ratio": 1.7407407407407407, "no_speech_prob": 0.0001233899820363149}, {"id": 48, "seek": 27900, "start": 282.0, "end": 291.0, "text": " Or this is like a list or this is a sequence or this is a thing that you await that can be done sequentially.", "tokens": [1610, 341, 307, 411, 257, 1329, 420, 341, 307, 257, 8310, 420, 341, 307, 257, 551, 300, 291, 19670, 300, 393, 312, 1096, 5123, 3137, 13], "temperature": 0.0, "avg_logprob": -0.18448876760092126, "compression_ratio": 1.7407407407407407, "no_speech_prob": 0.0001233899820363149}, {"id": 49, "seek": 27900, "start": 291.0, "end": 297.0, "text": " And it's like, well, what if we weren't talking about the kind of data something was or the kind of thing something represented,", "tokens": [400, 309, 311, 411, 11, 731, 11, 437, 498, 321, 4999, 380, 1417, 466, 264, 733, 295, 1412, 746, 390, 420, 264, 733, 295, 551, 746, 10379, 11], "temperature": 0.0, "avg_logprob": -0.18448876760092126, "compression_ratio": 1.7407407407407407, "no_speech_prob": 0.0001233899820363149}, {"id": 50, "seek": 27900, "start": 297.0, "end": 301.0, "text": " but rather how you transform data in something, right?", "tokens": [457, 2831, 577, 291, 4088, 1412, 294, 746, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.18448876760092126, "compression_ratio": 1.7407407407407407, "no_speech_prob": 0.0001233899820363149}, {"id": 51, "seek": 30100, "start": 301.0, "end": 309.0, "text": " So actually, you know, we can talk about a list and a task and a JSON decoder in the same way.", "tokens": [407, 767, 11, 291, 458, 11, 321, 393, 751, 466, 257, 1329, 293, 257, 5633, 293, 257, 31828, 979, 19866, 294, 264, 912, 636, 13], "temperature": 0.0, "avg_logprob": -0.14637149464000354, "compression_ratio": 1.5097087378640777, "no_speech_prob": 3.705108611029573e-05}, {"id": 52, "seek": 30100, "start": 309.0, "end": 311.0, "text": " What do those things have in common?", "tokens": [708, 360, 729, 721, 362, 294, 2689, 30], "temperature": 0.0, "avg_logprob": -0.14637149464000354, "compression_ratio": 1.5097087378640777, "no_speech_prob": 3.705108611029573e-05}, {"id": 53, "seek": 30100, "start": 311.0, "end": 315.0, "text": " Well, you can manipulate data in a similar way.", "tokens": [1042, 11, 291, 393, 20459, 1412, 294, 257, 2531, 636, 13], "temperature": 0.0, "avg_logprob": -0.14637149464000354, "compression_ratio": 1.5097087378640777, "no_speech_prob": 3.705108611029573e-05}, {"id": 54, "seek": 30100, "start": 315.0, "end": 317.0, "text": " How do you put a name to that idea?", "tokens": [1012, 360, 291, 829, 257, 1315, 281, 300, 1558, 30], "temperature": 0.0, "avg_logprob": -0.14637149464000354, "compression_ratio": 1.5097087378640777, "no_speech_prob": 3.705108611029573e-05}, {"id": 55, "seek": 30100, "start": 317.0, "end": 324.0, "text": " It's very difficult and it's very abstract, but it's a very productive way to work with things.", "tokens": [467, 311, 588, 2252, 293, 309, 311, 588, 12649, 11, 457, 309, 311, 257, 588, 13304, 636, 281, 589, 365, 721, 13], "temperature": 0.0, "avg_logprob": -0.14637149464000354, "compression_ratio": 1.5097087378640777, "no_speech_prob": 3.705108611029573e-05}, {"id": 56, "seek": 32400, "start": 324.0, "end": 331.0, "text": " And once you gain that intuition, you can be really productive, it feels like.", "tokens": [400, 1564, 291, 6052, 300, 24002, 11, 291, 393, 312, 534, 13304, 11, 309, 3417, 411, 13], "temperature": 0.0, "avg_logprob": -0.2010409364995268, "compression_ratio": 1.6597510373443984, "no_speech_prob": 3.4778277040459216e-05}, {"id": 57, "seek": 32400, "start": 331.0, "end": 334.0, "text": " But it's hard to develop that intuition.", "tokens": [583, 309, 311, 1152, 281, 1499, 300, 24002, 13], "temperature": 0.0, "avg_logprob": -0.2010409364995268, "compression_ratio": 1.6597510373443984, "no_speech_prob": 3.4778277040459216e-05}, {"id": 58, "seek": 32400, "start": 334.0, "end": 341.0, "text": " And it's an interesting question whether somebody develops that intuition faster when they're given the names first,", "tokens": [400, 309, 311, 364, 1880, 1168, 1968, 2618, 25453, 300, 24002, 4663, 562, 436, 434, 2212, 264, 5288, 700, 11], "temperature": 0.0, "avg_logprob": -0.2010409364995268, "compression_ratio": 1.6597510373443984, "no_speech_prob": 3.4778277040459216e-05}, {"id": 59, "seek": 32400, "start": 341.0, "end": 346.0, "text": " learning Haskell, or when they're not given the names and just use these concepts in Elm.", "tokens": [2539, 8646, 43723, 11, 420, 562, 436, 434, 406, 2212, 264, 5288, 293, 445, 764, 613, 10392, 294, 2699, 76, 13], "temperature": 0.0, "avg_logprob": -0.2010409364995268, "compression_ratio": 1.6597510373443984, "no_speech_prob": 3.4778277040459216e-05}, {"id": 60, "seek": 32400, "start": 346.0, "end": 347.0, "text": " Yeah, definitely.", "tokens": [865, 11, 2138, 13], "temperature": 0.0, "avg_logprob": -0.2010409364995268, "compression_ratio": 1.6597510373443984, "no_speech_prob": 3.4778277040459216e-05}, {"id": 61, "seek": 32400, "start": 347.0, "end": 353.0, "text": " I remember while doing or learning React in 2013, 2014,", "tokens": [286, 1604, 1339, 884, 420, 2539, 30644, 294, 9012, 11, 8227, 11], "temperature": 0.0, "avg_logprob": -0.2010409364995268, "compression_ratio": 1.6597510373443984, "no_speech_prob": 3.4778277040459216e-05}, {"id": 62, "seek": 35300, "start": 353.0, "end": 355.0, "text": " I was coming from AngularJS.", "tokens": [286, 390, 1348, 490, 34107, 41, 50, 13], "temperature": 0.0, "avg_logprob": -0.19317425396425505, "compression_ratio": 1.713768115942029, "no_speech_prob": 0.0002131113869836554}, {"id": 63, "seek": 35300, "start": 355.0, "end": 357.0, "text": " So, for example, I just wanted to do a very simple thing.", "tokens": [407, 11, 337, 1365, 11, 286, 445, 1415, 281, 360, 257, 588, 2199, 551, 13], "temperature": 0.0, "avg_logprob": -0.19317425396425505, "compression_ratio": 1.713768115942029, "no_speech_prob": 0.0002131113869836554}, {"id": 64, "seek": 35300, "start": 357.0, "end": 359.0, "text": " I wanted to iterate on a list.", "tokens": [286, 1415, 281, 44497, 322, 257, 1329, 13], "temperature": 0.0, "avg_logprob": -0.19317425396425505, "compression_ratio": 1.713768115942029, "no_speech_prob": 0.0002131113869836554}, {"id": 65, "seek": 35300, "start": 359.0, "end": 365.0, "text": " And you used to have these ng4, ngRepeat directives, you know, in the code.", "tokens": [400, 291, 1143, 281, 362, 613, 6415, 19, 11, 6415, 8524, 494, 267, 2047, 1539, 11, 291, 458, 11, 294, 264, 3089, 13], "temperature": 0.0, "avg_logprob": -0.19317425396425505, "compression_ratio": 1.713768115942029, "no_speech_prob": 0.0002131113869836554}, {"id": 66, "seek": 35300, "start": 365.0, "end": 367.0, "text": " I was looking for that in React.", "tokens": [286, 390, 1237, 337, 300, 294, 30644, 13], "temperature": 0.0, "avg_logprob": -0.19317425396425505, "compression_ratio": 1.713768115942029, "no_speech_prob": 0.0002131113869836554}, {"id": 67, "seek": 35300, "start": 367.0, "end": 375.0, "text": " And then obviously I learned about the function map, you know, and it's like, oh, so there is no special directive to do this.", "tokens": [400, 550, 2745, 286, 3264, 466, 264, 2445, 4471, 11, 291, 458, 11, 293, 309, 311, 411, 11, 1954, 11, 370, 456, 307, 572, 2121, 45444, 281, 360, 341, 13], "temperature": 0.0, "avg_logprob": -0.19317425396425505, "compression_ratio": 1.713768115942029, "no_speech_prob": 0.0002131113869836554}, {"id": 68, "seek": 35300, "start": 375.0, "end": 380.0, "text": " It's just you use a language construct, which is just list.map, so to say.", "tokens": [467, 311, 445, 291, 764, 257, 2856, 7690, 11, 597, 307, 445, 1329, 13, 24223, 11, 370, 281, 584, 13], "temperature": 0.0, "avg_logprob": -0.19317425396425505, "compression_ratio": 1.713768115942029, "no_speech_prob": 0.0002131113869836554}, {"id": 69, "seek": 35300, "start": 380.0, "end": 382.0, "text": " And then you do what you want with the list.", "tokens": [400, 550, 291, 360, 437, 291, 528, 365, 264, 1329, 13], "temperature": 0.0, "avg_logprob": -0.19317425396425505, "compression_ratio": 1.713768115942029, "no_speech_prob": 0.0002131113869836554}, {"id": 70, "seek": 38200, "start": 382.0, "end": 386.0, "text": " But this concept, learning it as a JavaScript developer, was so useful.", "tokens": [583, 341, 3410, 11, 2539, 309, 382, 257, 15778, 10754, 11, 390, 370, 4420, 13], "temperature": 0.0, "avg_logprob": -0.20390522696755148, "compression_ratio": 1.6162790697674418, "no_speech_prob": 0.00028470129473134875}, {"id": 71, "seek": 38200, "start": 386.0, "end": 389.0, "text": " And then it replicated in all the following languages I learned after that.", "tokens": [400, 550, 309, 46365, 294, 439, 264, 3480, 8650, 286, 3264, 934, 300, 13], "temperature": 0.0, "avg_logprob": -0.20390522696755148, "compression_ratio": 1.6162790697674418, "no_speech_prob": 0.00028470129473134875}, {"id": 72, "seek": 38200, "start": 389.0, "end": 394.0, "text": " And it was really, really practical and useful to get acquainted with that.", "tokens": [400, 309, 390, 534, 11, 534, 8496, 293, 4420, 281, 483, 50224, 365, 300, 13], "temperature": 0.0, "avg_logprob": -0.20390522696755148, "compression_ratio": 1.6162790697674418, "no_speech_prob": 0.00028470129473134875}, {"id": 73, "seek": 38200, "start": 394.0, "end": 399.0, "text": " Now I really want to know what was different with the Reason functor.", "tokens": [823, 286, 534, 528, 281, 458, 437, 390, 819, 365, 264, 39693, 1019, 1672, 13], "temperature": 0.0, "avg_logprob": -0.20390522696755148, "compression_ratio": 1.6162790697674418, "no_speech_prob": 0.00028470129473134875}, {"id": 74, "seek": 38200, "start": 399.0, "end": 400.0, "text": " Oh, yeah.", "tokens": [876, 11, 1338, 13], "temperature": 0.0, "avg_logprob": -0.20390522696755148, "compression_ratio": 1.6162790697674418, "no_speech_prob": 0.00028470129473134875}, {"id": 75, "seek": 38200, "start": 400.0, "end": 404.0, "text": " So in OCaml and by extension in Reason,", "tokens": [407, 294, 422, 31030, 75, 293, 538, 10320, 294, 39693, 11], "temperature": 0.0, "avg_logprob": -0.20390522696755148, "compression_ratio": 1.6162790697674418, "no_speech_prob": 0.00028470129473134875}, {"id": 76, "seek": 38200, "start": 404.0, "end": 411.0, "text": " so basically one file is not one module as in Elm, as in Haskell as well.", "tokens": [370, 1936, 472, 3991, 307, 406, 472, 10088, 382, 294, 2699, 76, 11, 382, 294, 8646, 43723, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.20390522696755148, "compression_ratio": 1.6162790697674418, "no_speech_prob": 0.00028470129473134875}, {"id": 77, "seek": 41100, "start": 411.0, "end": 413.0, "text": " You can have multiple modules in one file.", "tokens": [509, 393, 362, 3866, 16679, 294, 472, 3991, 13], "temperature": 0.0, "avg_logprob": -0.20486242120916193, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.00033733760938048363}, {"id": 78, "seek": 41100, "start": 413.0, "end": 425.0, "text": " So there is a case in which you want to parametrize a module and call it with a specific generic type and use that module with a different type.", "tokens": [407, 456, 307, 257, 1389, 294, 597, 291, 528, 281, 6220, 302, 470, 1381, 257, 10088, 293, 818, 309, 365, 257, 2685, 19577, 2010, 293, 764, 300, 10088, 365, 257, 819, 2010, 13], "temperature": 0.0, "avg_logprob": -0.20486242120916193, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.00033733760938048363}, {"id": 79, "seek": 41100, "start": 425.0, "end": 429.0, "text": " So these parametrizeable modules, so to speak, how they call them, they call them OCaml functors.", "tokens": [407, 613, 6220, 302, 470, 1381, 712, 16679, 11, 370, 281, 1710, 11, 577, 436, 818, 552, 11, 436, 818, 552, 422, 31030, 75, 1019, 5547, 13], "temperature": 0.0, "avg_logprob": -0.20486242120916193, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.00033733760938048363}, {"id": 80, "seek": 41100, "start": 429.0, "end": 435.0, "text": " But it's a completely different thing as in what we know in Elm and Haskell as a functor.", "tokens": [583, 309, 311, 257, 2584, 819, 551, 382, 294, 437, 321, 458, 294, 2699, 76, 293, 8646, 43723, 382, 257, 1019, 1672, 13], "temperature": 0.0, "avg_logprob": -0.20486242120916193, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.00033733760938048363}, {"id": 81, "seek": 41100, "start": 435.0, "end": 440.0, "text": " So it was kind of, yeah, mind-boggling to learn this.", "tokens": [407, 309, 390, 733, 295, 11, 1338, 11, 1575, 12, 65, 36754, 1688, 281, 1466, 341, 13], "temperature": 0.0, "avg_logprob": -0.20486242120916193, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.00033733760938048363}, {"id": 82, "seek": 44000, "start": 440.0, "end": 443.0, "text": " Gotcha. I can understand the confusion.", "tokens": [42109, 13, 286, 393, 1223, 264, 15075, 13], "temperature": 0.0, "avg_logprob": -0.20096030133835813, "compression_ratio": 1.481818181818182, "no_speech_prob": 9.152006532531232e-05}, {"id": 83, "seek": 44000, "start": 443.0, "end": 446.0, "text": " Yeah, it was very confusing.", "tokens": [865, 11, 309, 390, 588, 13181, 13], "temperature": 0.0, "avg_logprob": -0.20096030133835813, "compression_ratio": 1.481818181818182, "no_speech_prob": 9.152006532531232e-05}, {"id": 84, "seek": 44000, "start": 446.0, "end": 451.0, "text": " Okay. So, well, let's dive into it.", "tokens": [1033, 13, 407, 11, 731, 11, 718, 311, 9192, 666, 309, 13], "temperature": 0.0, "avg_logprob": -0.20096030133835813, "compression_ratio": 1.481818181818182, "no_speech_prob": 9.152006532531232e-05}, {"id": 85, "seek": 44000, "start": 451.0, "end": 456.0, "text": " In your blog series, you wrote about basically three different type classes.", "tokens": [682, 428, 6968, 2638, 11, 291, 4114, 466, 1936, 1045, 819, 2010, 5359, 13], "temperature": 0.0, "avg_logprob": -0.20096030133835813, "compression_ratio": 1.481818181818182, "no_speech_prob": 9.152006532531232e-05}, {"id": 86, "seek": 44000, "start": 456.0, "end": 460.0, "text": " You want to kind of enumerate those for us?", "tokens": [509, 528, 281, 733, 295, 465, 15583, 473, 729, 337, 505, 30], "temperature": 0.0, "avg_logprob": -0.20096030133835813, "compression_ratio": 1.481818181818182, "no_speech_prob": 9.152006532531232e-05}, {"id": 87, "seek": 44000, "start": 460.0, "end": 464.0, "text": " Sure. Well, I started with the easiest one, I thought.", "tokens": [4894, 13, 1042, 11, 286, 1409, 365, 264, 12889, 472, 11, 286, 1194, 13], "temperature": 0.0, "avg_logprob": -0.20096030133835813, "compression_ratio": 1.481818181818182, "no_speech_prob": 9.152006532531232e-05}, {"id": 88, "seek": 44000, "start": 464.0, "end": 467.0, "text": " We're talking about functors for a while now.", "tokens": [492, 434, 1417, 466, 1019, 5547, 337, 257, 1339, 586, 13], "temperature": 0.0, "avg_logprob": -0.20096030133835813, "compression_ratio": 1.481818181818182, "no_speech_prob": 9.152006532531232e-05}, {"id": 89, "seek": 46700, "start": 467.0, "end": 473.0, "text": " But I started with functor because I think it's one of the most intuitive to think about once you understand the concept of mapping.", "tokens": [583, 286, 1409, 365, 1019, 1672, 570, 286, 519, 309, 311, 472, 295, 264, 881, 21769, 281, 519, 466, 1564, 291, 1223, 264, 3410, 295, 18350, 13], "temperature": 0.0, "avg_logprob": -0.19614359358666647, "compression_ratio": 1.521505376344086, "no_speech_prob": 5.3068786655785516e-05}, {"id": 90, "seek": 46700, "start": 473.0, "end": 478.0, "text": " And we use them every day in Elm in all sorts of code.", "tokens": [400, 321, 764, 552, 633, 786, 294, 2699, 76, 294, 439, 7527, 295, 3089, 13], "temperature": 0.0, "avg_logprob": -0.19614359358666647, "compression_ratio": 1.521505376344086, "no_speech_prob": 5.3068786655785516e-05}, {"id": 91, "seek": 46700, "start": 478.0, "end": 484.0, "text": " As soon as you map any kind of data structure, you know that you are using functors underneath.", "tokens": [1018, 2321, 382, 291, 4471, 604, 733, 295, 1412, 3877, 11, 291, 458, 300, 291, 366, 1228, 1019, 5547, 7223, 13], "temperature": 0.0, "avg_logprob": -0.19614359358666647, "compression_ratio": 1.521505376344086, "no_speech_prob": 5.3068786655785516e-05}, {"id": 92, "seek": 48400, "start": 484.0, "end": 499.0, "text": " So the next thing that you kind of get to or need to understand is that there is something called applicative functors for when you need to map two or map three, map four, etc.", "tokens": [407, 264, 958, 551, 300, 291, 733, 295, 483, 281, 420, 643, 281, 1223, 307, 300, 456, 307, 746, 1219, 2580, 1166, 1019, 5547, 337, 562, 291, 643, 281, 4471, 732, 420, 4471, 1045, 11, 4471, 1451, 11, 5183, 13], "temperature": 0.0, "avg_logprob": -0.24966654213525916, "compression_ratio": 1.588235294117647, "no_speech_prob": 0.00026079174131155014}, {"id": 93, "seek": 48400, "start": 499.0, "end": 507.0, "text": " I read a really nice post by, I think it was Joel that also was a guest in a previous episode.", "tokens": [286, 1401, 257, 534, 1481, 2183, 538, 11, 286, 519, 309, 390, 21522, 300, 611, 390, 257, 8341, 294, 257, 3894, 3500, 13], "temperature": 0.0, "avg_logprob": -0.24966654213525916, "compression_ratio": 1.588235294117647, "no_speech_prob": 0.00026079174131155014}, {"id": 94, "seek": 48400, "start": 507.0, "end": 509.0, "text": " It was on this topic.", "tokens": [467, 390, 322, 341, 4829, 13], "temperature": 0.0, "avg_logprob": -0.24966654213525916, "compression_ratio": 1.588235294117647, "no_speech_prob": 0.00026079174131155014}, {"id": 95, "seek": 48400, "start": 509.0, "end": 512.0, "text": " Exactly. So what happens when you run out of maps, right?", "tokens": [7587, 13, 407, 437, 2314, 562, 291, 1190, 484, 295, 11317, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.24966654213525916, "compression_ratio": 1.588235294117647, "no_speech_prob": 0.00026079174131155014}, {"id": 96, "seek": 51200, "start": 512.0, "end": 516.0, "text": " When you don't have enough map n numbers.", "tokens": [1133, 291, 500, 380, 362, 1547, 4471, 297, 3547, 13], "temperature": 0.0, "avg_logprob": -0.23455057388696915, "compression_ratio": 1.7884615384615385, "no_speech_prob": 0.00045722455251961946}, {"id": 97, "seek": 51200, "start": 516.0, "end": 520.0, "text": " And then you can build yourself like using this and map thing.", "tokens": [400, 550, 291, 393, 1322, 1803, 411, 1228, 341, 293, 4471, 551, 13], "temperature": 0.0, "avg_logprob": -0.23455057388696915, "compression_ratio": 1.7884615384615385, "no_speech_prob": 0.00045722455251961946}, {"id": 98, "seek": 51200, "start": 520.0, "end": 525.0, "text": " You can basically use the pipe operator and this and map and use as many as you want.", "tokens": [509, 393, 1936, 764, 264, 11240, 12973, 293, 341, 293, 4471, 293, 764, 382, 867, 382, 291, 528, 13], "temperature": 0.0, "avg_logprob": -0.23455057388696915, "compression_ratio": 1.7884615384615385, "no_speech_prob": 0.00045722455251961946}, {"id": 99, "seek": 51200, "start": 525.0, "end": 532.0, "text": " And the concept behind these things, the concept that you can apply functors to each other, are called applicative functors.", "tokens": [400, 264, 3410, 2261, 613, 721, 11, 264, 3410, 300, 291, 393, 3079, 1019, 5547, 281, 1184, 661, 11, 366, 1219, 2580, 1166, 1019, 5547, 13], "temperature": 0.0, "avg_logprob": -0.23455057388696915, "compression_ratio": 1.7884615384615385, "no_speech_prob": 0.00045722455251961946}, {"id": 100, "seek": 51200, "start": 532.0, "end": 534.0, "text": " And it's kind of weird.", "tokens": [400, 309, 311, 733, 295, 3657, 13], "temperature": 0.0, "avg_logprob": -0.23455057388696915, "compression_ratio": 1.7884615384615385, "no_speech_prob": 0.00045722455251961946}, {"id": 101, "seek": 51200, "start": 534.0, "end": 538.0, "text": " The intuition is not as easy to understand as with functors.", "tokens": [440, 24002, 307, 406, 382, 1858, 281, 1223, 382, 365, 1019, 5547, 13], "temperature": 0.0, "avg_logprob": -0.23455057388696915, "compression_ratio": 1.7884615384615385, "no_speech_prob": 0.00045722455251961946}, {"id": 102, "seek": 51200, "start": 538.0, "end": 541.0, "text": " But when you learn about them, you start seeing them everywhere.", "tokens": [583, 562, 291, 1466, 466, 552, 11, 291, 722, 2577, 552, 5315, 13], "temperature": 0.0, "avg_logprob": -0.23455057388696915, "compression_ratio": 1.7884615384615385, "no_speech_prob": 0.00045722455251961946}, {"id": 103, "seek": 54100, "start": 541.0, "end": 548.0, "text": " And it's interesting because it's an intermediate step that you need to learn to go to the third step, which is monads.", "tokens": [400, 309, 311, 1880, 570, 309, 311, 364, 19376, 1823, 300, 291, 643, 281, 1466, 281, 352, 281, 264, 2636, 1823, 11, 597, 307, 1108, 5834, 13], "temperature": 0.0, "avg_logprob": -0.25803804860531704, "compression_ratio": 1.6367521367521367, "no_speech_prob": 0.00048741590580902994}, {"id": 104, "seek": 54100, "start": 548.0, "end": 554.0, "text": " The thing everyone talks about and there are a thousand blog posts about this scary monad thing.", "tokens": [440, 551, 1518, 6686, 466, 293, 456, 366, 257, 4714, 6968, 12300, 466, 341, 6958, 1108, 345, 551, 13], "temperature": 0.0, "avg_logprob": -0.25803804860531704, "compression_ratio": 1.6367521367521367, "no_speech_prob": 0.00048741590580902994}, {"id": 105, "seek": 54100, "start": 554.0, "end": 558.0, "text": " Except in the Elm community where we basically don't talk about it.", "tokens": [16192, 294, 264, 2699, 76, 1768, 689, 321, 1936, 500, 380, 751, 466, 309, 13], "temperature": 0.0, "avg_logprob": -0.25803804860531704, "compression_ratio": 1.6367521367521367, "no_speech_prob": 0.00048741590580902994}, {"id": 106, "seek": 54100, "start": 558.0, "end": 560.0, "text": " We don't use the M word.", "tokens": [492, 500, 380, 764, 264, 376, 1349, 13], "temperature": 0.0, "avg_logprob": -0.25803804860531704, "compression_ratio": 1.6367521367521367, "no_speech_prob": 0.00048741590580902994}, {"id": 107, "seek": 54100, "start": 560.0, "end": 564.0, "text": " In fact, we'll beep out every use of our word monad in the text.", "tokens": [682, 1186, 11, 321, 603, 28678, 484, 633, 764, 295, 527, 1349, 1108, 345, 294, 264, 2487, 13], "temperature": 0.0, "avg_logprob": -0.25803804860531704, "compression_ratio": 1.6367521367521367, "no_speech_prob": 0.00048741590580902994}, {"id": 108, "seek": 54100, "start": 564.0, "end": 569.0, "text": " Exactly.", "tokens": [7587, 13], "temperature": 0.0, "avg_logprob": -0.25803804860531704, "compression_ratio": 1.6367521367521367, "no_speech_prob": 0.00048741590580902994}, {"id": 109, "seek": 56900, "start": 569.0, "end": 574.0, "text": " We will censor it so no one hears the M word anymore.", "tokens": [492, 486, 19019, 284, 309, 370, 572, 472, 25688, 264, 376, 1349, 3602, 13], "temperature": 0.0, "avg_logprob": -0.27157466816452314, "compression_ratio": 1.3194444444444444, "no_speech_prob": 0.0001291336229769513}, {"id": 110, "seek": 56900, "start": 574.0, "end": 579.0, "text": " Keep our PG rating.", "tokens": [5527, 527, 40975, 10990, 13], "temperature": 0.0, "avg_logprob": -0.27157466816452314, "compression_ratio": 1.3194444444444444, "no_speech_prob": 0.0001291336229769513}, {"id": 111, "seek": 56900, "start": 579.0, "end": 591.0, "text": " Actually, the only people who talk about monads are the ones who try to convey that information from Haskell to Elm.", "tokens": [5135, 11, 264, 787, 561, 567, 751, 466, 1108, 5834, 366, 264, 2306, 567, 853, 281, 16965, 300, 1589, 490, 8646, 43723, 281, 2699, 76, 13], "temperature": 0.0, "avg_logprob": -0.27157466816452314, "compression_ratio": 1.3194444444444444, "no_speech_prob": 0.0001291336229769513}, {"id": 112, "seek": 59100, "start": 591.0, "end": 599.0, "text": " Yeah, but it's funny because it's also such a common pattern that happens all the time as soon as you want to work with the fakes.", "tokens": [865, 11, 457, 309, 311, 4074, 570, 309, 311, 611, 1270, 257, 2689, 5102, 300, 2314, 439, 264, 565, 382, 2321, 382, 291, 528, 281, 589, 365, 264, 283, 3419, 13], "temperature": 0.0, "avg_logprob": -0.22275371177523745, "compression_ratio": 1.5846774193548387, "no_speech_prob": 5.727156894863583e-05}, {"id": 113, "seek": 59100, "start": 599.0, "end": 603.0, "text": " Monads are everywhere, even if we ignore them.", "tokens": [4713, 5834, 366, 5315, 11, 754, 498, 321, 11200, 552, 13], "temperature": 0.0, "avg_logprob": -0.22275371177523745, "compression_ratio": 1.5846774193548387, "no_speech_prob": 5.727156894863583e-05}, {"id": 114, "seek": 59100, "start": 603.0, "end": 610.0, "text": " But when I became a more serious Elm developer, I understood why Evan would choose to just ignore those names.", "tokens": [583, 562, 286, 3062, 257, 544, 3156, 2699, 76, 10754, 11, 286, 7320, 983, 22613, 576, 2826, 281, 445, 11200, 729, 5288, 13], "temperature": 0.0, "avg_logprob": -0.22275371177523745, "compression_ratio": 1.5846774193548387, "no_speech_prob": 5.727156894863583e-05}, {"id": 115, "seek": 59100, "start": 610.0, "end": 612.0, "text": " Because they tend to be confusing.", "tokens": [1436, 436, 3928, 281, 312, 13181, 13], "temperature": 0.0, "avg_logprob": -0.22275371177523745, "compression_ratio": 1.5846774193548387, "no_speech_prob": 5.727156894863583e-05}, {"id": 116, "seek": 59100, "start": 612.0, "end": 614.0, "text": " And you don't need to know the names to use the patterns.", "tokens": [400, 291, 500, 380, 643, 281, 458, 264, 5288, 281, 764, 264, 8294, 13], "temperature": 0.0, "avg_logprob": -0.22275371177523745, "compression_ratio": 1.5846774193548387, "no_speech_prob": 5.727156894863583e-05}, {"id": 117, "seek": 59100, "start": 614.0, "end": 615.0, "text": " Definitely.", "tokens": [12151, 13], "temperature": 0.0, "avg_logprob": -0.22275371177523745, "compression_ratio": 1.5846774193548387, "no_speech_prob": 5.727156894863583e-05}, {"id": 118, "seek": 61500, "start": 615.0, "end": 624.0, "text": " Yeah, I find it confusing. Even the term fmap. Does that mean functor map? Is that why it's called fmap?", "tokens": [865, 11, 286, 915, 309, 13181, 13, 2754, 264, 1433, 283, 24223, 13, 4402, 300, 914, 1019, 1672, 4471, 30, 1119, 300, 983, 309, 311, 1219, 283, 24223, 30], "temperature": 0.0, "avg_logprob": -0.24748193133961072, "compression_ratio": 1.4684684684684686, "no_speech_prob": 0.00010367819049861282}, {"id": 119, "seek": 61500, "start": 624.0, "end": 632.0, "text": " Yeah, because since Haskell started as a research language, it didn't even have a way to do I-O at the beginning.", "tokens": [865, 11, 570, 1670, 8646, 43723, 1409, 382, 257, 2132, 2856, 11, 309, 994, 380, 754, 362, 257, 636, 281, 360, 286, 12, 46, 412, 264, 2863, 13], "temperature": 0.0, "avg_logprob": -0.24748193133961072, "compression_ratio": 1.4684684684684686, "no_speech_prob": 0.00010367819049861282}, {"id": 120, "seek": 61500, "start": 632.0, "end": 642.0, "text": " It lived in the world of purity, so you could literally do nothing useful with it, according to its author.", "tokens": [467, 5152, 294, 264, 1002, 295, 34382, 11, 370, 291, 727, 3736, 360, 1825, 4420, 365, 309, 11, 4650, 281, 1080, 3793, 13], "temperature": 0.0, "avg_logprob": -0.24748193133961072, "compression_ratio": 1.4684684684684686, "no_speech_prob": 0.00010367819049861282}, {"id": 121, "seek": 64200, "start": 642.0, "end": 647.0, "text": " So they started to develop some patterns to call things.", "tokens": [407, 436, 1409, 281, 1499, 512, 8294, 281, 818, 721, 13], "temperature": 0.0, "avg_logprob": -0.2404799461364746, "compression_ratio": 1.598326359832636, "no_speech_prob": 6.181518256198615e-05}, {"id": 122, "seek": 64200, "start": 647.0, "end": 649.0, "text": " And sometimes things have a weird name.", "tokens": [400, 2171, 721, 362, 257, 3657, 1315, 13], "temperature": 0.0, "avg_logprob": -0.2404799461364746, "compression_ratio": 1.598326359832636, "no_speech_prob": 6.181518256198615e-05}, {"id": 123, "seek": 64200, "start": 649.0, "end": 653.0, "text": " For example, there's a map function, but it only works for lists.", "tokens": [1171, 1365, 11, 456, 311, 257, 4471, 2445, 11, 457, 309, 787, 1985, 337, 14511, 13], "temperature": 0.0, "avg_logprob": -0.2404799461364746, "compression_ratio": 1.598326359832636, "no_speech_prob": 6.181518256198615e-05}, {"id": 124, "seek": 64200, "start": 653.0, "end": 658.0, "text": " So then once they generalized the functor pattern, so to say, or the functor type class, they said,", "tokens": [407, 550, 1564, 436, 44498, 264, 1019, 1672, 5102, 11, 370, 281, 584, 11, 420, 264, 1019, 1672, 2010, 1508, 11, 436, 848, 11], "temperature": 0.0, "avg_logprob": -0.2404799461364746, "compression_ratio": 1.598326359832636, "no_speech_prob": 6.181518256198615e-05}, {"id": 125, "seek": 64200, "start": 658.0, "end": 661.0, "text": " Hey, map is already taken for lists. So what do we do?", "tokens": [1911, 11, 4471, 307, 1217, 2726, 337, 14511, 13, 407, 437, 360, 321, 360, 30], "temperature": 0.0, "avg_logprob": -0.2404799461364746, "compression_ratio": 1.598326359832636, "no_speech_prob": 6.181518256198615e-05}, {"id": 126, "seek": 64200, "start": 661.0, "end": 666.0, "text": " Okay, we will just call it fmap. Or something along those lines.", "tokens": [1033, 11, 321, 486, 445, 818, 309, 283, 24223, 13, 1610, 746, 2051, 729, 3876, 13], "temperature": 0.0, "avg_logprob": -0.2404799461364746, "compression_ratio": 1.598326359832636, "no_speech_prob": 6.181518256198615e-05}, {"id": 127, "seek": 66600, "start": 666.0, "end": 675.0, "text": " Actually, do you know what the history is here? Is it like, these terms come from mathematics, and they were ported to Haskell?", "tokens": [5135, 11, 360, 291, 458, 437, 264, 2503, 307, 510, 30, 1119, 309, 411, 11, 613, 2115, 808, 490, 18666, 11, 293, 436, 645, 2436, 292, 281, 8646, 43723, 30], "temperature": 0.0, "avg_logprob": -0.21272850036621094, "compression_ratio": 1.5333333333333334, "no_speech_prob": 5.291023262543604e-05}, {"id": 128, "seek": 66600, "start": 675.0, "end": 681.0, "text": " Or were they mostly found out in Haskell or other ancestor languages to that?", "tokens": [1610, 645, 436, 5240, 1352, 484, 294, 8646, 43723, 420, 661, 40032, 8650, 281, 300, 30], "temperature": 0.0, "avg_logprob": -0.21272850036621094, "compression_ratio": 1.5333333333333334, "no_speech_prob": 5.291023262543604e-05}, {"id": 129, "seek": 66600, "start": 681.0, "end": 684.0, "text": " And then people say, Oh, it's just mathematics.", "tokens": [400, 550, 561, 584, 11, 876, 11, 309, 311, 445, 18666, 13], "temperature": 0.0, "avg_logprob": -0.21272850036621094, "compression_ratio": 1.5333333333333334, "no_speech_prob": 5.291023262543604e-05}, {"id": 130, "seek": 66600, "start": 684.0, "end": 690.0, "text": " Yeah, I can be wrong answering this, but I will give you what I know from my understanding.", "tokens": [865, 11, 286, 393, 312, 2085, 13430, 341, 11, 457, 286, 486, 976, 291, 437, 286, 458, 490, 452, 3701, 13], "temperature": 0.0, "avg_logprob": -0.21272850036621094, "compression_ratio": 1.5333333333333334, "no_speech_prob": 5.291023262543604e-05}, {"id": 131, "seek": 69000, "start": 690.0, "end": 697.0, "text": " There is a word, there are a few words that we don't want to say in Haskell as we don't want to say in Elm, which are category theory.", "tokens": [821, 307, 257, 1349, 11, 456, 366, 257, 1326, 2283, 300, 321, 500, 380, 528, 281, 584, 294, 8646, 43723, 382, 321, 500, 380, 528, 281, 584, 294, 2699, 76, 11, 597, 366, 7719, 5261, 13], "temperature": 0.0, "avg_logprob": -0.23465087890625, "compression_ratio": 1.7831858407079646, "no_speech_prob": 8.476044604321942e-05}, {"id": 132, "seek": 69000, "start": 697.0, "end": 698.0, "text": " What?", "tokens": [708, 30], "temperature": 0.0, "avg_logprob": -0.23465087890625, "compression_ratio": 1.7831858407079646, "no_speech_prob": 8.476044604321942e-05}, {"id": 133, "seek": 69000, "start": 698.0, "end": 699.0, "text": " You know.", "tokens": [509, 458, 13], "temperature": 0.0, "avg_logprob": -0.23465087890625, "compression_ratio": 1.7831858407079646, "no_speech_prob": 8.476044604321942e-05}, {"id": 134, "seek": 69000, "start": 699.0, "end": 700.0, "text": " Oh, really?", "tokens": [876, 11, 534, 30], "temperature": 0.0, "avg_logprob": -0.23465087890625, "compression_ratio": 1.7831858407079646, "no_speech_prob": 8.476044604321942e-05}, {"id": 135, "seek": 69000, "start": 700.0, "end": 703.0, "text": " Do you know about category theory?", "tokens": [1144, 291, 458, 466, 7719, 5261, 30], "temperature": 0.0, "avg_logprob": -0.23465087890625, "compression_ratio": 1.7831858407079646, "no_speech_prob": 8.476044604321942e-05}, {"id": 136, "seek": 69000, "start": 703.0, "end": 707.0, "text": " Yes. I mean, I know of it.", "tokens": [1079, 13, 286, 914, 11, 286, 458, 295, 309, 13], "temperature": 0.0, "avg_logprob": -0.23465087890625, "compression_ratio": 1.7831858407079646, "no_speech_prob": 8.476044604321942e-05}, {"id": 137, "seek": 69000, "start": 707.0, "end": 710.0, "text": " I don't know about it.", "tokens": [286, 500, 380, 458, 466, 309, 13], "temperature": 0.0, "avg_logprob": -0.23465087890625, "compression_ratio": 1.7831858407079646, "no_speech_prob": 8.476044604321942e-05}, {"id": 138, "seek": 69000, "start": 710.0, "end": 712.0, "text": " What do you mean Haskell developers don't want to talk about that?", "tokens": [708, 360, 291, 914, 8646, 43723, 8849, 500, 380, 528, 281, 751, 466, 300, 30], "temperature": 0.0, "avg_logprob": -0.23465087890625, "compression_ratio": 1.7831858407079646, "no_speech_prob": 8.476044604321942e-05}, {"id": 139, "seek": 69000, "start": 712.0, "end": 718.0, "text": " That's, isn't that just the whole thing around functors and monads and all those things?", "tokens": [663, 311, 11, 1943, 380, 300, 445, 264, 1379, 551, 926, 1019, 5547, 293, 1108, 5834, 293, 439, 729, 721, 30], "temperature": 0.0, "avg_logprob": -0.23465087890625, "compression_ratio": 1.7831858407079646, "no_speech_prob": 8.476044604321942e-05}, {"id": 140, "seek": 71800, "start": 718.0, "end": 727.0, "text": " Exactly. Yeah, but we try to speak the least possible amount about category theory, because obviously, since it influences all of these crazy names.", "tokens": [7587, 13, 865, 11, 457, 321, 853, 281, 1710, 264, 1935, 1944, 2372, 466, 7719, 5261, 11, 570, 2745, 11, 1670, 309, 21222, 439, 295, 613, 3219, 5288, 13], "temperature": 0.0, "avg_logprob": -0.21858674577138956, "compression_ratio": 1.6171003717472119, "no_speech_prob": 0.00044206815073266625}, {"id": 141, "seek": 71800, "start": 727.0, "end": 739.0, "text": " But sometimes, for example, if you talk to a mathematician who happens to be an expert in category theory, they can tell you that the functor defined in Haskell or the monad defined in Haskell is not actually 100% right.", "tokens": [583, 2171, 11, 337, 1365, 11, 498, 291, 751, 281, 257, 48281, 567, 2314, 281, 312, 364, 5844, 294, 7719, 5261, 11, 436, 393, 980, 291, 300, 264, 1019, 1672, 7642, 294, 8646, 43723, 420, 264, 1108, 345, 7642, 294, 8646, 43723, 307, 406, 767, 2319, 4, 558, 13], "temperature": 0.0, "avg_logprob": -0.21858674577138956, "compression_ratio": 1.6171003717472119, "no_speech_prob": 0.00044206815073266625}, {"id": 142, "seek": 71800, "start": 739.0, "end": 745.0, "text": " So that's why I don't want to get too much deep into that forest.", "tokens": [407, 300, 311, 983, 286, 500, 380, 528, 281, 483, 886, 709, 2452, 666, 300, 6719, 13], "temperature": 0.0, "avg_logprob": -0.21858674577138956, "compression_ratio": 1.6171003717472119, "no_speech_prob": 0.00044206815073266625}, {"id": 143, "seek": 74500, "start": 745.0, "end": 751.0, "text": " So for a category theory purist, Haskell is not pure enough for a category theory purist. I see.", "tokens": [407, 337, 257, 7719, 5261, 1864, 468, 11, 8646, 43723, 307, 406, 6075, 1547, 337, 257, 7719, 5261, 1864, 468, 13, 286, 536, 13], "temperature": 0.0, "avg_logprob": -0.23592888391934907, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.00017353198199998587}, {"id": 144, "seek": 74500, "start": 751.0, "end": 752.0, "text": " Exactly.", "tokens": [7587, 13], "temperature": 0.0, "avg_logprob": -0.23592888391934907, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.00017353198199998587}, {"id": 145, "seek": 74500, "start": 752.0, "end": 757.0, "text": " I see. Elm is not pure enough for a Haskell purist. Okay, I see.", "tokens": [286, 536, 13, 2699, 76, 307, 406, 6075, 1547, 337, 257, 8646, 43723, 1864, 468, 13, 1033, 11, 286, 536, 13], "temperature": 0.0, "avg_logprob": -0.23592888391934907, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.00017353198199998587}, {"id": 146, "seek": 74500, "start": 757.0, "end": 760.0, "text": " And O'Camel was right the whole time.", "tokens": [400, 422, 6, 34, 64, 10909, 390, 558, 264, 1379, 565, 13], "temperature": 0.0, "avg_logprob": -0.23592888391934907, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.00017353198199998587}, {"id": 147, "seek": 74500, "start": 760.0, "end": 766.0, "text": " Yeah, actually, I think there's an argument to be made for the O'Camel functor. It's just that I don't know the argument.", "tokens": [865, 11, 767, 11, 286, 519, 456, 311, 364, 6770, 281, 312, 1027, 337, 264, 422, 6, 34, 16103, 1019, 1672, 13, 467, 311, 445, 300, 286, 500, 380, 458, 264, 6770, 13], "temperature": 0.0, "avg_logprob": -0.23592888391934907, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.00017353198199998587}, {"id": 148, "seek": 76600, "start": 766.0, "end": 775.0, "text": " But probably someone with more experience than me that will probably explain why it's called a functor and what it has to be with a category theory functor.", "tokens": [583, 1391, 1580, 365, 544, 1752, 813, 385, 300, 486, 1391, 2903, 983, 309, 311, 1219, 257, 1019, 1672, 293, 437, 309, 575, 281, 312, 365, 257, 7719, 5261, 1019, 1672, 13], "temperature": 0.0, "avg_logprob": -0.2260566552480062, "compression_ratio": 1.6297872340425532, "no_speech_prob": 8.695196447661147e-05}, {"id": 149, "seek": 76600, "start": 775.0, "end": 783.0, "text": " Yeah, I'm guessing they didn't come up with that word out of nowhere. Like, oh, let's find a word for this. Functor sounds nice.", "tokens": [865, 11, 286, 478, 17939, 436, 994, 380, 808, 493, 365, 300, 1349, 484, 295, 11159, 13, 1743, 11, 1954, 11, 718, 311, 915, 257, 1349, 337, 341, 13, 11166, 1672, 3263, 1481, 13], "temperature": 0.0, "avg_logprob": -0.2260566552480062, "compression_ratio": 1.6297872340425532, "no_speech_prob": 8.695196447661147e-05}, {"id": 150, "seek": 76600, "start": 783.0, "end": 790.0, "text": " I think only one person did that ever. And then that's the functor that we hear about everywhere.", "tokens": [286, 519, 787, 472, 954, 630, 300, 1562, 13, 400, 550, 300, 311, 264, 1019, 1672, 300, 321, 1568, 466, 5315, 13], "temperature": 0.0, "avg_logprob": -0.2260566552480062, "compression_ratio": 1.6297872340425532, "no_speech_prob": 8.695196447661147e-05}, {"id": 151, "seek": 79000, "start": 790.0, "end": 799.0, "text": " Yeah, I think while researching or while developing Haskell and learning about all these patterns, obviously, you know that FB has a solid foundation in math.", "tokens": [865, 11, 286, 519, 1339, 24176, 420, 1339, 6416, 8646, 43723, 293, 2539, 466, 439, 613, 8294, 11, 2745, 11, 291, 458, 300, 479, 33, 575, 257, 5100, 7030, 294, 5221, 13], "temperature": 0.0, "avg_logprob": -0.23022261120024182, "compression_ratio": 1.5551020408163265, "no_speech_prob": 0.00018210562120657414}, {"id": 152, "seek": 79000, "start": 799.0, "end": 814.0, "text": " So you turn to something to look up for names, right? And they said, hey, so there is this really abstract branch of mathematics called category theory that happens to have all those fancy and cool names we're looking for.", "tokens": [407, 291, 1261, 281, 746, 281, 574, 493, 337, 5288, 11, 558, 30, 400, 436, 848, 11, 4177, 11, 370, 456, 307, 341, 534, 12649, 9819, 295, 18666, 1219, 7719, 5261, 300, 2314, 281, 362, 439, 729, 10247, 293, 1627, 5288, 321, 434, 1237, 337, 13], "temperature": 0.0, "avg_logprob": -0.23022261120024182, "compression_ratio": 1.5551020408163265, "no_speech_prob": 0.00018210562120657414}, {"id": 153, "seek": 81400, "start": 814.0, "end": 822.0, "text": " Why don't why not? We can start using them right away. That's my guess. My wild guess.", "tokens": [1545, 500, 380, 983, 406, 30, 492, 393, 722, 1228, 552, 558, 1314, 13, 663, 311, 452, 2041, 13, 1222, 4868, 2041, 13], "temperature": 0.0, "avg_logprob": -0.2489043947250124, "compression_ratio": 1.4, "no_speech_prob": 0.00026513912598602474}, {"id": 154, "seek": 81400, "start": 822.0, "end": 833.0, "text": " Yeah, I mean, and they, they, there certainly are useful ideas here. It's just like, it feels like there's such a large barrier to entry.", "tokens": [865, 11, 286, 914, 11, 293, 436, 11, 436, 11, 456, 3297, 366, 4420, 3487, 510, 13, 467, 311, 445, 411, 11, 309, 3417, 411, 456, 311, 1270, 257, 2416, 13357, 281, 8729, 13], "temperature": 0.0, "avg_logprob": -0.2489043947250124, "compression_ratio": 1.4, "no_speech_prob": 0.00026513912598602474}, {"id": 155, "seek": 83300, "start": 833.0, "end": 855.0, "text": " But, you know, I have I have thought, like, sometimes you'll see an Elm API that, you know, maybe it has like map two and map three, but it doesn't expose an end map, which you can derive, you know, as Joel talks about in his post running out of maps, you can derive it from those building blocks.", "tokens": [583, 11, 291, 458, 11, 286, 362, 286, 362, 1194, 11, 411, 11, 2171, 291, 603, 536, 364, 2699, 76, 9362, 300, 11, 291, 458, 11, 1310, 309, 575, 411, 4471, 732, 293, 4471, 1045, 11, 457, 309, 1177, 380, 19219, 364, 917, 4471, 11, 597, 291, 393, 28446, 11, 291, 458, 11, 382, 21522, 6686, 466, 294, 702, 2183, 2614, 484, 295, 11317, 11, 291, 393, 28446, 309, 490, 729, 2390, 8474, 13], "temperature": 0.0, "avg_logprob": -0.21775590456449068, "compression_ratio": 1.6054054054054054, "no_speech_prob": 9.460808360017836e-05}, {"id": 156, "seek": 85500, "start": 855.0, "end": 868.0, "text": " But we sometimes don't have the conventions for which of these things should go together. Like if something is applicative, what building blocks should we have?", "tokens": [583, 321, 2171, 500, 380, 362, 264, 33520, 337, 597, 295, 613, 721, 820, 352, 1214, 13, 1743, 498, 746, 307, 2580, 1166, 11, 437, 2390, 8474, 820, 321, 362, 30], "temperature": 0.0, "avg_logprob": -0.2215226718357631, "compression_ratio": 1.5, "no_speech_prob": 0.0002694681752473116}, {"id": 157, "seek": 85500, "start": 868.0, "end": 878.0, "text": " You know, the idea has crossed my mind. What if we had like an Elm review package, some community standard and came up with a set of conventions?", "tokens": [509, 458, 11, 264, 1558, 575, 14622, 452, 1575, 13, 708, 498, 321, 632, 411, 364, 2699, 76, 3131, 7372, 11, 512, 1768, 3832, 293, 1361, 493, 365, 257, 992, 295, 33520, 30], "temperature": 0.0, "avg_logprob": -0.2215226718357631, "compression_ratio": 1.5, "no_speech_prob": 0.0002694681752473116}, {"id": 158, "seek": 87800, "start": 878.0, "end": 893.0, "text": " And we said, okay, well, like what? Because really, sometimes even just the terms that we use for these ideas, like, is it called concat map? Or is it called and then or is it called or whatever?", "tokens": [400, 321, 848, 11, 1392, 11, 731, 11, 411, 437, 30, 1436, 534, 11, 2171, 754, 445, 264, 2115, 300, 321, 764, 337, 613, 3487, 11, 411, 11, 307, 309, 1219, 1588, 267, 4471, 30, 1610, 307, 309, 1219, 293, 550, 420, 307, 309, 1219, 420, 2035, 30], "temperature": 0.0, "avg_logprob": -0.2682580030881442, "compression_ratio": 1.4885496183206106, "no_speech_prob": 0.0002570167416706681}, {"id": 159, "seek": 89300, "start": 893.0, "end": 912.0, "text": " Exactly. And you find you find instances of these different terms in different packages. And you have to look at the type signatures and know this is sort of the same type of thing that I can do, or have a little bit of a background in Haskell or category theory or whatever, and kind of squint your eyes at it.", "tokens": [7587, 13, 400, 291, 915, 291, 915, 14519, 295, 613, 819, 2115, 294, 819, 17401, 13, 400, 291, 362, 281, 574, 412, 264, 2010, 32322, 293, 458, 341, 307, 1333, 295, 264, 912, 2010, 295, 551, 300, 286, 393, 360, 11, 420, 362, 257, 707, 857, 295, 257, 3678, 294, 8646, 43723, 420, 7719, 5261, 420, 2035, 11, 293, 733, 295, 2339, 686, 428, 2575, 412, 309, 13], "temperature": 0.0, "avg_logprob": -0.2093457645840115, "compression_ratio": 1.61139896373057, "no_speech_prob": 2.8856327844550833e-05}, {"id": 160, "seek": 91200, "start": 912.0, "end": 926.0, "text": " And you see it's the same thing. But wouldn't it be interesting if we had a community standard and an Elm review package that said, well, what's the name for this group of things? What are the standard function names and signatures?", "tokens": [400, 291, 536, 309, 311, 264, 912, 551, 13, 583, 2759, 380, 309, 312, 1880, 498, 321, 632, 257, 1768, 3832, 293, 364, 2699, 76, 3131, 7372, 300, 848, 11, 731, 11, 437, 311, 264, 1315, 337, 341, 1594, 295, 721, 30, 708, 366, 264, 3832, 2445, 5288, 293, 32322, 30], "temperature": 0.0, "avg_logprob": -0.2184979890522204, "compression_ratio": 1.6266094420600858, "no_speech_prob": 1.7502548871561885e-05}, {"id": 161, "seek": 91200, "start": 926.0, "end": 934.0, "text": " I'm not sure if Elm review, would Elm review be able to look at the type signatures of something in order to do that? Yeah, you can do that. Okay.", "tokens": [286, 478, 406, 988, 498, 2699, 76, 3131, 11, 576, 2699, 76, 3131, 312, 1075, 281, 574, 412, 264, 2010, 32322, 295, 746, 294, 1668, 281, 360, 300, 30, 865, 11, 291, 393, 360, 300, 13, 1033, 13], "temperature": 0.0, "avg_logprob": -0.2184979890522204, "compression_ratio": 1.6266094420600858, "no_speech_prob": 1.7502548871561885e-05}, {"id": 162, "seek": 93400, "start": 934.0, "end": 949.0, "text": " You can look at the type signatures as long as they're written in the code. Yeah. So then it should be possible to say like, this is a mappable thing. And then it could, it could verify it could give you an error if it doesn't have something called map that has the appropriate signature, right?", "tokens": [509, 393, 574, 412, 264, 2010, 32322, 382, 938, 382, 436, 434, 3720, 294, 264, 3089, 13, 865, 13, 407, 550, 309, 820, 312, 1944, 281, 584, 411, 11, 341, 307, 257, 463, 427, 712, 551, 13, 400, 550, 309, 727, 11, 309, 727, 16888, 309, 727, 976, 291, 364, 6713, 498, 309, 1177, 380, 362, 746, 1219, 4471, 300, 575, 264, 6854, 13397, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.2261108076068717, "compression_ratio": 1.560846560846561, "no_speech_prob": 9.080292329599615e-06}, {"id": 163, "seek": 94900, "start": 949.0, "end": 973.0, "text": " Yeah. There's also the opposite thing, where, for instance, in Elm review simplify, I tried to simplify code that uses maps. But if I don't know what the type is, then I can't do the simplification. Like if I see list on map used in a certain way, like on an empty list, then I can know, okay, well, this is useless, I can just simplify it to an empty list.", "tokens": [865, 13, 821, 311, 611, 264, 6182, 551, 11, 689, 11, 337, 5197, 11, 294, 2699, 76, 3131, 20460, 11, 286, 3031, 281, 20460, 3089, 300, 4960, 11317, 13, 583, 498, 286, 500, 380, 458, 437, 264, 2010, 307, 11, 550, 286, 393, 380, 360, 264, 6883, 3774, 13, 1743, 498, 286, 536, 1329, 322, 4471, 1143, 294, 257, 1629, 636, 11, 411, 322, 364, 6707, 1329, 11, 550, 286, 393, 458, 11, 1392, 11, 731, 11, 341, 307, 14115, 11, 286, 393, 445, 20460, 309, 281, 364, 6707, 1329, 13], "temperature": 0.0, "avg_logprob": -0.19771589981882196, "compression_ratio": 1.6527777777777777, "no_speech_prob": 2.6687463105190545e-05}, {"id": 164, "seek": 97300, "start": 973.0, "end": 994.0, "text": " But if I have a map function that whose type I don't know, well, I have no clue whether that will, in fact, respect the laws of functors as they do it in Haskell. So, so we like we have a name we have a that is pretty standard, but we don't have all the guarantees that go with it.", "tokens": [583, 498, 286, 362, 257, 4471, 2445, 300, 6104, 2010, 286, 500, 380, 458, 11, 731, 11, 286, 362, 572, 13602, 1968, 300, 486, 11, 294, 1186, 11, 3104, 264, 6064, 295, 1019, 5547, 382, 436, 360, 309, 294, 8646, 43723, 13, 407, 11, 370, 321, 411, 321, 362, 257, 1315, 321, 362, 257, 300, 307, 1238, 3832, 11, 457, 321, 500, 380, 362, 439, 264, 32567, 300, 352, 365, 309, 13], "temperature": 0.0, "avg_logprob": -0.2285437081989489, "compression_ratio": 1.5698324022346368, "no_speech_prob": 0.0005112442886456847}, {"id": 165, "seek": 99400, "start": 994.0, "end": 1012.0, "text": " Like potentially, it's just a map that creates something, or maybe it's a map that has the same signature, but it does something entirely different. And that's, that's a bit annoying, but we don't have that information of does this follow those rules, those laws, because we could do something, a few things that would be quite nicer, I think.", "tokens": [1743, 7263, 11, 309, 311, 445, 257, 4471, 300, 7829, 746, 11, 420, 1310, 309, 311, 257, 4471, 300, 575, 264, 912, 13397, 11, 457, 309, 775, 746, 7696, 819, 13, 400, 300, 311, 11, 300, 311, 257, 857, 11304, 11, 457, 321, 500, 380, 362, 300, 1589, 295, 775, 341, 1524, 729, 4474, 11, 729, 6064, 11, 570, 321, 727, 360, 746, 11, 257, 1326, 721, 300, 576, 312, 1596, 22842, 11, 286, 519, 13], "temperature": 0.0, "avg_logprob": -0.1920113444328308, "compression_ratio": 1.6650485436893203, "no_speech_prob": 8.219276060117409e-05}, {"id": 166, "seek": 101200, "start": 1012.0, "end": 1032.0, "text": " But that is the case in Haskell, right? So that's some type says, well, I'm implementing or deriving or whatever, or what the term is, a functor. And therefore, this map now has to prove, does it have to prove that it follows some rules? Or does it not have to?", "tokens": [583, 300, 307, 264, 1389, 294, 8646, 43723, 11, 558, 30, 407, 300, 311, 512, 2010, 1619, 11, 731, 11, 286, 478, 18114, 420, 1163, 2123, 420, 2035, 11, 420, 437, 264, 1433, 307, 11, 257, 1019, 1672, 13, 400, 4412, 11, 341, 4471, 586, 575, 281, 7081, 11, 775, 309, 362, 281, 7081, 300, 309, 10002, 512, 4474, 30, 1610, 775, 309, 406, 362, 281, 30], "temperature": 0.0, "avg_logprob": -0.25646416570099306, "compression_ratio": 1.544378698224852, "no_speech_prob": 0.00023753248387947679}, {"id": 167, "seek": 103200, "start": 1032.0, "end": 1048.0, "text": " Yeah, you can check if it follows some rules. There are well, you can use one of the most used libraries is QuickCheck for property-based testing. And it comes by default for example, for checkers for the functor laws or the applicative laws or monad laws, and you can you can check.", "tokens": [865, 11, 291, 393, 1520, 498, 309, 10002, 512, 4474, 13, 821, 366, 731, 11, 291, 393, 764, 472, 295, 264, 881, 1143, 15148, 307, 12101, 47769, 337, 4707, 12, 6032, 4997, 13, 400, 309, 1487, 538, 7576, 337, 1365, 11, 337, 1520, 433, 337, 264, 1019, 1672, 6064, 420, 264, 2580, 1166, 6064, 420, 1108, 345, 6064, 11, 293, 291, 393, 291, 393, 1520, 13], "temperature": 0.0, "avg_logprob": -0.28283705030168804, "compression_ratio": 1.546448087431694, "no_speech_prob": 0.0007314527174457908}, {"id": 168, "seek": 104800, "start": 1048.0, "end": 1063.0, "text": " But if you use, for example, the deriving mechanisms from GHC, from the main Haskell compiler, whatever the GHC derives as a functor instance, you can be pretty sure that it's going to be a correct functor.", "tokens": [583, 498, 291, 764, 11, 337, 1365, 11, 264, 1163, 2123, 15902, 490, 40690, 34, 11, 490, 264, 2135, 8646, 43723, 31958, 11, 2035, 264, 40690, 34, 1163, 1539, 382, 257, 1019, 1672, 5197, 11, 291, 393, 312, 1238, 988, 300, 309, 311, 516, 281, 312, 257, 3006, 1019, 1672, 13], "temperature": 0.0, "avg_logprob": -0.15812828757546166, "compression_ratio": 1.3825503355704698, "no_speech_prob": 0.0006861230358481407}, {"id": 169, "seek": 106300, "start": 1063.0, "end": 1085.0, "text": " Unless there's more than one way to implement something which happens with some other instances, like with monoid instances, for example, or certain operators or for certain operations, there can be more than one valid implementation, then you need to disambiguate. But it's not so common with functors, I would say.", "tokens": [16581, 456, 311, 544, 813, 472, 636, 281, 4445, 746, 597, 2314, 365, 512, 661, 14519, 11, 411, 365, 1108, 17079, 14519, 11, 337, 1365, 11, 420, 1629, 19077, 420, 337, 1629, 7705, 11, 456, 393, 312, 544, 813, 472, 7363, 11420, 11, 550, 291, 643, 281, 717, 2173, 328, 10107, 13, 583, 309, 311, 406, 370, 2689, 365, 1019, 5547, 11, 286, 576, 584, 13], "temperature": 0.0, "avg_logprob": -0.24663808005196708, "compression_ratio": 1.6458333333333333, "no_speech_prob": 4.130261004320346e-05}, {"id": 170, "seek": 108500, "start": 1085.0, "end": 1114.0, "text": " Yeah. So one thing that I was wondering about is like, you made this suite of blog posts for Haskell for Elm developers. Why specifically Elm developers? Is it because all of your colleagues are Elm developers? Or is it because like, we're doing something wrong? Or, well, we are the closest ones to be able to reach for this information, like JavaScript developers, they're not close enough, but Elm developers, they just have to know the names.", "tokens": [865, 13, 407, 472, 551, 300, 286, 390, 6359, 466, 307, 411, 11, 291, 1027, 341, 14205, 295, 6968, 12300, 337, 8646, 43723, 337, 2699, 76, 8849, 13, 1545, 4682, 2699, 76, 8849, 30, 1119, 309, 570, 439, 295, 428, 7734, 366, 2699, 76, 8849, 30, 1610, 307, 309, 570, 411, 11, 321, 434, 884, 746, 2085, 30, 1610, 11, 731, 11, 321, 366, 264, 13699, 2306, 281, 312, 1075, 281, 2524, 337, 341, 1589, 11, 411, 15778, 8849, 11, 436, 434, 406, 1998, 1547, 11, 457, 2699, 76, 8849, 11, 436, 445, 362, 281, 458, 264, 5288, 13], "temperature": 0.0, "avg_logprob": -0.23722626399068, "compression_ratio": 1.7421875, "no_speech_prob": 6.0136790125397965e-05}, {"id": 171, "seek": 111400, "start": 1114.0, "end": 1115.0, "text": " And it's good.", "tokens": [400, 309, 311, 665, 13], "temperature": 0.0, "avg_logprob": -0.2032684854941793, "compression_ratio": 1.6290322580645162, "no_speech_prob": 0.005215043667703867}, {"id": 172, "seek": 111400, "start": 1115.0, "end": 1142.0, "text": " Yeah, exactly. I think knowing Elm makes you closer to Haskell than knowing any other language. Because you could consider to some point Elm to be some kind of subset of the Haskell language, like a very small subset. And then I'm a little lazy as a functional engineer, you know, and then I was wondering, hey, I really want to teach Haskell. What's the best audience to teach Haskell to?", "tokens": [865, 11, 2293, 13, 286, 519, 5276, 2699, 76, 1669, 291, 4966, 281, 8646, 43723, 813, 5276, 604, 661, 2856, 13, 1436, 291, 727, 1949, 281, 512, 935, 2699, 76, 281, 312, 512, 733, 295, 25993, 295, 264, 8646, 43723, 2856, 11, 411, 257, 588, 1359, 25993, 13, 400, 550, 286, 478, 257, 707, 14847, 382, 257, 11745, 11403, 11, 291, 458, 11, 293, 550, 286, 390, 6359, 11, 4177, 11, 286, 534, 528, 281, 2924, 8646, 43723, 13, 708, 311, 264, 1151, 4034, 281, 2924, 8646, 43723, 281, 30], "temperature": 0.0, "avg_logprob": -0.2032684854941793, "compression_ratio": 1.6290322580645162, "no_speech_prob": 0.005215043667703867}, {"id": 173, "seek": 114200, "start": 1142.0, "end": 1171.0, "text": " Because they have very little to learn, actually, if they want to, to learn Haskell. And also it happened to be that yes, my previous job was was Elm. And I was finding more and more Elm developers in Twitter, especially on Slack, interested into the Haskell language. I was, for example, part of the Haskell channel in the Slack. And there were many questions. So I could see there was some some kind of community or a pool of people that were trying to learn Haskell. And I thought, okay, I'm going to try to teach them.", "tokens": [1436, 436, 362, 588, 707, 281, 1466, 11, 767, 11, 498, 436, 528, 281, 11, 281, 1466, 8646, 43723, 13, 400, 611, 309, 2011, 281, 312, 300, 2086, 11, 452, 3894, 1691, 390, 390, 2699, 76, 13, 400, 286, 390, 5006, 544, 293, 544, 2699, 76, 8849, 294, 5794, 11, 2318, 322, 37211, 11, 3102, 666, 264, 8646, 43723, 2856, 13, 286, 390, 11, 337, 1365, 11, 644, 295, 264, 8646, 43723, 2269, 294, 264, 37211, 13, 400, 456, 645, 867, 1651, 13, 407, 286, 727, 536, 456, 390, 512, 512, 733, 295, 1768, 420, 257, 7005, 295, 561, 300, 645, 1382, 281, 1466, 8646, 43723, 13, 400, 286, 1194, 11, 1392, 11, 286, 478, 516, 281, 853, 281, 2924, 552, 13], "temperature": 0.0, "avg_logprob": -0.3345313299269903, "compression_ratio": 1.728476821192053, "no_speech_prob": 0.021915871649980545}, {"id": 174, "seek": 117100, "start": 1171.0, "end": 1191.0, "text": " And I thought, hey, I might have something to say in this domain, that might be useful for someone else. And I really, it got me excited, because I love Haskell. And I love Elm. And I said, hey, if whatever I struggled to learn all those years, is useful for somebody else and wants to have a head start on Haskell, I'm happy to write those, you know.", "tokens": [400, 286, 1194, 11, 4177, 11, 286, 1062, 362, 746, 281, 584, 294, 341, 9274, 11, 300, 1062, 312, 4420, 337, 1580, 1646, 13, 400, 286, 534, 11, 309, 658, 385, 2919, 11, 570, 286, 959, 8646, 43723, 13, 400, 286, 959, 2699, 76, 13, 400, 286, 848, 11, 4177, 11, 498, 2035, 286, 19023, 281, 1466, 439, 729, 924, 11, 307, 4420, 337, 2618, 1646, 293, 2738, 281, 362, 257, 1378, 722, 322, 8646, 43723, 11, 286, 478, 2055, 281, 2464, 729, 11, 291, 458, 13], "temperature": 0.0, "avg_logprob": -0.2513378478668548, "compression_ratio": 1.6401869158878504, "no_speech_prob": 0.006992970127612352}, {"id": 175, "seek": 119100, "start": 1191.0, "end": 1201.0, "text": " Do you think with hindsight, that you would have preferred learning Elm before Haskell? Would that have made it easier? Yeah.", "tokens": [1144, 291, 519, 365, 44357, 11, 300, 291, 576, 362, 16494, 2539, 2699, 76, 949, 8646, 43723, 30, 6068, 300, 362, 1027, 309, 3571, 30, 865, 13], "temperature": 0.0, "avg_logprob": -0.27106005145657447, "compression_ratio": 1.1682242990654206, "no_speech_prob": 0.0011140728602185845}, {"id": 176, "seek": 120100, "start": 1201.0, "end": 1223.0, "text": " Yeah, for sure. Because it's like starting small, and then using stuff and getting proficient with things and then having the next jump. But in retrospective, I cannot regret my decision too much, because I'm hearing from some Elm developers that the gap is actually bigger than I expected when they tried to actually learn Haskell.", "tokens": [865, 11, 337, 988, 13, 1436, 309, 311, 411, 2891, 1359, 11, 293, 550, 1228, 1507, 293, 1242, 1740, 24549, 365, 721, 293, 550, 1419, 264, 958, 3012, 13, 583, 294, 34997, 488, 11, 286, 2644, 10879, 452, 3537, 886, 709, 11, 570, 286, 478, 4763, 490, 512, 2699, 76, 8849, 300, 264, 7417, 307, 767, 3801, 813, 286, 5176, 562, 436, 3031, 281, 767, 1466, 8646, 43723, 13], "temperature": 0.0, "avg_logprob": -0.18393379368194163, "compression_ratio": 1.5229357798165137, "no_speech_prob": 0.000412457826314494}, {"id": 177, "seek": 122300, "start": 1223.0, "end": 1243.0, "text": " So going the hardcore path first of trying to learn Haskell, it paid the dividends in the end, you know, it was it was worth it, because I learned Haskell, I learned Elm, and I also got to understand OCaml and Reason and many other functional languages, Fshare, for example, I was trying Fshare for some time.", "tokens": [407, 516, 264, 28196, 3100, 700, 295, 1382, 281, 1466, 8646, 43723, 11, 309, 4835, 264, 39675, 294, 264, 917, 11, 291, 458, 11, 309, 390, 309, 390, 3163, 309, 11, 570, 286, 3264, 8646, 43723, 11, 286, 3264, 2699, 76, 11, 293, 286, 611, 658, 281, 1223, 422, 31030, 75, 293, 39693, 293, 867, 661, 11745, 8650, 11, 479, 2716, 289, 68, 11, 337, 1365, 11, 286, 390, 1382, 479, 2716, 543, 337, 512, 565, 13], "temperature": 0.0, "avg_logprob": -0.2362755904962987, "compression_ratio": 1.5765306122448979, "no_speech_prob": 0.0025044342037290335}, {"id": 178, "seek": 124300, "start": 1243.0, "end": 1253.0, "text": " And I could feel that the hardest part of the language I already understood, which was incredible for me. So it was time well spent, definitely. Gotcha.", "tokens": [400, 286, 727, 841, 300, 264, 13158, 644, 295, 264, 2856, 286, 1217, 7320, 11, 597, 390, 4651, 337, 385, 13, 407, 309, 390, 565, 731, 4418, 11, 2138, 13, 42109, 13], "temperature": 0.0, "avg_logprob": -0.18545125590430367, "compression_ratio": 1.256198347107438, "no_speech_prob": 0.0004652925708796829}, {"id": 179, "seek": 125300, "start": 1253.0, "end": 1278.0, "text": " I've always found Haskell to be intimidating, personally. And I mean, I think some of it is like, some of the names and operators seem cryptic to me. And it just is like a lot of concepts that are hard to make sense out of. But I'd be curious to hear your thoughts on like, for an Elm developer, what types of things might they do with Haskell?", "tokens": [286, 600, 1009, 1352, 8646, 43723, 281, 312, 29714, 11, 5665, 13, 400, 286, 914, 11, 286, 519, 512, 295, 309, 307, 411, 11, 512, 295, 264, 5288, 293, 19077, 1643, 9844, 299, 281, 385, 13, 400, 309, 445, 307, 411, 257, 688, 295, 10392, 300, 366, 1152, 281, 652, 2020, 484, 295, 13, 583, 286, 1116, 312, 6369, 281, 1568, 428, 4598, 322, 411, 11, 337, 364, 2699, 76, 10754, 11, 437, 3467, 295, 721, 1062, 436, 360, 365, 8646, 43723, 30], "temperature": 0.0, "avg_logprob": -0.19168972146922145, "compression_ratio": 1.5426008968609866, "no_speech_prob": 9.605394006939605e-05}, {"id": 180, "seek": 127800, "start": 1278.0, "end": 1285.0, "text": " And if they, you know, if they paid that cost of learning Haskell, what are the cool things that you can build with Haskell?", "tokens": [400, 498, 436, 11, 291, 458, 11, 498, 436, 4835, 300, 2063, 295, 2539, 8646, 43723, 11, 437, 366, 264, 1627, 721, 300, 291, 393, 1322, 365, 8646, 43723, 30], "temperature": 0.0, "avg_logprob": -0.2763273192615044, "compression_ratio": 1.3017241379310345, "no_speech_prob": 0.001031850348226726}, {"id": 181, "seek": 127800, "start": 1285.0, "end": 1289.0, "text": " Except an academic career.", "tokens": [16192, 364, 7778, 3988, 13], "temperature": 0.0, "avg_logprob": -0.2763273192615044, "compression_ratio": 1.3017241379310345, "no_speech_prob": 0.001031850348226726}, {"id": 182, "seek": 128900, "start": 1289.0, "end": 1308.0, "text": " Exactly. So, you know, now there's all this fuss going on about probably having Elm in the backend. We don't know yet, right? But there's some expectation. But before that, we don't actually know what's going to happen. Hopefully, we will have some news regarding that.", "tokens": [7587, 13, 407, 11, 291, 458, 11, 586, 456, 311, 439, 341, 34792, 516, 322, 466, 1391, 1419, 2699, 76, 294, 264, 38087, 13, 492, 500, 380, 458, 1939, 11, 558, 30, 583, 456, 311, 512, 14334, 13, 583, 949, 300, 11, 321, 500, 380, 767, 458, 437, 311, 516, 281, 1051, 13, 10429, 11, 321, 486, 362, 512, 2583, 8595, 300, 13], "temperature": 0.0, "avg_logprob": -0.22271372666999475, "compression_ratio": 1.454054054054054, "no_speech_prob": 0.0003792167699430138}, {"id": 183, "seek": 130800, "start": 1308.0, "end": 1330.0, "text": " But if you wanted to experience this feeling of you being in control of your code, of the compiler assisting you, of checking every possible case of your code, etc. If you wanted to have the same experience you have with Elm, but in the backend, or for something, for a more general purpose programming language that could pretty much do anything, then you needed to look for alternatives.", "tokens": [583, 498, 291, 1415, 281, 1752, 341, 2633, 295, 291, 885, 294, 1969, 295, 428, 3089, 11, 295, 264, 31958, 40368, 291, 11, 295, 8568, 633, 1944, 1389, 295, 428, 3089, 11, 5183, 13, 759, 291, 1415, 281, 362, 264, 912, 1752, 291, 362, 365, 2699, 76, 11, 457, 294, 264, 38087, 11, 420, 337, 746, 11, 337, 257, 544, 2674, 4334, 9410, 2856, 300, 727, 1238, 709, 360, 1340, 11, 550, 291, 2978, 281, 574, 337, 20478, 13], "temperature": 0.0, "avg_logprob": -0.19974175418715878, "compression_ratio": 1.7212389380530972, "no_speech_prob": 0.0004950008005835116}, {"id": 184, "seek": 133000, "start": 1330.0, "end": 1351.0, "text": " For example, Haskell is one of them. And yeah, even though the learning curve is a little bit different, but you could do what's no Red Ink does, for example, using a small subset of Haskell as well and have packages and imports look like Elm code. And their Haskell pretty much resembles Elm. So that's a very interesting approach as well.", "tokens": [1171, 1365, 11, 8646, 43723, 307, 472, 295, 552, 13, 400, 1338, 11, 754, 1673, 264, 2539, 7605, 307, 257, 707, 857, 819, 11, 457, 291, 727, 360, 437, 311, 572, 4477, 31147, 775, 11, 337, 1365, 11, 1228, 257, 1359, 25993, 295, 8646, 43723, 382, 731, 293, 362, 17401, 293, 41596, 574, 411, 2699, 76, 3089, 13, 400, 641, 8646, 43723, 1238, 709, 34433, 2699, 76, 13, 407, 300, 311, 257, 588, 1880, 3109, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.21707890250466086, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.00037389766657724977}, {"id": 185, "seek": 133000, "start": 1351.0, "end": 1359.0, "text": " Is it called like cherry prelude? Is that what their helper is called that gives you like an Elm-like core?", "tokens": [1119, 309, 1219, 411, 20164, 659, 32334, 30, 1119, 300, 437, 641, 36133, 307, 1219, 300, 2709, 291, 411, 364, 2699, 76, 12, 4092, 4965, 30], "temperature": 0.0, "avg_logprob": -0.21707890250466086, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.00037389766657724977}, {"id": 186, "seek": 135900, "start": 1359.0, "end": 1375.0, "text": " I think I've looked at nri prelude is what they use like a Haskell package that turns your Haskell prelude into an Elm-ish kind of looking prelude. So that's interesting, but maybe they do something else as well.", "tokens": [286, 519, 286, 600, 2956, 412, 297, 470, 659, 32334, 307, 437, 436, 764, 411, 257, 8646, 43723, 7372, 300, 4523, 428, 8646, 43723, 659, 32334, 666, 364, 2699, 76, 12, 742, 733, 295, 1237, 659, 32334, 13, 407, 300, 311, 1880, 11, 457, 1310, 436, 360, 746, 1646, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.23480933053152903, "compression_ratio": 1.4324324324324325, "no_speech_prob": 0.0012447874760255218}, {"id": 187, "seek": 137500, "start": 1375.0, "end": 1390.0, "text": " Yeah, Teresa has a package called cherry core, which is a set of basic functions, but maybe they are influenced by each other. I think at some point they may have been using Teresa's cherry core.", "tokens": [865, 11, 35039, 575, 257, 7372, 1219, 20164, 4965, 11, 597, 307, 257, 992, 295, 3875, 6828, 11, 457, 1310, 436, 366, 15269, 538, 1184, 661, 13, 286, 519, 412, 512, 935, 436, 815, 362, 668, 1228, 35039, 311, 20164, 4965, 13], "temperature": 0.0, "avg_logprob": -0.23900380050926878, "compression_ratio": 1.4390243902439024, "no_speech_prob": 7.368127990048379e-05}, {"id": 188, "seek": 137500, "start": 1390.0, "end": 1392.0, "text": " Interesting. First time I hear about it.", "tokens": [14711, 13, 2386, 565, 286, 1568, 466, 309, 13], "temperature": 0.0, "avg_logprob": -0.23900380050926878, "compression_ratio": 1.4390243902439024, "no_speech_prob": 7.368127990048379e-05}, {"id": 189, "seek": 139200, "start": 1392.0, "end": 1414.0, "text": " So one of the things that always seemed really cool to me, but also a little bit cryptic is the do notation. So maybe we should first talk a little bit about monads. We have talked about them on previous episodes, but do you want to do your best monad elevator pitch?", "tokens": [407, 472, 295, 264, 721, 300, 1009, 6576, 534, 1627, 281, 385, 11, 457, 611, 257, 707, 857, 9844, 299, 307, 264, 360, 24657, 13, 407, 1310, 321, 820, 700, 751, 257, 707, 857, 466, 1108, 5834, 13, 492, 362, 2825, 466, 552, 322, 3894, 9313, 11, 457, 360, 291, 528, 281, 360, 428, 1151, 1108, 345, 18782, 7293, 30], "temperature": 0.0, "avg_logprob": -0.21156069967481825, "compression_ratio": 1.5238095238095237, "no_speech_prob": 0.0012836247915402055}, {"id": 190, "seek": 139200, "start": 1414.0, "end": 1417.0, "text": " In 10 words or less.", "tokens": [682, 1266, 2283, 420, 1570, 13], "temperature": 0.0, "avg_logprob": -0.21156069967481825, "compression_ratio": 1.5238095238095237, "no_speech_prob": 0.0012836247915402055}, {"id": 191, "seek": 141700, "start": 1417.0, "end": 1442.0, "text": " Wow, that's gonna be difficult. Well, basically monads allow you to conditionally chain computations, basically. So when you need something like an fmap or a mapping function, but you need to have more power over what to do next, and you end up having to use monads.", "tokens": [3153, 11, 300, 311, 799, 312, 2252, 13, 1042, 11, 1936, 1108, 5834, 2089, 291, 281, 4188, 379, 5021, 2807, 763, 11, 1936, 13, 407, 562, 291, 643, 746, 411, 364, 283, 24223, 420, 257, 18350, 2445, 11, 457, 291, 643, 281, 362, 544, 1347, 670, 437, 281, 360, 958, 11, 293, 291, 917, 493, 1419, 281, 764, 1108, 5834, 13], "temperature": 0.0, "avg_logprob": -0.23014341501089242, "compression_ratio": 1.528735632183908, "no_speech_prob": 0.0024678416084498167}, {"id": 192, "seek": 144200, "start": 1442.0, "end": 1457.0, "text": " That's why Elm has something called and then, which reads quite nicely and it's easy to understand. But surprisingly, or the list data type, it's called concat map.", "tokens": [663, 311, 983, 2699, 76, 575, 746, 1219, 293, 550, 11, 597, 15700, 1596, 9594, 293, 309, 311, 1858, 281, 1223, 13, 583, 17600, 11, 420, 264, 1329, 1412, 2010, 11, 309, 311, 1219, 1588, 267, 4471, 13], "temperature": 0.0, "avg_logprob": -0.2743007342020671, "compression_ratio": 1.3015873015873016, "no_speech_prob": 0.0020621875301003456}, {"id": 193, "seek": 145700, "start": 1457.0, "end": 1472.0, "text": " So Elm was not consistent with that and then name just for lists, because it's easier to understand that you might want to flat map a list or might want to concat map something. But it's the only case in which it is not consistent.", "tokens": [407, 2699, 76, 390, 406, 8398, 365, 300, 293, 550, 1315, 445, 337, 14511, 11, 570, 309, 311, 3571, 281, 1223, 300, 291, 1062, 528, 281, 4962, 4471, 257, 1329, 420, 1062, 528, 281, 1588, 267, 4471, 746, 13, 583, 309, 311, 264, 787, 1389, 294, 597, 309, 307, 406, 8398, 13], "temperature": 0.0, "avg_logprob": -0.22731004442487443, "compression_ratio": 1.54, "no_speech_prob": 0.00010343269968871027}, {"id": 194, "seek": 147200, "start": 1472.0, "end": 1494.0, "text": " Yeah, Elm does tend to use more domain terms for naming things when possible. But then certain things like mapping, sometimes you can have a more domain like term for mapping, but usually it's just map and it's easier to just in the case of map, it's a pretty clear case where you just say, yeah, you're just mapping this data.", "tokens": [865, 11, 2699, 76, 775, 3928, 281, 764, 544, 9274, 2115, 337, 25290, 721, 562, 1944, 13, 583, 550, 1629, 721, 411, 18350, 11, 2171, 291, 393, 362, 257, 544, 9274, 411, 1433, 337, 18350, 11, 457, 2673, 309, 311, 445, 4471, 293, 309, 311, 3571, 281, 445, 294, 264, 1389, 295, 4471, 11, 309, 311, 257, 1238, 1850, 1389, 689, 291, 445, 584, 11, 1338, 11, 291, 434, 445, 18350, 341, 1412, 13], "temperature": 0.0, "avg_logprob": -0.20006059988951072, "compression_ratio": 1.676923076923077, "no_speech_prob": 0.0001105586052290164}, {"id": 195, "seek": 149400, "start": 1494.0, "end": 1521.0, "text": " Let's just learn the concept that you can map things. But yeah, in the case of like, and thening a list, that could be confusing. I will say since our conversation with Joelle, where we talked about some of these category theory ideas, and I expressed my difficulty with reasoning about and thening a maybe type, I now feel more confident doing that and more comfortable. It feels more intuitive.", "tokens": [961, 311, 445, 1466, 264, 3410, 300, 291, 393, 4471, 721, 13, 583, 1338, 11, 294, 264, 1389, 295, 411, 11, 293, 550, 278, 257, 1329, 11, 300, 727, 312, 13181, 13, 286, 486, 584, 1670, 527, 3761, 365, 3139, 4434, 11, 689, 321, 2825, 466, 512, 295, 613, 7719, 5261, 3487, 11, 293, 286, 12675, 452, 10360, 365, 21577, 466, 293, 550, 278, 257, 1310, 2010, 11, 286, 586, 841, 544, 6679, 884, 300, 293, 544, 4619, 13, 467, 3417, 544, 21769, 13], "temperature": 0.0, "avg_logprob": -0.24757151170210404, "compression_ratio": 1.6708860759493671, "no_speech_prob": 0.00019409056403674185}, {"id": 196, "seek": 152100, "start": 1521.0, "end": 1532.0, "text": " So having the discussion about some of these things has helped me a little bit with building up an intuition for this a little bit more. So I think there's definitely value to it.", "tokens": [407, 1419, 264, 5017, 466, 512, 295, 613, 721, 575, 4254, 385, 257, 707, 857, 365, 2390, 493, 364, 24002, 337, 341, 257, 707, 857, 544, 13, 407, 286, 519, 456, 311, 2138, 2158, 281, 309, 13], "temperature": 0.0, "avg_logprob": -0.16972306879555307, "compression_ratio": 1.4094488188976377, "no_speech_prob": 0.0030749868601560593}, {"id": 197, "seek": 153200, "start": 1532.0, "end": 1560.0, "text": " So yeah, so in Elm, you can end then in a JSON decoder and you can then have access to the actual decoded value in the chain so far and do something based on that. You can succeed or fail or do another JSON decoder conditionally based on that. Or in a task, you can have access to time.now, task.endthen, and then now you have the time.", "tokens": [407, 1338, 11, 370, 294, 2699, 76, 11, 291, 393, 917, 550, 294, 257, 31828, 979, 19866, 293, 291, 393, 550, 362, 2105, 281, 264, 3539, 979, 12340, 2158, 294, 264, 5021, 370, 1400, 293, 360, 746, 2361, 322, 300, 13, 509, 393, 7754, 420, 3061, 420, 360, 1071, 31828, 979, 19866, 4188, 379, 2361, 322, 300, 13, 1610, 294, 257, 5633, 11, 291, 393, 362, 2105, 281, 565, 13, 3785, 11, 5633, 13, 521, 19096, 11, 293, 550, 586, 291, 362, 264, 565, 13], "temperature": 0.0, "avg_logprob": -0.24621547741836378, "compression_ratio": 1.7872340425531914, "no_speech_prob": 0.00015596764569636434}, {"id": 198, "seek": 156000, "start": 1560.0, "end": 1566.0, "text": " So Elm developers will be familiar with that general concept of and thening something.", "tokens": [407, 2699, 76, 8849, 486, 312, 4963, 365, 300, 2674, 3410, 295, 293, 550, 278, 746, 13], "temperature": 0.0, "avg_logprob": -0.29431320900140806, "compression_ratio": 1.6233766233766234, "no_speech_prob": 0.00030045988387428224}, {"id": 199, "seek": 156000, "start": 1566.0, "end": 1583.0, "text": " Yeah, and interestingly, it comes up a lot while trying to use effects, right? Like side effects, like for example, in I think when Elm developers use the task data type, they probably are going to eventually end up using and then, task and then, and that happens very frequently as well.", "tokens": [865, 11, 293, 25873, 11, 309, 1487, 493, 257, 688, 1339, 1382, 281, 764, 5065, 11, 558, 30, 1743, 1252, 5065, 11, 411, 337, 1365, 11, 294, 286, 519, 562, 2699, 76, 8849, 764, 264, 5633, 1412, 2010, 11, 436, 1391, 366, 516, 281, 4728, 917, 493, 1228, 293, 550, 11, 5633, 293, 550, 11, 293, 300, 2314, 588, 10374, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.29431320900140806, "compression_ratio": 1.6233766233766234, "no_speech_prob": 0.00030045988387428224}, {"id": 200, "seek": 158300, "start": 1583.0, "end": 1591.0, "text": " I will want to go back to talk about effects afterwards, but I think Dillon wants to continue on the do notation.", "tokens": [286, 486, 528, 281, 352, 646, 281, 751, 466, 5065, 10543, 11, 457, 286, 519, 28160, 2738, 281, 2354, 322, 264, 360, 24657, 13], "temperature": 0.0, "avg_logprob": -0.2620465414864676, "compression_ratio": 1.1926605504587156, "no_speech_prob": 2.1781692339573056e-05}, {"id": 201, "seek": 158300, "start": 1591.0, "end": 1592.0, "text": " Sure, no problem.", "tokens": [4894, 11, 572, 1154, 13], "temperature": 0.0, "avg_logprob": -0.2620465414864676, "compression_ratio": 1.1926605504587156, "no_speech_prob": 2.1781692339573056e-05}, {"id": 202, "seek": 159200, "start": 1592.0, "end": 1614.0, "text": " Well, I wonder if you can demystify that for me a little bit because I've always whenever I see a little Haskell snippet and it uses the do notation, I'm always thinking like that seems very helpful and interesting, but I don't quite understand what does it do, you might say. And I wonder if you could demystify that for me.", "tokens": [1042, 11, 286, 2441, 498, 291, 393, 1371, 38593, 2505, 300, 337, 385, 257, 707, 857, 570, 286, 600, 1009, 5699, 286, 536, 257, 707, 8646, 43723, 35623, 302, 293, 309, 4960, 264, 360, 24657, 11, 286, 478, 1009, 1953, 411, 300, 2544, 588, 4961, 293, 1880, 11, 457, 286, 500, 380, 1596, 1223, 437, 775, 309, 360, 11, 291, 1062, 584, 13, 400, 286, 2441, 498, 291, 727, 1371, 38593, 2505, 300, 337, 385, 13], "temperature": 0.0, "avg_logprob": -0.2381842041015625, "compression_ratio": 1.6514522821576763, "no_speech_prob": 0.00017392051813658327}, {"id": 203, "seek": 159200, "start": 1614.0, "end": 1619.0, "text": " Yeah, without showing code is kind of difficult, but I will try my best.", "tokens": [865, 11, 1553, 402, 9637, 3089, 307, 733, 295, 2252, 11, 457, 286, 486, 853, 452, 1151, 13], "temperature": 0.0, "avg_logprob": -0.2381842041015625, "compression_ratio": 1.6514522821576763, "no_speech_prob": 0.00017392051813658327}, {"id": 204, "seek": 161900, "start": 1619.0, "end": 1644.0, "text": " Basically, when you want to and then a lot of things, and this happened also in some Elm code, right? For example, I'm looking at the implementation of the map five for task. It has like, task XA, task XB, like a bunch of tasks. And when you want to chain those with and then you end up having lots of nested. And how do you call the indentation?", "tokens": [8537, 11, 562, 291, 528, 281, 293, 550, 257, 688, 295, 721, 11, 293, 341, 2011, 611, 294, 512, 2699, 76, 3089, 11, 558, 30, 1171, 1365, 11, 286, 478, 1237, 412, 264, 11420, 295, 264, 4471, 1732, 337, 5633, 13, 467, 575, 411, 11, 5633, 1783, 32, 11, 5633, 1783, 33, 11, 411, 257, 3840, 295, 9608, 13, 400, 562, 291, 528, 281, 5021, 729, 365, 293, 550, 291, 917, 493, 1419, 3195, 295, 15646, 292, 13, 400, 577, 360, 291, 818, 264, 44494, 399, 30], "temperature": 0.0, "avg_logprob": -0.3086901100314393, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.007005512714385986}, {"id": 205, "seek": 161900, "start": 1644.0, "end": 1645.0, "text": " Indentation hell.", "tokens": [2333, 317, 399, 4921, 13], "temperature": 0.0, "avg_logprob": -0.3086901100314393, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.007005512714385986}, {"id": 206, "seek": 164500, "start": 1645.0, "end": 1649.0, "text": " Indentation, yeah. You have like a callback hell, like an indentation hell.", "tokens": [2333, 317, 399, 11, 1338, 13, 509, 362, 411, 257, 818, 3207, 4921, 11, 411, 364, 44494, 399, 4921, 13], "temperature": 0.0, "avg_logprob": -0.20872047712218086, "compression_ratio": 1.6639004149377594, "no_speech_prob": 0.0009247577399946749}, {"id": 207, "seek": 164500, "start": 1649.0, "end": 1650.0, "text": " Right, right, totally.", "tokens": [1779, 11, 558, 11, 3879, 13], "temperature": 0.0, "avg_logprob": -0.20872047712218086, "compression_ratio": 1.6639004149377594, "no_speech_prob": 0.0009247577399946749}, {"id": 208, "seek": 164500, "start": 1650.0, "end": 1670.0, "text": " And you cannot skip it. And I remember, for example, Martin Janicek opening an Elm format issue saying, hey, is there some way to prevent Elm format to do this indentation thing? And it's not the scope of Elm formats to fix that because it's actually code that needs to be indented semantically, right?", "tokens": [400, 291, 2644, 10023, 309, 13, 400, 286, 1604, 11, 337, 1365, 11, 9184, 4956, 573, 74, 5193, 364, 2699, 76, 7877, 2734, 1566, 11, 4177, 11, 307, 456, 512, 636, 281, 4871, 2699, 76, 7877, 281, 360, 341, 44494, 399, 551, 30, 400, 309, 311, 406, 264, 11923, 295, 2699, 76, 25879, 281, 3191, 300, 570, 309, 311, 767, 3089, 300, 2203, 281, 312, 1016, 6003, 4361, 49505, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.20872047712218086, "compression_ratio": 1.6639004149377594, "no_speech_prob": 0.0009247577399946749}, {"id": 209, "seek": 167000, "start": 1670.0, "end": 1688.0, "text": " So do notation is just the nice thing about it is that it's basically just syntactic sugar. So instead of having to indent every single lambda expression after the bind operator, it lets you a way of opening some block of code. And F sharp has this as well.", "tokens": [407, 360, 24657, 307, 445, 264, 1481, 551, 466, 309, 307, 300, 309, 311, 1936, 445, 23980, 19892, 5076, 13, 407, 2602, 295, 1419, 281, 44494, 633, 2167, 13607, 6114, 934, 264, 14786, 12973, 11, 309, 6653, 291, 257, 636, 295, 5193, 512, 3461, 295, 3089, 13, 400, 479, 8199, 575, 341, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.2344890529826536, "compression_ratio": 1.4519774011299436, "no_speech_prob": 0.001168775837868452}, {"id": 210, "seek": 168800, "start": 1688.0, "end": 1701.0, "text": " But it is literally like you open a block of code in Haskell, it starts by two, and then you start to bind things into names that are going to be the result of applying that bind operator and the lambda expression.", "tokens": [583, 309, 307, 3736, 411, 291, 1269, 257, 3461, 295, 3089, 294, 8646, 43723, 11, 309, 3719, 538, 732, 11, 293, 550, 291, 722, 281, 14786, 721, 666, 5288, 300, 366, 516, 281, 312, 264, 1874, 295, 9275, 300, 14786, 12973, 293, 264, 13607, 6114, 13], "temperature": 0.0, "avg_logprob": -0.21823785781860353, "compression_ratio": 1.4758620689655173, "no_speech_prob": 7.0280468207784e-05}, {"id": 211, "seek": 170100, "start": 1701.0, "end": 1718.0, "text": " So instead of all your code going deep and deep into indentation, it allows you to have a more flat, like a vertical align kind of code that basically does the same underneath. The Haskell compiler will desugar this into all the bind and lambda expression function calls.", "tokens": [407, 2602, 295, 439, 428, 3089, 516, 2452, 293, 2452, 666, 44494, 399, 11, 309, 4045, 291, 281, 362, 257, 544, 4962, 11, 411, 257, 9429, 7975, 733, 295, 3089, 300, 1936, 775, 264, 912, 7223, 13, 440, 8646, 43723, 31958, 486, 730, 8307, 341, 666, 439, 264, 14786, 293, 13607, 6114, 2445, 5498, 13], "temperature": 0.0, "avg_logprob": -0.19843906467243777, "compression_ratio": 1.5055555555555555, "no_speech_prob": 9.158127068076283e-05}, {"id": 212, "seek": 171800, "start": 1718.0, "end": 1732.0, "text": " But it just looks more natural or easier for the developer to look at the code with do notation sometimes, because people apparently in the Haskell community, some of them are not all of them are not big fans of do notation.", "tokens": [583, 309, 445, 1542, 544, 3303, 420, 3571, 337, 264, 10754, 281, 574, 412, 264, 3089, 365, 360, 24657, 2171, 11, 570, 561, 7970, 294, 264, 8646, 43723, 1768, 11, 512, 295, 552, 366, 406, 439, 295, 552, 366, 406, 955, 4499, 295, 360, 24657, 13], "temperature": 0.0, "avg_logprob": -0.2223236249840778, "compression_ratio": 1.641350210970464, "no_speech_prob": 2.1109864974278025e-05}, {"id": 213, "seek": 171800, "start": 1732.0, "end": 1734.0, "text": " That's a completely different topic.", "tokens": [663, 311, 257, 2584, 819, 4829, 13], "temperature": 0.0, "avg_logprob": -0.2223236249840778, "compression_ratio": 1.641350210970464, "no_speech_prob": 2.1109864974278025e-05}, {"id": 214, "seek": 171800, "start": 1734.0, "end": 1742.0, "text": " So is the do notation something that you would like to see in Elm as well? Or do you think it's actually better not to have it?", "tokens": [407, 307, 264, 360, 24657, 746, 300, 291, 576, 411, 281, 536, 294, 2699, 76, 382, 731, 30, 1610, 360, 291, 519, 309, 311, 767, 1101, 406, 281, 362, 309, 30], "temperature": 0.0, "avg_logprob": -0.2223236249840778, "compression_ratio": 1.641350210970464, "no_speech_prob": 2.1109864974278025e-05}, {"id": 215, "seek": 174200, "start": 1742.0, "end": 1758.0, "text": " Well, that's a that's a good question. I think it would not hurt to have it because it's like a syntactic choice. But you know that Elm is so simple that it doesn't often offer you various ways to do the same thing.", "tokens": [1042, 11, 300, 311, 257, 300, 311, 257, 665, 1168, 13, 286, 519, 309, 576, 406, 4607, 281, 362, 309, 570, 309, 311, 411, 257, 23980, 19892, 3922, 13, 583, 291, 458, 300, 2699, 76, 307, 370, 2199, 300, 309, 1177, 380, 2049, 2626, 291, 3683, 2098, 281, 360, 264, 912, 551, 13], "temperature": 0.0, "avg_logprob": -0.1788656000505414, "compression_ratio": 1.3870967741935485, "no_speech_prob": 0.000998771982267499}, {"id": 216, "seek": 175800, "start": 1758.0, "end": 1778.0, "text": " It prefers one single approved way of doing things. And this makes in the end things simpler. But for example, people building like for example, Martin Janicek building this Elm in Elm compiler and having all these nested lambda expressions, these people would argue that maybe it might be useful.", "tokens": [467, 44334, 472, 2167, 10826, 636, 295, 884, 721, 13, 400, 341, 1669, 294, 264, 917, 721, 18587, 13, 583, 337, 1365, 11, 561, 2390, 411, 337, 1365, 11, 9184, 4956, 573, 74, 2390, 341, 2699, 76, 294, 2699, 76, 31958, 293, 1419, 439, 613, 15646, 292, 13607, 15277, 11, 613, 561, 576, 9695, 300, 1310, 309, 1062, 312, 4420, 13], "temperature": 0.0, "avg_logprob": -0.2623232914851262, "compression_ratio": 1.546875, "no_speech_prob": 0.0009025956387631595}, {"id": 217, "seek": 177800, "start": 1778.0, "end": 1790.0, "text": " But being an Elm developer by myself, I've come across in a very few occasions of the need of saying, hey, I would, I would really love to do have you do notation right now.", "tokens": [583, 885, 364, 2699, 76, 10754, 538, 2059, 11, 286, 600, 808, 2108, 294, 257, 588, 1326, 20641, 295, 264, 643, 295, 1566, 11, 4177, 11, 286, 576, 11, 286, 576, 534, 959, 281, 360, 362, 291, 360, 24657, 558, 586, 13], "temperature": 0.0, "avg_logprob": -0.216918093486897, "compression_ratio": 1.584313725490196, "no_speech_prob": 0.00019083815277554095}, {"id": 218, "seek": 177800, "start": 1790.0, "end": 1803.0, "text": " It's like you don't often nest your code that much. I know there, there's a case to be made against well, in favor of people really needing this. So I think it wouldn't hurt. But I understand why it's not included in the language.", "tokens": [467, 311, 411, 291, 500, 380, 2049, 15646, 428, 3089, 300, 709, 13, 286, 458, 456, 11, 456, 311, 257, 1389, 281, 312, 1027, 1970, 731, 11, 294, 2294, 295, 561, 534, 18006, 341, 13, 407, 286, 519, 309, 2759, 380, 4607, 13, 583, 286, 1223, 983, 309, 311, 406, 5556, 294, 264, 2856, 13], "temperature": 0.0, "avg_logprob": -0.216918093486897, "compression_ratio": 1.584313725490196, "no_speech_prob": 0.00019083815277554095}, {"id": 219, "seek": 180300, "start": 1803.0, "end": 1812.0, "text": " As someone who has to analyze Elm source codes, like the least amount of options that are available, the nicer it is for me.", "tokens": [1018, 1580, 567, 575, 281, 12477, 2699, 76, 4009, 14211, 11, 411, 264, 1935, 2372, 295, 3956, 300, 366, 2435, 11, 264, 22842, 309, 307, 337, 385, 13], "temperature": 0.0, "avg_logprob": -0.29705744884053215, "compression_ratio": 1.4251497005988023, "no_speech_prob": 2.3186908947536722e-05}, {"id": 220, "seek": 180300, "start": 1812.0, "end": 1817.0, "text": " So exactly. The less amount of work.", "tokens": [407, 2293, 13, 440, 1570, 2372, 295, 589, 13], "temperature": 0.0, "avg_logprob": -0.29705744884053215, "compression_ratio": 1.4251497005988023, "no_speech_prob": 2.3186908947536722e-05}, {"id": 221, "seek": 180300, "start": 1817.0, "end": 1827.0, "text": " So I will actively give Evan money to not implement a new feature like that.", "tokens": [407, 286, 486, 13022, 976, 22613, 1460, 281, 406, 4445, 257, 777, 4111, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.29705744884053215, "compression_ratio": 1.4251497005988023, "no_speech_prob": 2.3186908947536722e-05}, {"id": 222, "seek": 182700, "start": 1827.0, "end": 1840.0, "text": " Some people would say a happy medium would be a formatter that allows you to do that a chain of and then lambdas without the indentation increasing every time you nest a lambda.", "tokens": [2188, 561, 576, 584, 257, 2055, 6399, 576, 312, 257, 1254, 1161, 300, 4045, 291, 281, 360, 300, 257, 5021, 295, 293, 550, 10097, 27476, 1553, 264, 44494, 399, 5662, 633, 565, 291, 15646, 257, 13607, 13], "temperature": 0.0, "avg_logprob": -0.1925410642856505, "compression_ratio": 1.4047619047619047, "no_speech_prob": 0.00017673503316473216}, {"id": 223, "seek": 184000, "start": 1840.0, "end": 1868.0, "text": " But yeah, so the do notation gives you a way to sequence things if you're comfortable putting the term sequence. Monads don't necessarily always mean a sequence because they could be a list or whatever. But it's a way of if it were tasks and you said task A, you're basically saying task A returns this value A, task B returns this value B, task C returns this value C.", "tokens": [583, 1338, 11, 370, 264, 360, 24657, 2709, 291, 257, 636, 281, 8310, 721, 498, 291, 434, 4619, 3372, 264, 1433, 8310, 13, 4713, 5834, 500, 380, 4725, 1009, 914, 257, 8310, 570, 436, 727, 312, 257, 1329, 420, 2035, 13, 583, 309, 311, 257, 636, 295, 498, 309, 645, 9608, 293, 291, 848, 5633, 316, 11, 291, 434, 1936, 1566, 5633, 316, 11247, 341, 2158, 316, 11, 5633, 363, 11247, 341, 2158, 363, 11, 5633, 383, 11247, 341, 2158, 383, 13], "temperature": 0.0, "avg_logprob": -0.22873794200808503, "compression_ratio": 1.7571428571428571, "no_speech_prob": 3.535113137331791e-05}, {"id": 224, "seek": 186800, "start": 1868.0, "end": 1878.0, "text": " So given the return values for each of these, do task A, then give me the return value of it. Do task B, then give me the return value of it. And then you can combine all of those after the do.", "tokens": [407, 2212, 264, 2736, 4190, 337, 1184, 295, 613, 11, 360, 5633, 316, 11, 550, 976, 385, 264, 2736, 2158, 295, 309, 13, 1144, 5633, 363, 11, 550, 976, 385, 264, 2736, 2158, 295, 309, 13, 400, 550, 291, 393, 10432, 439, 295, 729, 934, 264, 360, 13], "temperature": 0.0, "avg_logprob": -0.2076537691313645, "compression_ratio": 1.9388888888888889, "no_speech_prob": 2.1782216208521277e-05}, {"id": 225, "seek": 186800, "start": 1878.0, "end": 1892.0, "text": " So you're basically just grabbing a return value from a sequence of and thenable things. And then you can combine them in an expression at the end of that.", "tokens": [407, 291, 434, 1936, 445, 23771, 257, 2736, 2158, 490, 257, 8310, 295, 293, 550, 712, 721, 13, 400, 550, 291, 393, 10432, 552, 294, 364, 6114, 412, 264, 917, 295, 300, 13], "temperature": 0.0, "avg_logprob": -0.2076537691313645, "compression_ratio": 1.9388888888888889, "no_speech_prob": 2.1782216208521277e-05}, {"id": 226, "seek": 189200, "start": 1892.0, "end": 1903.0, "text": " So now it is one thing that does stick out to me is and actually you mentioned the implementation of task map five.", "tokens": [407, 586, 309, 307, 472, 551, 300, 775, 2897, 484, 281, 385, 307, 293, 767, 291, 2835, 264, 11420, 295, 5633, 4471, 1732, 13], "temperature": 0.0, "avg_logprob": -0.22426761798004605, "compression_ratio": 1.56875, "no_speech_prob": 8.480876567773521e-05}, {"id": 227, "seek": 189200, "start": 1903.0, "end": 1912.0, "text": " When I think of task map five, I actually think, well, if it's map five, wouldn't it be nice if I didn't have to end then each of them?", "tokens": [1133, 286, 519, 295, 5633, 4471, 1732, 11, 286, 767, 519, 11, 731, 11, 498, 309, 311, 4471, 1732, 11, 2759, 380, 309, 312, 1481, 498, 286, 994, 380, 362, 281, 917, 550, 1184, 295, 552, 30], "temperature": 0.0, "avg_logprob": -0.22426761798004605, "compression_ratio": 1.56875, "no_speech_prob": 8.480876567773521e-05}, {"id": 228, "seek": 191200, "start": 1912.0, "end": 1928.0, "text": " Wouldn't it be nice if I could do it applicatively? Because you think like an applicative chain, like end map, you think parallel because you can do a sequence of things and then combine them at the end.", "tokens": [26291, 380, 309, 312, 1481, 498, 286, 727, 360, 309, 2580, 19020, 30, 1436, 291, 519, 411, 364, 2580, 1166, 5021, 11, 411, 917, 4471, 11, 291, 519, 8952, 570, 291, 393, 360, 257, 8310, 295, 721, 293, 550, 10432, 552, 412, 264, 917, 13], "temperature": 0.0, "avg_logprob": -0.24113645358961455, "compression_ratio": 1.460431654676259, "no_speech_prob": 4.425424776854925e-06}, {"id": 229, "seek": 192800, "start": 1928.0, "end": 1942.0, "text": " Whereas end then you get the value and then you can continue with another value of the same type. So if you do task dot and then you need to resolve that task before you can know how to continue.", "tokens": [13813, 917, 550, 291, 483, 264, 2158, 293, 550, 291, 393, 2354, 365, 1071, 2158, 295, 264, 912, 2010, 13, 407, 498, 291, 360, 5633, 5893, 293, 550, 291, 643, 281, 14151, 300, 5633, 949, 291, 393, 458, 577, 281, 2354, 13], "temperature": 0.0, "avg_logprob": -0.2179250717163086, "compression_ratio": 1.738888888888889, "no_speech_prob": 0.00017127185128629208}, {"id": 230, "seek": 192800, "start": 1942.0, "end": 1952.0, "text": " Whereas in an applicative pipeline, you don't need that. So is that a point of controversy in do or a downside in do?", "tokens": [13813, 294, 364, 2580, 1166, 15517, 11, 291, 500, 380, 643, 300, 13, 407, 307, 300, 257, 935, 295, 22976, 294, 360, 420, 257, 25060, 294, 360, 30], "temperature": 0.0, "avg_logprob": -0.2179250717163086, "compression_ratio": 1.738888888888889, "no_speech_prob": 0.00017127185128629208}, {"id": 231, "seek": 195200, "start": 1952.0, "end": 1958.0, "text": " Yeah, that's a very good point because in Haskell, there is a language extension called applicative do.", "tokens": [865, 11, 300, 311, 257, 588, 665, 935, 570, 294, 8646, 43723, 11, 456, 307, 257, 2856, 10320, 1219, 2580, 1166, 360, 13], "temperature": 0.0, "avg_logprob": -0.2008709240985173, "compression_ratio": 1.6637554585152838, "no_speech_prob": 0.0003098878951277584}, {"id": 232, "seek": 195200, "start": 1958.0, "end": 1967.0, "text": " So just as you said, so you can use if you toggle on this extension, you can use do notation with applicatives without needing monads.", "tokens": [407, 445, 382, 291, 848, 11, 370, 291, 393, 764, 498, 291, 31225, 322, 341, 10320, 11, 291, 393, 764, 360, 24657, 365, 2580, 4884, 1553, 18006, 1108, 5834, 13], "temperature": 0.0, "avg_logprob": -0.2008709240985173, "compression_ratio": 1.6637554585152838, "no_speech_prob": 0.0003098878951277584}, {"id": 233, "seek": 195200, "start": 1967.0, "end": 1976.0, "text": " And I know lots of people when you do not need the sequencing aspect of it, like you don't need to make sure that one happens after the other.", "tokens": [400, 286, 458, 3195, 295, 561, 562, 291, 360, 406, 643, 264, 32693, 4171, 295, 309, 11, 411, 291, 500, 380, 643, 281, 652, 988, 300, 472, 2314, 934, 264, 661, 13], "temperature": 0.0, "avg_logprob": -0.2008709240985173, "compression_ratio": 1.6637554585152838, "no_speech_prob": 0.0003098878951277584}, {"id": 234, "seek": 197600, "start": 1976.0, "end": 1983.0, "text": " They will just turn on applicative do and have do blocks with just applicatives, which is also very useful.", "tokens": [814, 486, 445, 1261, 322, 2580, 1166, 360, 293, 362, 360, 8474, 365, 445, 2580, 4884, 11, 597, 307, 611, 588, 4420, 13], "temperature": 0.0, "avg_logprob": -0.24714467062878964, "compression_ratio": 1.4385964912280702, "no_speech_prob": 9.906855848385021e-05}, {"id": 235, "seek": 197600, "start": 1983.0, "end": 1986.0, "text": " Hmm, interesting. Okay.", "tokens": [8239, 11, 1880, 13, 1033, 13], "temperature": 0.0, "avg_logprob": -0.24714467062878964, "compression_ratio": 1.4385964912280702, "no_speech_prob": 9.906855848385021e-05}, {"id": 236, "seek": 197600, "start": 1986.0, "end": 1995.0, "text": " Kind of feels like a cheat, like, yes, I can't do this thing in Haskell. Well, you can just enable this extension.", "tokens": [9242, 295, 3417, 411, 257, 17470, 11, 411, 11, 2086, 11, 286, 393, 380, 360, 341, 551, 294, 8646, 43723, 13, 1042, 11, 291, 393, 445, 9528, 341, 10320, 13], "temperature": 0.0, "avg_logprob": -0.24714467062878964, "compression_ratio": 1.4385964912280702, "no_speech_prob": 9.906855848385021e-05}, {"id": 237, "seek": 199500, "start": 1995.0, "end": 2006.0, "text": " Exactly. That's totally how doing Haskell feels like you want to do all sorts of fancy or tricky type things.", "tokens": [7587, 13, 663, 311, 3879, 577, 884, 8646, 43723, 3417, 411, 291, 528, 281, 360, 439, 7527, 295, 10247, 420, 12414, 2010, 721, 13], "temperature": 0.0, "avg_logprob": -0.2110745566231864, "compression_ratio": 1.620817843866171, "no_speech_prob": 0.00013539100473280996}, {"id": 238, "seek": 199500, "start": 2006.0, "end": 2011.0, "text": " You ask somewhere around and they tell you, oh, actually, you know, you can do that with that syntax.", "tokens": [509, 1029, 4079, 926, 293, 436, 980, 291, 11, 1954, 11, 767, 11, 291, 458, 11, 291, 393, 360, 300, 365, 300, 28431, 13], "temperature": 0.0, "avg_logprob": -0.2110745566231864, "compression_ratio": 1.620817843866171, "no_speech_prob": 0.00013539100473280996}, {"id": 239, "seek": 199500, "start": 2011.0, "end": 2017.0, "text": " You think it should be doable, but you need to enable this and this language extension and then it works.", "tokens": [509, 519, 309, 820, 312, 41183, 11, 457, 291, 643, 281, 9528, 341, 293, 341, 2856, 10320, 293, 550, 309, 1985, 13], "temperature": 0.0, "avg_logprob": -0.2110745566231864, "compression_ratio": 1.620817843866171, "no_speech_prob": 0.00013539100473280996}, {"id": 240, "seek": 199500, "start": 2017.0, "end": 2019.0, "text": " It happens really often.", "tokens": [467, 2314, 534, 2049, 13], "temperature": 0.0, "avg_logprob": -0.2110745566231864, "compression_ratio": 1.620817843866171, "no_speech_prob": 0.00013539100473280996}, {"id": 241, "seek": 199500, "start": 2019.0, "end": 2024.0, "text": " Now we're back at the JavaScript babble days where everybody has their own JavaScript syntax.", "tokens": [823, 321, 434, 646, 412, 264, 15778, 7564, 638, 1708, 689, 2201, 575, 641, 1065, 15778, 28431, 13], "temperature": 0.0, "avg_logprob": -0.2110745566231864, "compression_ratio": 1.620817843866171, "no_speech_prob": 0.00013539100473280996}, {"id": 242, "seek": 202400, "start": 2024.0, "end": 2026.0, "text": " Exactly.", "tokens": [7587, 13], "temperature": 0.0, "avg_logprob": -0.2167809549967448, "compression_ratio": 1.4874371859296482, "no_speech_prob": 0.00020284812489990145}, {"id": 243, "seek": 202400, "start": 2026.0, "end": 2029.0, "text": " Well, this is actually something I was wondering about.", "tokens": [1042, 11, 341, 307, 767, 746, 286, 390, 6359, 466, 13], "temperature": 0.0, "avg_logprob": -0.2167809549967448, "compression_ratio": 1.4874371859296482, "no_speech_prob": 0.00020284812489990145}, {"id": 244, "seek": 202400, "start": 2029.0, "end": 2040.0, "text": " Is all the language extensions a problem for Haskell or is it something that introduces a lot of complexity that people try to reduce their usage of?", "tokens": [1119, 439, 264, 2856, 25129, 257, 1154, 337, 8646, 43723, 420, 307, 309, 746, 300, 31472, 257, 688, 295, 14024, 300, 561, 853, 281, 5407, 641, 14924, 295, 30], "temperature": 0.0, "avg_logprob": -0.2167809549967448, "compression_ratio": 1.4874371859296482, "no_speech_prob": 0.00020284812489990145}, {"id": 245, "seek": 202400, "start": 2040.0, "end": 2044.0, "text": " Or is it like, no, everything enable as many as you can.", "tokens": [1610, 307, 309, 411, 11, 572, 11, 1203, 9528, 382, 867, 382, 291, 393, 13], "temperature": 0.0, "avg_logprob": -0.2167809549967448, "compression_ratio": 1.4874371859296482, "no_speech_prob": 0.00020284812489990145}, {"id": 246, "seek": 202400, "start": 2044.0, "end": 2047.0, "text": " You will thank me later.", "tokens": [509, 486, 1309, 385, 1780, 13], "temperature": 0.0, "avg_logprob": -0.2167809549967448, "compression_ratio": 1.4874371859296482, "no_speech_prob": 0.00020284812489990145}, {"id": 247, "seek": 204700, "start": 2047.0, "end": 2055.0, "text": " Yeah, this is a really controversial topic because there are hundreds of extensions and some of them are widely used.", "tokens": [865, 11, 341, 307, 257, 534, 17323, 4829, 570, 456, 366, 6779, 295, 25129, 293, 512, 295, 552, 366, 13371, 1143, 13], "temperature": 0.0, "avg_logprob": -0.17259351891207408, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.00022934796288609505}, {"id": 248, "seek": 204700, "start": 2055.0, "end": 2061.0, "text": " And most Haskell developers are using the same, let's say, 30 to 40 extensions.", "tokens": [400, 881, 8646, 43723, 8849, 366, 1228, 264, 912, 11, 718, 311, 584, 11, 2217, 281, 3356, 25129, 13], "temperature": 0.0, "avg_logprob": -0.17259351891207408, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.00022934796288609505}, {"id": 249, "seek": 204700, "start": 2061.0, "end": 2072.0, "text": " So interestingly, being a JS developer, Haskell is going the JavaScript way now in the sense that they're gathering as a standard to decide on a standard per year.", "tokens": [407, 25873, 11, 885, 257, 33063, 10754, 11, 8646, 43723, 307, 516, 264, 15778, 636, 586, 294, 264, 2020, 300, 436, 434, 13519, 382, 257, 3832, 281, 4536, 322, 257, 3832, 680, 1064, 13], "temperature": 0.0, "avg_logprob": -0.17259351891207408, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.00022934796288609505}, {"id": 250, "seek": 207200, "start": 2072.0, "end": 2083.0, "text": " For example, they gathered on GHC 2021, the committee, and they came up with a language extension called default language, rather.", "tokens": [1171, 1365, 11, 436, 13032, 322, 40690, 34, 7201, 11, 264, 7482, 11, 293, 436, 1361, 493, 365, 257, 2856, 10320, 1219, 7576, 2856, 11, 2831, 13], "temperature": 0.0, "avg_logprob": -0.2524501925609151, "compression_ratio": 1.4679487179487178, "no_speech_prob": 0.0001397285668645054}, {"id": 251, "seek": 207200, "start": 2083.0, "end": 2088.0, "text": " That was GHC 2021 that enables this list of like 20 extensions.", "tokens": [663, 390, 40690, 34, 7201, 300, 17077, 341, 1329, 295, 411, 945, 25129, 13], "temperature": 0.0, "avg_logprob": -0.2524501925609151, "compression_ratio": 1.4679487179487178, "no_speech_prob": 0.0001397285668645054}, {"id": 252, "seek": 207200, "start": 2088.0, "end": 2090.0, "text": " For all files?", "tokens": [1171, 439, 7098, 30], "temperature": 0.0, "avg_logprob": -0.2524501925609151, "compression_ratio": 1.4679487179487178, "no_speech_prob": 0.0001397285668645054}, {"id": 253, "seek": 207200, "start": 2090.0, "end": 2092.0, "text": " Yes, for all files.", "tokens": [1079, 11, 337, 439, 7098, 13], "temperature": 0.0, "avg_logprob": -0.2524501925609151, "compression_ratio": 1.4679487179487178, "no_speech_prob": 0.0001397285668645054}, {"id": 254, "seek": 209200, "start": 2092.0, "end": 2104.0, "text": " And you can enable this in your cabal file, which is like your package.json file in Haskell, and then you can basically remove all these language extensions in from your comments in your files.", "tokens": [400, 291, 393, 9528, 341, 294, 428, 5487, 304, 3991, 11, 597, 307, 411, 428, 7372, 13, 73, 3015, 3991, 294, 8646, 43723, 11, 293, 550, 291, 393, 1936, 4159, 439, 613, 2856, 25129, 294, 490, 428, 3053, 294, 428, 7098, 13], "temperature": 0.0, "avg_logprob": -0.2022093709309896, "compression_ratio": 1.6548223350253808, "no_speech_prob": 0.00010867568198591471}, {"id": 255, "seek": 209200, "start": 2104.0, "end": 2113.0, "text": " Because now you're using that version of Haskell, so to speak, quote unquote, with all those language extensions enabled by default.", "tokens": [1436, 586, 291, 434, 1228, 300, 3037, 295, 8646, 43723, 11, 370, 281, 1710, 11, 6513, 37557, 11, 365, 439, 729, 2856, 25129, 15172, 538, 7576, 13], "temperature": 0.0, "avg_logprob": -0.2022093709309896, "compression_ratio": 1.6548223350253808, "no_speech_prob": 0.00010867568198591471}, {"id": 256, "seek": 211300, "start": 2113.0, "end": 2122.0, "text": " But it is an issue because it adds complexity and some of them are a bit frowned upon if you use them.", "tokens": [583, 309, 307, 364, 2734, 570, 309, 10860, 14024, 293, 512, 295, 552, 366, 257, 857, 431, 14683, 3564, 498, 291, 764, 552, 13], "temperature": 0.0, "avg_logprob": -0.24790029268007022, "compression_ratio": 1.5284090909090908, "no_speech_prob": 8.829376747598872e-05}, {"id": 257, "seek": 211300, "start": 2122.0, "end": 2130.0, "text": " Because, for example, there is one extension called allow-ambiguous-types, which sometimes is not what you want.", "tokens": [1436, 11, 337, 1365, 11, 456, 307, 472, 10320, 1219, 2089, 12, 2173, 30525, 12, 874, 5190, 11, 597, 2171, 307, 406, 437, 291, 528, 13], "temperature": 0.0, "avg_logprob": -0.24790029268007022, "compression_ratio": 1.5284090909090908, "no_speech_prob": 8.829376747598872e-05}, {"id": 258, "seek": 211300, "start": 2130.0, "end": 2132.0, "text": " It doesn't sound great.", "tokens": [467, 1177, 380, 1626, 869, 13], "temperature": 0.0, "avg_logprob": -0.24790029268007022, "compression_ratio": 1.5284090909090908, "no_speech_prob": 8.829376747598872e-05}, {"id": 259, "seek": 211300, "start": 2132.0, "end": 2134.0, "text": " Yeah, it doesn't sound great.", "tokens": [865, 11, 309, 1177, 380, 1626, 869, 13], "temperature": 0.0, "avg_logprob": -0.24790029268007022, "compression_ratio": 1.5284090909090908, "no_speech_prob": 8.829376747598872e-05}, {"id": 260, "seek": 213400, "start": 2134.0, "end": 2144.0, "text": " Just for some crazy compiler logic, people who use this, they know what they're doing, but I would not know what I was doing by enabling that extension.", "tokens": [1449, 337, 512, 3219, 31958, 9952, 11, 561, 567, 764, 341, 11, 436, 458, 437, 436, 434, 884, 11, 457, 286, 576, 406, 458, 437, 286, 390, 884, 538, 23148, 300, 10320, 13], "temperature": 0.0, "avg_logprob": -0.2475676266652233, "compression_ratio": 1.4240506329113924, "no_speech_prob": 0.0001936681364895776}, {"id": 261, "seek": 213400, "start": 2144.0, "end": 2149.0, "text": " And all these language features, is that coming from the academia world?", "tokens": [400, 439, 613, 2856, 4122, 11, 307, 300, 1348, 490, 264, 28937, 1002, 30], "temperature": 0.0, "avg_logprob": -0.2475676266652233, "compression_ratio": 1.4240506329113924, "no_speech_prob": 0.0001936681364895776}, {"id": 262, "seek": 214900, "start": 2149.0, "end": 2165.0, "text": " So, from what I understand, Haskell was developed in academia, where people were trying out a lot of things like how would the language work if we did this, if this feature was in there, and all those kinds of experiments.", "tokens": [407, 11, 490, 437, 286, 1223, 11, 8646, 43723, 390, 4743, 294, 28937, 11, 689, 561, 645, 1382, 484, 257, 688, 295, 721, 411, 577, 576, 264, 2856, 589, 498, 321, 630, 341, 11, 498, 341, 4111, 390, 294, 456, 11, 293, 439, 729, 3685, 295, 12050, 13], "temperature": 0.0, "avg_logprob": -0.22491062646624685, "compression_ratio": 1.565217391304348, "no_speech_prob": 8.100867125904188e-05}, {"id": 263, "seek": 214900, "start": 2165.0, "end": 2173.0, "text": " And so Haskell is just, by default, a language that is supposed to be extensible so that researchers can try out things.", "tokens": [400, 370, 8646, 43723, 307, 445, 11, 538, 7576, 11, 257, 2856, 300, 307, 3442, 281, 312, 1279, 30633, 370, 300, 10309, 393, 853, 484, 721, 13], "temperature": 0.0, "avg_logprob": -0.22491062646624685, "compression_ratio": 1.565217391304348, "no_speech_prob": 8.100867125904188e-05}, {"id": 264, "seek": 214900, "start": 2173.0, "end": 2175.0, "text": " Is that correct?", "tokens": [1119, 300, 3006, 30], "temperature": 0.0, "avg_logprob": -0.22491062646624685, "compression_ratio": 1.565217391304348, "no_speech_prob": 8.100867125904188e-05}, {"id": 265, "seek": 217500, "start": 2175.0, "end": 2180.0, "text": " Yeah, this is what is happening. It started in academia, but then it made its way to industry.", "tokens": [865, 11, 341, 307, 437, 307, 2737, 13, 467, 1409, 294, 28937, 11, 457, 550, 309, 1027, 1080, 636, 281, 3518, 13], "temperature": 0.0, "avg_logprob": -0.20847116358139936, "compression_ratio": 1.5959183673469388, "no_speech_prob": 0.00032685903715901077}, {"id": 266, "seek": 217500, "start": 2180.0, "end": 2187.0, "text": " And now it's a language that has a really difficult path ahead because it needs to accommodate both communities.", "tokens": [400, 586, 309, 311, 257, 2856, 300, 575, 257, 534, 2252, 3100, 2286, 570, 309, 2203, 281, 21410, 1293, 4456, 13], "temperature": 0.0, "avg_logprob": -0.20847116358139936, "compression_ratio": 1.5959183673469388, "no_speech_prob": 0.00032685903715901077}, {"id": 267, "seek": 217500, "start": 2187.0, "end": 2198.0, "text": " So it's still used in academia, for example, it's used for researching algebraic effects and dependent types and really crazy things like the next generation of programming languages.", "tokens": [407, 309, 311, 920, 1143, 294, 28937, 11, 337, 1365, 11, 309, 311, 1143, 337, 24176, 21989, 299, 5065, 293, 12334, 3467, 293, 534, 3219, 721, 411, 264, 958, 5125, 295, 9410, 8650, 13], "temperature": 0.0, "avg_logprob": -0.20847116358139936, "compression_ratio": 1.5959183673469388, "no_speech_prob": 0.00032685903715901077}, {"id": 268, "seek": 219800, "start": 2198.0, "end": 2207.0, "text": " But also there are companies like mine, like Scribe, which is using it to digitally sign contracts and it needs to work and it needs to be 100% correct.", "tokens": [583, 611, 456, 366, 3431, 411, 3892, 11, 411, 318, 8056, 11, 597, 307, 1228, 309, 281, 36938, 1465, 13952, 293, 309, 2203, 281, 589, 293, 309, 2203, 281, 312, 2319, 4, 3006, 13], "temperature": 0.0, "avg_logprob": -0.22031057105874116, "compression_ratio": 1.5411764705882354, "no_speech_prob": 0.00016778268036432564}, {"id": 269, "seek": 219800, "start": 2207.0, "end": 2212.0, "text": " So you need to accommodate both audiences in the same language.", "tokens": [407, 291, 643, 281, 21410, 1293, 15479, 294, 264, 912, 2856, 13], "temperature": 0.0, "avg_logprob": -0.22031057105874116, "compression_ratio": 1.5411764705882354, "no_speech_prob": 0.00016778268036432564}, {"id": 270, "seek": 219800, "start": 2212.0, "end": 2213.0, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.22031057105874116, "compression_ratio": 1.5411764705882354, "no_speech_prob": 0.00016778268036432564}, {"id": 271, "seek": 219800, "start": 2213.0, "end": 2216.0, "text": " But it's a nice challenge.", "tokens": [583, 309, 311, 257, 1481, 3430, 13], "temperature": 0.0, "avg_logprob": -0.22031057105874116, "compression_ratio": 1.5411764705882354, "no_speech_prob": 0.00016778268036432564}, {"id": 272, "seek": 219800, "start": 2216.0, "end": 2227.0, "text": " So we talked about the I-O monad briefly, we touched on that. Could you tell us a little bit about the role of I-O in Haskell and what that is?", "tokens": [407, 321, 2825, 466, 264, 286, 12, 46, 1108, 345, 10515, 11, 321, 9828, 322, 300, 13, 7497, 291, 980, 505, 257, 707, 857, 466, 264, 3090, 295, 286, 12, 46, 294, 8646, 43723, 293, 437, 300, 307, 30], "temperature": 0.0, "avg_logprob": -0.22031057105874116, "compression_ratio": 1.5411764705882354, "no_speech_prob": 0.00016778268036432564}, {"id": 273, "seek": 222700, "start": 2227.0, "end": 2236.0, "text": " So you mentioned that originally the Haskell language, you couldn't really do anything in the real world because it was just a pure thing.", "tokens": [407, 291, 2835, 300, 7993, 264, 8646, 43723, 2856, 11, 291, 2809, 380, 534, 360, 1340, 294, 264, 957, 1002, 570, 309, 390, 445, 257, 6075, 551, 13], "temperature": 0.0, "avg_logprob": -0.19879061525518243, "compression_ratio": 1.5585585585585586, "no_speech_prob": 1.921964212669991e-05}, {"id": 274, "seek": 222700, "start": 2236.0, "end": 2242.0, "text": " And then I-O changed that. So what does I-O introduce that lets you do things in the real world?", "tokens": [400, 550, 286, 12, 46, 3105, 300, 13, 407, 437, 775, 286, 12, 46, 5366, 300, 6653, 291, 360, 721, 294, 264, 957, 1002, 30], "temperature": 0.0, "avg_logprob": -0.19879061525518243, "compression_ratio": 1.5585585585585586, "no_speech_prob": 1.921964212669991e-05}, {"id": 275, "seek": 222700, "start": 2242.0, "end": 2250.0, "text": " Well, I-O is like a very special monad and it's used for input, output and performing side effects, basically.", "tokens": [1042, 11, 286, 12, 46, 307, 411, 257, 588, 2121, 1108, 345, 293, 309, 311, 1143, 337, 4846, 11, 5598, 293, 10205, 1252, 5065, 11, 1936, 13], "temperature": 0.0, "avg_logprob": -0.19879061525518243, "compression_ratio": 1.5585585585585586, "no_speech_prob": 1.921964212669991e-05}, {"id": 276, "seek": 225000, "start": 2250.0, "end": 2258.0, "text": " So once you use code or with the I-O monad, you know that things can go wrong.", "tokens": [407, 1564, 291, 764, 3089, 420, 365, 264, 286, 12, 46, 1108, 345, 11, 291, 458, 300, 721, 393, 352, 2085, 13], "temperature": 0.0, "avg_logprob": -0.20024738614521329, "compression_ratio": 1.4303797468354431, "no_speech_prob": 0.0005522134597413242}, {"id": 277, "seek": 225000, "start": 2258.0, "end": 2270.0, "text": " So it's like when you see the CMD part of your Elm application, it's that special hole in the language that allows you to do things that can crash.", "tokens": [407, 309, 311, 411, 562, 291, 536, 264, 20424, 35, 644, 295, 428, 2699, 76, 3861, 11, 309, 311, 300, 2121, 5458, 294, 264, 2856, 300, 4045, 291, 281, 360, 721, 300, 393, 8252, 13], "temperature": 0.0, "avg_logprob": -0.20024738614521329, "compression_ratio": 1.4303797468354431, "no_speech_prob": 0.0005522134597413242}, {"id": 278, "seek": 227000, "start": 2270.0, "end": 2283.0, "text": " And for example, people use it expecting it to be like a pure monad, but suddenly there are exceptions in Haskell and they can throw exceptions within the I-O monad.", "tokens": [400, 337, 1365, 11, 561, 764, 309, 9650, 309, 281, 312, 411, 257, 6075, 1108, 345, 11, 457, 5800, 456, 366, 22847, 294, 8646, 43723, 293, 436, 393, 3507, 22847, 1951, 264, 286, 12, 46, 1108, 345, 13], "temperature": 0.0, "avg_logprob": -0.17203795909881592, "compression_ratio": 1.6756756756756757, "no_speech_prob": 0.00016171704919543117}, {"id": 279, "seek": 227000, "start": 2283.0, "end": 2291.0, "text": " And people do not expect a language to be able to throw exceptions. But as soon as you are in the I-O monad realm, many, many things can happen.", "tokens": [400, 561, 360, 406, 2066, 257, 2856, 281, 312, 1075, 281, 3507, 22847, 13, 583, 382, 2321, 382, 291, 366, 294, 264, 286, 12, 46, 1108, 345, 15355, 11, 867, 11, 867, 721, 393, 1051, 13], "temperature": 0.0, "avg_logprob": -0.17203795909881592, "compression_ratio": 1.6756756756756757, "no_speech_prob": 0.00016171704919543117}, {"id": 280, "seek": 229100, "start": 2291.0, "end": 2301.0, "text": " So it's interesting. It allows you on one side, you cannot do a program that does stuff without input output. So you need to eventually use the I-O monad.", "tokens": [407, 309, 311, 1880, 13, 467, 4045, 291, 322, 472, 1252, 11, 291, 2644, 360, 257, 1461, 300, 775, 1507, 1553, 4846, 5598, 13, 407, 291, 643, 281, 4728, 764, 264, 286, 12, 46, 1108, 345, 13], "temperature": 0.0, "avg_logprob": -0.18438607227953174, "compression_ratio": 1.5592417061611374, "no_speech_prob": 8.329298725584522e-05}, {"id": 281, "seek": 229100, "start": 2301.0, "end": 2311.0, "text": " But as soon as you start doing things with it, you know that you need to be extra careful because that's where the whole realm of side effects and unwanted things can happen.", "tokens": [583, 382, 2321, 382, 291, 722, 884, 721, 365, 309, 11, 291, 458, 300, 291, 643, 281, 312, 2857, 5026, 570, 300, 311, 689, 264, 1379, 15355, 295, 1252, 5065, 293, 33745, 721, 393, 1051, 13], "temperature": 0.0, "avg_logprob": -0.18438607227953174, "compression_ratio": 1.5592417061611374, "no_speech_prob": 8.329298725584522e-05}, {"id": 282, "seek": 231100, "start": 2311.0, "end": 2324.0, "text": " Right, right. Yeah. So there's this kind of advice with all of these things, whether you're using the terms of monads and functors or not, just using an Elm application.", "tokens": [1779, 11, 558, 13, 865, 13, 407, 456, 311, 341, 733, 295, 5192, 365, 439, 295, 613, 721, 11, 1968, 291, 434, 1228, 264, 2115, 295, 1108, 5834, 293, 1019, 5547, 420, 406, 11, 445, 1228, 364, 2699, 76, 3861, 13], "temperature": 0.0, "avg_logprob": -0.18738761948950497, "compression_ratio": 1.6037735849056605, "no_speech_prob": 3.3722506486810744e-05}, {"id": 283, "seek": 231100, "start": 2324.0, "end": 2335.0, "text": " There's this advice to do as much work as you can in the land of simple functions that don't know about these complicated things because that's where failures can happen.", "tokens": [821, 311, 341, 5192, 281, 360, 382, 709, 589, 382, 291, 393, 294, 264, 2117, 295, 2199, 6828, 300, 500, 380, 458, 466, 613, 6179, 721, 570, 300, 311, 689, 20774, 393, 1051, 13], "temperature": 0.0, "avg_logprob": -0.18738761948950497, "compression_ratio": 1.6037735849056605, "no_speech_prob": 3.3722506486810744e-05}, {"id": 284, "seek": 233500, "start": 2335.0, "end": 2349.0, "text": " I mean, really, it's the same idea as we talked about in a previous episode about Richard's talk, Scaling Elm Applications, the general idea that the more guarantees you can have about a function, the better.", "tokens": [286, 914, 11, 534, 11, 309, 311, 264, 912, 1558, 382, 321, 2825, 466, 294, 257, 3894, 3500, 466, 9809, 311, 751, 11, 2747, 4270, 2699, 76, 26519, 763, 11, 264, 2674, 1558, 300, 264, 544, 32567, 291, 393, 362, 466, 257, 2445, 11, 264, 1101, 13], "temperature": 0.0, "avg_logprob": -0.2018850160681683, "compression_ratio": 1.7207207207207207, "no_speech_prob": 3.8827893149573356e-05}, {"id": 285, "seek": 233500, "start": 2349.0, "end": 2359.0, "text": " So like the less things that something can return, the more narrowly scoped, the more narrowly scoped the inputs, the less your brain has to worry about what could go wrong.", "tokens": [407, 411, 264, 1570, 721, 300, 746, 393, 2736, 11, 264, 544, 9432, 356, 795, 27277, 11, 264, 544, 9432, 356, 795, 27277, 264, 15743, 11, 264, 1570, 428, 3567, 575, 281, 3292, 466, 437, 727, 352, 2085, 13], "temperature": 0.0, "avg_logprob": -0.2018850160681683, "compression_ratio": 1.7207207207207207, "no_speech_prob": 3.8827893149573356e-05}, {"id": 286, "seek": 235900, "start": 2359.0, "end": 2365.0, "text": " But I-O, it can do anything, including catastrophically failing.", "tokens": [583, 286, 12, 46, 11, 309, 393, 360, 1340, 11, 3009, 28363, 984, 18223, 13], "temperature": 0.0, "avg_logprob": -0.20156232366022073, "compression_ratio": 1.5875912408759123, "no_speech_prob": 3.5355769796296954e-05}, {"id": 287, "seek": 235900, "start": 2365.0, "end": 2366.0, "text": " Exactly.", "tokens": [7587, 13], "temperature": 0.0, "avg_logprob": -0.20156232366022073, "compression_ratio": 1.5875912408759123, "no_speech_prob": 3.5355769796296954e-05}, {"id": 288, "seek": 235900, "start": 2366.0, "end": 2380.0, "text": " Yeah, so you use it with care. But now when you say exceptions, do you mean, of course, the first thing many people will think with exceptions would be something like a JavaScript exception where it's a control flow mechanism.", "tokens": [865, 11, 370, 291, 764, 309, 365, 1127, 13, 583, 586, 562, 291, 584, 22847, 11, 360, 291, 914, 11, 295, 1164, 11, 264, 700, 551, 867, 561, 486, 519, 365, 22847, 576, 312, 746, 411, 257, 15778, 11183, 689, 309, 311, 257, 1969, 3095, 7513, 13], "temperature": 0.0, "avg_logprob": -0.20156232366022073, "compression_ratio": 1.5875912408759123, "no_speech_prob": 3.5355769796296954e-05}, {"id": 289, "seek": 235900, "start": 2380.0, "end": 2388.0, "text": " It changes the way the language works. You can throw and you can catch. What does an exception mean in the context of Haskell and I-O?", "tokens": [467, 2962, 264, 636, 264, 2856, 1985, 13, 509, 393, 3507, 293, 291, 393, 3745, 13, 708, 775, 364, 11183, 914, 294, 264, 4319, 295, 8646, 43723, 293, 286, 12, 46, 30], "temperature": 0.0, "avg_logprob": -0.20156232366022073, "compression_ratio": 1.5875912408759123, "no_speech_prob": 3.5355769796296954e-05}, {"id": 290, "seek": 238800, "start": 2388.0, "end": 2396.0, "text": " Yes, it means exactly the same. So you have the control flow of your application. You can deliberately throw and catch exceptions.", "tokens": [1079, 11, 309, 1355, 2293, 264, 912, 13, 407, 291, 362, 264, 1969, 3095, 295, 428, 3861, 13, 509, 393, 23506, 3507, 293, 3745, 22847, 13], "temperature": 0.0, "avg_logprob": -0.20255794525146484, "compression_ratio": 1.5974025974025974, "no_speech_prob": 0.00046486040810123086}, {"id": 291, "seek": 238800, "start": 2396.0, "end": 2406.0, "text": " But for example, because of Haskell's legacy, for example, the list.head function is partial, meaning it's not as in Elm that it returns a maybe.", "tokens": [583, 337, 1365, 11, 570, 295, 8646, 43723, 311, 11711, 11, 337, 1365, 11, 264, 1329, 13, 1934, 2445, 307, 14641, 11, 3620, 309, 311, 406, 382, 294, 2699, 76, 300, 309, 11247, 257, 1310, 13], "temperature": 0.0, "avg_logprob": -0.20255794525146484, "compression_ratio": 1.5974025974025974, "no_speech_prob": 0.00046486040810123086}, {"id": 292, "seek": 238800, "start": 2406.0, "end": 2411.0, "text": " If you accidentally called head on an empty list, it will throw an exception. It will crash.", "tokens": [759, 291, 15715, 1219, 1378, 322, 364, 6707, 1329, 11, 309, 486, 3507, 364, 11183, 13, 467, 486, 8252, 13], "temperature": 0.0, "avg_logprob": -0.20255794525146484, "compression_ratio": 1.5974025974025974, "no_speech_prob": 0.00046486040810123086}, {"id": 293, "seek": 241100, "start": 2411.0, "end": 2421.0, "text": " So this is an issue. And Haskell has in the prelude a few partial functions that will crash if you're not careful.", "tokens": [407, 341, 307, 364, 2734, 13, 400, 8646, 43723, 575, 294, 264, 659, 32334, 257, 1326, 14641, 6828, 300, 486, 8252, 498, 291, 434, 406, 5026, 13], "temperature": 0.0, "avg_logprob": -0.2175572156906128, "compression_ratio": 1.527363184079602, "no_speech_prob": 0.0004569432057905942}, {"id": 294, "seek": 241100, "start": 2421.0, "end": 2432.0, "text": " And that's why people also created new preludes, standard preludes that don't have these issues that provide you, for example, with a non-empty list, a data type and all sorts of useful stuff.", "tokens": [400, 300, 311, 983, 561, 611, 2942, 777, 659, 1471, 279, 11, 3832, 659, 1471, 279, 300, 500, 380, 362, 613, 2663, 300, 2893, 291, 11, 337, 1365, 11, 365, 257, 2107, 12, 4543, 88, 1329, 11, 257, 1412, 2010, 293, 439, 7527, 295, 4420, 1507, 13], "temperature": 0.0, "avg_logprob": -0.2175572156906128, "compression_ratio": 1.527363184079602, "no_speech_prob": 0.0004569432057905942}, {"id": 295, "seek": 243200, "start": 2432.0, "end": 2441.0, "text": " But yeah, if you come to the language thinking about, oh, this is everything going to be pure and perfect, then you're up for a surprise.", "tokens": [583, 1338, 11, 498, 291, 808, 281, 264, 2856, 1953, 466, 11, 1954, 11, 341, 307, 1203, 516, 281, 312, 6075, 293, 2176, 11, 550, 291, 434, 493, 337, 257, 6365, 13], "temperature": 0.0, "avg_logprob": -0.21501695192777193, "compression_ratio": 1.4076086956521738, "no_speech_prob": 0.00027160794707015157}, {"id": 296, "seek": 243200, "start": 2441.0, "end": 2448.0, "text": " Right. I mean, Haskell is the other pure language, right?", "tokens": [1779, 13, 286, 914, 11, 8646, 43723, 307, 264, 661, 6075, 2856, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.21501695192777193, "compression_ratio": 1.4076086956521738, "no_speech_prob": 0.00027160794707015157}, {"id": 297, "seek": 243200, "start": 2448.0, "end": 2449.0, "text": " Exactly.", "tokens": [7587, 13], "temperature": 0.0, "avg_logprob": -0.21501695192777193, "compression_ratio": 1.4076086956521738, "no_speech_prob": 0.00027160794707015157}, {"id": 298, "seek": 243200, "start": 2449.0, "end": 2453.0, "text": " And then you don't know. No, it's not that pure.", "tokens": [400, 550, 291, 500, 380, 458, 13, 883, 11, 309, 311, 406, 300, 6075, 13], "temperature": 0.0, "avg_logprob": -0.21501695192777193, "compression_ratio": 1.4076086956521738, "no_speech_prob": 0.00027160794707015157}, {"id": 299, "seek": 243200, "start": 2453.0, "end": 2454.0, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.21501695192777193, "compression_ratio": 1.4076086956521738, "no_speech_prob": 0.00027160794707015157}, {"id": 300, "seek": 245400, "start": 2454.0, "end": 2464.0, "text": " And I guess PureScript is also somewhere in that realm, but I don't know how it works. I know even less of PureScript compared to Haskell.", "tokens": [400, 286, 2041, 29474, 14237, 307, 611, 4079, 294, 300, 15355, 11, 457, 286, 500, 380, 458, 577, 309, 1985, 13, 286, 458, 754, 1570, 295, 29474, 14237, 5347, 281, 8646, 43723, 13], "temperature": 0.0, "avg_logprob": -0.22846163535604672, "compression_ratio": 1.6205357142857142, "no_speech_prob": 4.465493475436233e-05}, {"id": 301, "seek": 245400, "start": 2464.0, "end": 2475.0, "text": " Yeah, I know very little about PureScript as well. But interestingly, one thing I like, which is quite mind boggling about Haskell compared to Elm, is that Elm is eager and Haskell is lazy.", "tokens": [865, 11, 286, 458, 588, 707, 466, 29474, 14237, 382, 731, 13, 583, 25873, 11, 472, 551, 286, 411, 11, 597, 307, 1596, 1575, 26132, 70, 1688, 466, 8646, 43723, 5347, 281, 2699, 76, 11, 307, 300, 2699, 76, 307, 18259, 293, 8646, 43723, 307, 14847, 13], "temperature": 0.0, "avg_logprob": -0.22846163535604672, "compression_ratio": 1.6205357142857142, "no_speech_prob": 4.465493475436233e-05}, {"id": 302, "seek": 245400, "start": 2475.0, "end": 2478.0, "text": " Ah, I was going to ask about that.", "tokens": [2438, 11, 286, 390, 516, 281, 1029, 466, 300, 13], "temperature": 0.0, "avg_logprob": -0.22846163535604672, "compression_ratio": 1.6205357142857142, "no_speech_prob": 4.465493475436233e-05}, {"id": 303, "seek": 247800, "start": 2478.0, "end": 2488.0, "text": " So I think it's the only lazy functional programming language that is actually used and it's not useless, you know.", "tokens": [407, 286, 519, 309, 311, 264, 787, 14847, 11745, 9410, 2856, 300, 307, 767, 1143, 293, 309, 311, 406, 14115, 11, 291, 458, 13], "temperature": 0.0, "avg_logprob": -0.2211591601371765, "compression_ratio": 1.5887096774193548, "no_speech_prob": 0.0008375580073334277}, {"id": 304, "seek": 247800, "start": 2488.0, "end": 2499.0, "text": " But the whole concept of it being lazy and having different algorithms for benefiting from this laziness, it's very mind boggling as well, very surprising to me.", "tokens": [583, 264, 1379, 3410, 295, 309, 885, 14847, 293, 1419, 819, 14642, 337, 47515, 490, 341, 19320, 1324, 11, 309, 311, 588, 1575, 26132, 70, 1688, 382, 731, 11, 588, 8830, 281, 385, 13], "temperature": 0.0, "avg_logprob": -0.2211591601371765, "compression_ratio": 1.5887096774193548, "no_speech_prob": 0.0008375580073334277}, {"id": 305, "seek": 247800, "start": 2499.0, "end": 2507.0, "text": " Okay. Can you explain what lazy is and what eager is as well? And yeah, what can you do with it or why is it useful?", "tokens": [1033, 13, 1664, 291, 2903, 437, 14847, 307, 293, 437, 18259, 307, 382, 731, 30, 400, 1338, 11, 437, 393, 291, 360, 365, 309, 420, 983, 307, 309, 4420, 30], "temperature": 0.0, "avg_logprob": -0.2211591601371765, "compression_ratio": 1.5887096774193548, "no_speech_prob": 0.0008375580073334277}, {"id": 306, "seek": 250700, "start": 2507.0, "end": 2512.0, "text": " Wow, it's a very philosophical question and hard to explain, but I will do my best.", "tokens": [3153, 11, 309, 311, 257, 588, 25066, 1168, 293, 1152, 281, 2903, 11, 457, 286, 486, 360, 452, 1151, 13], "temperature": 0.0, "avg_logprob": -0.1703637658733211, "compression_ratio": 1.5515463917525774, "no_speech_prob": 0.0007508450653403997}, {"id": 307, "seek": 250700, "start": 2512.0, "end": 2519.0, "text": " So basically in Haskell, you can define functions that are recursive.", "tokens": [407, 1936, 294, 8646, 43723, 11, 291, 393, 6964, 6828, 300, 366, 20560, 488, 13], "temperature": 0.0, "avg_logprob": -0.1703637658733211, "compression_ratio": 1.5515463917525774, "no_speech_prob": 0.0007508450653403997}, {"id": 308, "seek": 250700, "start": 2519.0, "end": 2529.0, "text": " For example, you can define recursively the Fibonacci sequence and you can define things that should not compile because they depend on each other.", "tokens": [1171, 1365, 11, 291, 393, 6964, 20560, 3413, 264, 479, 897, 266, 43870, 8310, 293, 291, 393, 6964, 721, 300, 820, 406, 31413, 570, 436, 5672, 322, 1184, 661, 13], "temperature": 0.0, "avg_logprob": -0.1703637658733211, "compression_ratio": 1.5515463917525774, "no_speech_prob": 0.0007508450653403997}, {"id": 309, "seek": 252900, "start": 2529.0, "end": 2539.0, "text": " If the compiler tries to parse all of that, it should absolutely crash, but it's lazy in the sense that it doesn't compute things until you willingly request it to do so.", "tokens": [759, 264, 31958, 9898, 281, 48377, 439, 295, 300, 11, 309, 820, 3122, 8252, 11, 457, 309, 311, 14847, 294, 264, 2020, 300, 309, 1177, 380, 14722, 721, 1826, 291, 44675, 5308, 309, 281, 360, 370, 13], "temperature": 0.0, "avg_logprob": -0.19254046992251747, "compression_ratio": 1.6836363636363636, "no_speech_prob": 0.0003345704753883183}, {"id": 310, "seek": 252900, "start": 2539.0, "end": 2548.0, "text": " So Elm chose to be eager for some reason, because I think technically for HTML on the front end was needed, but Haskell is not.", "tokens": [407, 2699, 76, 5111, 281, 312, 18259, 337, 512, 1778, 11, 570, 286, 519, 12120, 337, 17995, 322, 264, 1868, 917, 390, 2978, 11, 457, 8646, 43723, 307, 406, 13], "temperature": 0.0, "avg_logprob": -0.19254046992251747, "compression_ratio": 1.6836363636363636, "no_speech_prob": 0.0003345704753883183}, {"id": 311, "seek": 252900, "start": 2548.0, "end": 2558.0, "text": " So for example, you define your lazy Fibonacci sequence and you say, take five on this Fibonacci sequence and you're making it just to compute up until number five.", "tokens": [407, 337, 1365, 11, 291, 6964, 428, 14847, 479, 897, 266, 43870, 8310, 293, 291, 584, 11, 747, 1732, 322, 341, 479, 897, 266, 43870, 8310, 293, 291, 434, 1455, 309, 445, 281, 14722, 493, 1826, 1230, 1732, 13], "temperature": 0.0, "avg_logprob": -0.19254046992251747, "compression_ratio": 1.6836363636363636, "no_speech_prob": 0.0003345704753883183}, {"id": 312, "seek": 255800, "start": 2558.0, "end": 2564.0, "text": " It will not compute the rest, it will not crash or it will not recurse infinity until infinity.", "tokens": [467, 486, 406, 14722, 264, 1472, 11, 309, 486, 406, 8252, 420, 309, 486, 406, 18680, 405, 13202, 1826, 13202, 13], "temperature": 0.0, "avg_logprob": -0.2723092351640974, "compression_ratio": 1.5466666666666666, "no_speech_prob": 0.0001764492626534775}, {"id": 313, "seek": 255800, "start": 2564.0, "end": 2575.0, "text": " So, yeah, from what I understand is you can create infinite lists, like all the integers, for instance, which is impossible in practice.", "tokens": [407, 11, 1338, 11, 490, 437, 286, 1223, 307, 291, 393, 1884, 13785, 14511, 11, 411, 439, 264, 41674, 11, 337, 5197, 11, 597, 307, 6243, 294, 3124, 13], "temperature": 0.0, "avg_logprob": -0.2723092351640974, "compression_ratio": 1.5466666666666666, "no_speech_prob": 0.0001764492626534775}, {"id": 314, "seek": 257500, "start": 2575.0, "end": 2589.0, "text": " But because those are actually not computed eagerly, you can do computations on it and just hope that you're not reaching out to infinity because then you have a problem.", "tokens": [583, 570, 729, 366, 767, 406, 40610, 18259, 356, 11, 291, 393, 360, 2807, 763, 322, 309, 293, 445, 1454, 300, 291, 434, 406, 9906, 484, 281, 13202, 570, 550, 291, 362, 257, 1154, 13], "temperature": 0.0, "avg_logprob": -0.2732076168060303, "compression_ratio": 1.5330188679245282, "no_speech_prob": 3.424005626584403e-05}, {"id": 315, "seek": 257500, "start": 2589.0, "end": 2594.0, "text": " And I'm guessing there's some performance overhead with that as well.", "tokens": [400, 286, 478, 17939, 456, 311, 512, 3389, 19922, 365, 300, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.2732076168060303, "compression_ratio": 1.5330188679245282, "no_speech_prob": 3.424005626584403e-05}, {"id": 316, "seek": 257500, "start": 2594.0, "end": 2600.0, "text": " Yes, like there are some functions that, for example, there is foldAl, l, and foldR.", "tokens": [1079, 11, 411, 456, 366, 512, 6828, 300, 11, 337, 1365, 11, 456, 307, 4860, 9171, 11, 287, 11, 293, 4860, 49, 13], "temperature": 0.0, "avg_logprob": -0.2732076168060303, "compression_ratio": 1.5330188679245282, "no_speech_prob": 3.424005626584403e-05}, {"id": 317, "seek": 260000, "start": 2600.0, "end": 2605.0, "text": " So depending on whether you want to fold from left or right.", "tokens": [407, 5413, 322, 1968, 291, 528, 281, 4860, 490, 1411, 420, 558, 13], "temperature": 0.0, "avg_logprob": -0.1893627585434332, "compression_ratio": 1.553921568627451, "no_speech_prob": 0.0003077138098888099}, {"id": 318, "seek": 260000, "start": 2605.0, "end": 2616.0, "text": " And in Haskell, foldAl is known to have a performance impact because it being lazy, what it will do is just create thunks and thunks and thunks of code.", "tokens": [400, 294, 8646, 43723, 11, 4860, 9171, 307, 2570, 281, 362, 257, 3389, 2712, 570, 309, 885, 14847, 11, 437, 309, 486, 360, 307, 445, 1884, 258, 17627, 293, 258, 17627, 293, 258, 17627, 295, 3089, 13], "temperature": 0.0, "avg_logprob": -0.1893627585434332, "compression_ratio": 1.553921568627451, "no_speech_prob": 0.0003077138098888099}, {"id": 319, "seek": 260000, "start": 2616.0, "end": 2626.0, "text": " And because it doesn't eagerly evaluate them until it's at the end, it can cause very huge space leaks.", "tokens": [400, 570, 309, 1177, 380, 18259, 356, 13059, 552, 1826, 309, 311, 412, 264, 917, 11, 309, 393, 3082, 588, 2603, 1901, 28885, 13], "temperature": 0.0, "avg_logprob": -0.1893627585434332, "compression_ratio": 1.553921568627451, "no_speech_prob": 0.0003077138098888099}, {"id": 320, "seek": 262600, "start": 2626.0, "end": 2633.0, "text": " Yes, so a thunk is a delayed computation in a function, right?", "tokens": [1079, 11, 370, 257, 258, 3197, 307, 257, 20268, 24903, 294, 257, 2445, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.20115399828144148, "compression_ratio": 1.55, "no_speech_prob": 4.3923137127421796e-05}, {"id": 321, "seek": 262600, "start": 2633.0, "end": 2634.0, "text": " Yes.", "tokens": [1079, 13], "temperature": 0.0, "avg_logprob": -0.20115399828144148, "compression_ratio": 1.55, "no_speech_prob": 4.3923137127421796e-05}, {"id": 322, "seek": 262600, "start": 2634.0, "end": 2639.0, "text": " And presumably it would be a closure, meaning it carries context with it.", "tokens": [400, 26742, 309, 576, 312, 257, 24653, 11, 3620, 309, 16402, 4319, 365, 309, 13], "temperature": 0.0, "avg_logprob": -0.20115399828144148, "compression_ratio": 1.55, "no_speech_prob": 4.3923137127421796e-05}, {"id": 323, "seek": 262600, "start": 2639.0, "end": 2642.0, "text": " So it prevents those things from being released in memory.", "tokens": [407, 309, 22367, 729, 721, 490, 885, 4736, 294, 4675, 13], "temperature": 0.0, "avg_logprob": -0.20115399828144148, "compression_ratio": 1.55, "no_speech_prob": 4.3923137127421796e-05}, {"id": 324, "seek": 262600, "start": 2642.0, "end": 2645.0, "text": " So there are performance implications to that.", "tokens": [407, 456, 366, 3389, 16602, 281, 300, 13], "temperature": 0.0, "avg_logprob": -0.20115399828144148, "compression_ratio": 1.55, "no_speech_prob": 4.3923137127421796e-05}, {"id": 325, "seek": 262600, "start": 2645.0, "end": 2654.0, "text": " Yes, so that's why by default Haskellers tend to use more foldR, surprisingly, when they're just folding lists and they don't care about the associativity.", "tokens": [1079, 11, 370, 300, 311, 983, 538, 7576, 8646, 43723, 433, 3928, 281, 764, 544, 4860, 49, 11, 17600, 11, 562, 436, 434, 445, 25335, 14511, 293, 436, 500, 380, 1127, 466, 264, 4180, 30142, 13], "temperature": 0.0, "avg_logprob": -0.20115399828144148, "compression_ratio": 1.55, "no_speech_prob": 4.3923137127421796e-05}, {"id": 326, "seek": 265400, "start": 2654.0, "end": 2662.0, "text": " But also there are versions of the function which are called very weirdly foldL', which won't cause a space leak.", "tokens": [583, 611, 456, 366, 9606, 295, 264, 2445, 597, 366, 1219, 588, 48931, 4860, 43, 6098, 597, 1582, 380, 3082, 257, 1901, 17143, 13], "temperature": 0.0, "avg_logprob": -0.25708658854166666, "compression_ratio": 1.5346534653465347, "no_speech_prob": 6.597070023417473e-05}, {"id": 327, "seek": 265400, "start": 2662.0, "end": 2667.0, "text": " So they're very bad at naming things.", "tokens": [407, 436, 434, 588, 1578, 412, 25290, 721, 13], "temperature": 0.0, "avg_logprob": -0.25708658854166666, "compression_ratio": 1.5346534653465347, "no_speech_prob": 6.597070023417473e-05}, {"id": 328, "seek": 265400, "start": 2667.0, "end": 2668.0, "text": " Interesting.", "tokens": [14711, 13], "temperature": 0.0, "avg_logprob": -0.25708658854166666, "compression_ratio": 1.5346534653465347, "no_speech_prob": 6.597070023417473e-05}, {"id": 329, "seek": 265400, "start": 2668.0, "end": 2679.0, "text": " I'm kind of confused because you say like people tend to not like the list at foldL because that creates all those thunks and performance issues.", "tokens": [286, 478, 733, 295, 9019, 570, 291, 584, 411, 561, 3928, 281, 406, 411, 264, 1329, 412, 4860, 43, 570, 300, 7829, 439, 729, 258, 17627, 293, 3389, 2663, 13], "temperature": 0.0, "avg_logprob": -0.25708658854166666, "compression_ratio": 1.5346534653465347, "no_speech_prob": 6.597070023417473e-05}, {"id": 330, "seek": 267900, "start": 2679.0, "end": 2689.0, "text": " So they prefer foldR. But if you do that on an infinite list, then are you trying to get to infinity before you get to number one?", "tokens": [407, 436, 4382, 4860, 49, 13, 583, 498, 291, 360, 300, 322, 364, 13785, 1329, 11, 550, 366, 291, 1382, 281, 483, 281, 13202, 949, 291, 483, 281, 1230, 472, 30], "temperature": 0.0, "avg_logprob": -0.2157388020710773, "compression_ratio": 1.6149732620320856, "no_speech_prob": 5.5327127483906224e-05}, {"id": 331, "seek": 267900, "start": 2689.0, "end": 2690.0, "text": " Right.", "tokens": [1779, 13], "temperature": 0.0, "avg_logprob": -0.2157388020710773, "compression_ratio": 1.6149732620320856, "no_speech_prob": 5.5327127483906224e-05}, {"id": 332, "seek": 267900, "start": 2690.0, "end": 2694.0, "text": " Or is it just like people won't do that in that case?", "tokens": [1610, 307, 309, 445, 411, 561, 1582, 380, 360, 300, 294, 300, 1389, 30], "temperature": 0.0, "avg_logprob": -0.2157388020710773, "compression_ratio": 1.6149732620320856, "no_speech_prob": 5.5327127483906224e-05}, {"id": 333, "seek": 267900, "start": 2694.0, "end": 2700.0, "text": " Yeah, obviously, folding R on infinity will not work.", "tokens": [865, 11, 2745, 11, 25335, 497, 322, 13202, 486, 406, 589, 13], "temperature": 0.0, "avg_logprob": -0.2157388020710773, "compression_ratio": 1.6149732620320856, "no_speech_prob": 5.5327127483906224e-05}, {"id": 334, "seek": 267900, "start": 2700.0, "end": 2705.0, "text": " But for finite lists of things, it definitely will work.", "tokens": [583, 337, 19362, 14511, 295, 721, 11, 309, 2138, 486, 589, 13], "temperature": 0.0, "avg_logprob": -0.2157388020710773, "compression_ratio": 1.6149732620320856, "no_speech_prob": 5.5327127483906224e-05}, {"id": 335, "seek": 270500, "start": 2705.0, "end": 2711.0, "text": " But if you see the explanation, for example, there's a blog post from Lexi Lambda, which is really great.", "tokens": [583, 498, 291, 536, 264, 10835, 11, 337, 1365, 11, 456, 311, 257, 6968, 2183, 490, 24086, 72, 45691, 11, 597, 307, 534, 869, 13], "temperature": 0.0, "avg_logprob": -0.1805053304453365, "compression_ratio": 1.6245614035087719, "no_speech_prob": 0.00036988253123126924}, {"id": 336, "seek": 270500, "start": 2711.0, "end": 2717.0, "text": " She was explaining why foldL is so dangerous to a colleague and it ended up being like a full blog post.", "tokens": [1240, 390, 13468, 983, 4860, 43, 307, 370, 5795, 281, 257, 13532, 293, 309, 4590, 493, 885, 411, 257, 1577, 6968, 2183, 13], "temperature": 0.0, "avg_logprob": -0.1805053304453365, "compression_ratio": 1.6245614035087719, "no_speech_prob": 0.00036988253123126924}, {"id": 337, "seek": 270500, "start": 2717.0, "end": 2725.0, "text": " And it's so interesting the way this laziness thing enables this to happen and why Haskell is the way it is.", "tokens": [400, 309, 311, 370, 1880, 264, 636, 341, 19320, 1324, 551, 17077, 341, 281, 1051, 293, 983, 8646, 43723, 307, 264, 636, 309, 307, 13], "temperature": 0.0, "avg_logprob": -0.1805053304453365, "compression_ratio": 1.6245614035087719, "no_speech_prob": 0.00036988253123126924}, {"id": 338, "seek": 270500, "start": 2725.0, "end": 2729.0, "text": " So I will probably send you a link afterwards so that you can have a look at it.", "tokens": [407, 286, 486, 1391, 2845, 291, 257, 2113, 10543, 370, 300, 291, 393, 362, 257, 574, 412, 309, 13], "temperature": 0.0, "avg_logprob": -0.1805053304453365, "compression_ratio": 1.6245614035087719, "no_speech_prob": 0.00036988253123126924}, {"id": 339, "seek": 270500, "start": 2729.0, "end": 2731.0, "text": " It's really interesting.", "tokens": [467, 311, 534, 1880, 13], "temperature": 0.0, "avg_logprob": -0.1805053304453365, "compression_ratio": 1.6245614035087719, "no_speech_prob": 0.00036988253123126924}, {"id": 340, "seek": 270500, "start": 2731.0, "end": 2733.0, "text": " Yeah, we'll put it in the show notes.", "tokens": [865, 11, 321, 603, 829, 309, 294, 264, 855, 5570, 13], "temperature": 0.0, "avg_logprob": -0.1805053304453365, "compression_ratio": 1.6245614035087719, "no_speech_prob": 0.00036988253123126924}, {"id": 341, "seek": 273300, "start": 2733.0, "end": 2744.0, "text": " So what are other pitfalls that you can have with laziness and also maybe like cool things that you can do that we can't benefit from in Elm?", "tokens": [407, 437, 366, 661, 10147, 18542, 300, 291, 393, 362, 365, 19320, 1324, 293, 611, 1310, 411, 1627, 721, 300, 291, 393, 360, 300, 321, 393, 380, 5121, 490, 294, 2699, 76, 30], "temperature": 0.0, "avg_logprob": -0.20922336330661526, "compression_ratio": 1.7053140096618358, "no_speech_prob": 3.640742943389341e-05}, {"id": 342, "seek": 273300, "start": 2744.0, "end": 2758.0, "text": " So from my experience, for example, when you are learning algorithms and you see like the mathematical implementation of an algorithm that deals with infinite lists, for example, or infinite sequences of things.", "tokens": [407, 490, 452, 1752, 11, 337, 1365, 11, 562, 291, 366, 2539, 14642, 293, 291, 536, 411, 264, 18894, 11420, 295, 364, 9284, 300, 11215, 365, 13785, 14511, 11, 337, 1365, 11, 420, 13785, 22978, 295, 721, 13], "temperature": 0.0, "avg_logprob": -0.20922336330661526, "compression_ratio": 1.7053140096618358, "no_speech_prob": 3.640742943389341e-05}, {"id": 343, "seek": 275800, "start": 2758.0, "end": 2767.0, "text": " If you see the equations, you can pretty much translate those straight from math notation into Haskell and it will work, which is amazing.", "tokens": [759, 291, 536, 264, 11787, 11, 291, 393, 1238, 709, 13799, 729, 2997, 490, 5221, 24657, 666, 8646, 43723, 293, 309, 486, 589, 11, 597, 307, 2243, 13], "temperature": 0.0, "avg_logprob": -0.19387578252536147, "compression_ratio": 1.4759358288770053, "no_speech_prob": 0.00024357919755857438}, {"id": 344, "seek": 275800, "start": 2767.0, "end": 2770.0, "text": " But it's not really doable in many other languages.", "tokens": [583, 309, 311, 406, 534, 41183, 294, 867, 661, 8650, 13], "temperature": 0.0, "avg_logprob": -0.19387578252536147, "compression_ratio": 1.4759358288770053, "no_speech_prob": 0.00024357919755857438}, {"id": 345, "seek": 275800, "start": 2770.0, "end": 2778.0, "text": " But yeah, I think the huge or the main con against laziness is the space leaks thing.", "tokens": [583, 1338, 11, 286, 519, 264, 2603, 420, 264, 2135, 416, 1970, 19320, 1324, 307, 264, 1901, 28885, 551, 13], "temperature": 0.0, "avg_logprob": -0.19387578252536147, "compression_ratio": 1.4759358288770053, "no_speech_prob": 0.00024357919755857438}, {"id": 346, "seek": 277800, "start": 2778.0, "end": 2796.0, "text": " But it enables all sorts of also different way of thinking about algorithms that are only like it's a specialized case for lazy languages that they need to think in a different algorithms to solve the same problems that we that we're used to solving with eager algorithms, interestingly.", "tokens": [583, 309, 17077, 439, 7527, 295, 611, 819, 636, 295, 1953, 466, 14642, 300, 366, 787, 411, 309, 311, 257, 19813, 1389, 337, 14847, 8650, 300, 436, 643, 281, 519, 294, 257, 819, 14642, 281, 5039, 264, 912, 2740, 300, 321, 300, 321, 434, 1143, 281, 12606, 365, 18259, 14642, 11, 25873, 13], "temperature": 0.0, "avg_logprob": -0.24418248628315173, "compression_ratio": 1.6494252873563218, "no_speech_prob": 0.0001671723584877327}, {"id": 347, "seek": 279600, "start": 2796.0, "end": 2810.0, "text": " Okay, so if you learn Haskell, if you go from JavaScript to Haskell, you first have to learn about no mutation, you have to learn about recursion, and now you also have to think about well, laziness is a thing you need to.", "tokens": [1033, 11, 370, 498, 291, 1466, 8646, 43723, 11, 498, 291, 352, 490, 15778, 281, 8646, 43723, 11, 291, 700, 362, 281, 1466, 466, 572, 27960, 11, 291, 362, 281, 1466, 466, 20560, 313, 11, 293, 586, 291, 611, 362, 281, 519, 466, 731, 11, 19320, 1324, 307, 257, 551, 291, 643, 281, 13], "temperature": 0.0, "avg_logprob": -0.20549128988514775, "compression_ratio": 1.7519685039370079, "no_speech_prob": 1.9514618543325923e-05}, {"id": 348, "seek": 279600, "start": 2810.0, "end": 2813.0, "text": " Okay, yeah, that's that sounds like a lot of things to learn.", "tokens": [1033, 11, 1338, 11, 300, 311, 300, 3263, 411, 257, 688, 295, 721, 281, 1466, 13], "temperature": 0.0, "avg_logprob": -0.20549128988514775, "compression_ratio": 1.7519685039370079, "no_speech_prob": 1.9514618543325923e-05}, {"id": 349, "seek": 279600, "start": 2813.0, "end": 2814.0, "text": " Yes.", "tokens": [1079, 13], "temperature": 0.0, "avg_logprob": -0.20549128988514775, "compression_ratio": 1.7519685039370079, "no_speech_prob": 1.9514618543325923e-05}, {"id": 350, "seek": 279600, "start": 2814.0, "end": 2822.0, "text": " And also, yeah, coming back to the Elm question, for example, while doing Elm, you learn about carrying and partial application and higher order functions.", "tokens": [400, 611, 11, 1338, 11, 1348, 646, 281, 264, 2699, 76, 1168, 11, 337, 1365, 11, 1339, 884, 2699, 76, 11, 291, 1466, 466, 9792, 293, 14641, 3861, 293, 2946, 1668, 6828, 13], "temperature": 0.0, "avg_logprob": -0.20549128988514775, "compression_ratio": 1.7519685039370079, "no_speech_prob": 1.9514618543325923e-05}, {"id": 351, "seek": 282200, "start": 2822.0, "end": 2828.0, "text": " And these are functional concepts that are great, and you learn them and you use them instantly.", "tokens": [400, 613, 366, 11745, 10392, 300, 366, 869, 11, 293, 291, 1466, 552, 293, 291, 764, 552, 13518, 13], "temperature": 0.0, "avg_logprob": -0.16736944913864135, "compression_ratio": 1.626865671641791, "no_speech_prob": 0.00038588480674661696}, {"id": 352, "seek": 282200, "start": 2828.0, "end": 2836.0, "text": " But if you come from JavaScript, you might need to learn all those plus, as you said, the laziness and all the crazy Haskell stuff.", "tokens": [583, 498, 291, 808, 490, 15778, 11, 291, 1062, 643, 281, 1466, 439, 729, 1804, 11, 382, 291, 848, 11, 264, 19320, 1324, 293, 439, 264, 3219, 8646, 43723, 1507, 13], "temperature": 0.0, "avg_logprob": -0.16736944913864135, "compression_ratio": 1.626865671641791, "no_speech_prob": 0.00038588480674661696}, {"id": 353, "seek": 282200, "start": 2836.0, "end": 2841.0, "text": " So you have like a huge pile of things to learn when you want to get into Haskell from JavaScript.", "tokens": [407, 291, 362, 411, 257, 2603, 14375, 295, 721, 281, 1466, 562, 291, 528, 281, 483, 666, 8646, 43723, 490, 15778, 13], "temperature": 0.0, "avg_logprob": -0.16736944913864135, "compression_ratio": 1.626865671641791, "no_speech_prob": 0.00038588480674661696}, {"id": 354, "seek": 284100, "start": 2841.0, "end": 2863.0, "text": " The one place in Elm where I can think of this eager thing coming into play is in tests where you you say test and then give it the test name as a string and then you give it you know, usually you give it a left pipe to avoid parentheses and then you give it a lambda with unit.", "tokens": [440, 472, 1081, 294, 2699, 76, 689, 286, 393, 519, 295, 341, 18259, 551, 1348, 666, 862, 307, 294, 6921, 689, 291, 291, 584, 1500, 293, 550, 976, 309, 264, 1500, 1315, 382, 257, 6798, 293, 550, 291, 976, 309, 291, 458, 11, 2673, 291, 976, 309, 257, 1411, 11240, 281, 5042, 34153, 293, 550, 291, 976, 309, 257, 13607, 365, 4985, 13], "temperature": 0.0, "avg_logprob": -0.22541363559552094, "compression_ratio": 1.6848484848484848, "no_speech_prob": 4.9855210818350315e-05}, {"id": 355, "seek": 286300, "start": 2863.0, "end": 2881.0, "text": " And so that's just a way of creating laziness explicitly that and that's why the API has that because if you did your test cases without that being in a little lambda with with no data with a unit type argument,", "tokens": [400, 370, 300, 311, 445, 257, 636, 295, 4084, 19320, 1324, 20803, 300, 293, 300, 311, 983, 264, 9362, 575, 300, 570, 498, 291, 630, 428, 1500, 3331, 1553, 300, 885, 294, 257, 707, 13607, 365, 365, 572, 1412, 365, 257, 4985, 2010, 6770, 11], "temperature": 0.0, "avg_logprob": -0.18035261971609934, "compression_ratio": 1.4551724137931035, "no_speech_prob": 8.219672599807382e-05}, {"id": 356, "seek": 288100, "start": 2881.0, "end": 2894.0, "text": " then the test runner wouldn't be able to defer execution on a test or, you know, choose to parallelize tests by selectively running different ones on different threads.", "tokens": [550, 264, 1500, 24376, 2759, 380, 312, 1075, 281, 25704, 15058, 322, 257, 1500, 420, 11, 291, 458, 11, 2826, 281, 8952, 1125, 6921, 538, 3048, 3413, 2614, 819, 2306, 322, 819, 19314, 13], "temperature": 0.0, "avg_logprob": -0.19052550133238447, "compression_ratio": 1.4097222222222223, "no_speech_prob": 5.1438575610518456e-05}, {"id": 357, "seek": 288100, "start": 2894.0, "end": 2896.0, "text": " There are optimizations like that.", "tokens": [821, 366, 5028, 14455, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.19052550133238447, "compression_ratio": 1.4097222222222223, "no_speech_prob": 5.1438575610518456e-05}, {"id": 358, "seek": 289600, "start": 2896.0, "end": 2914.0, "text": " And also, if you have a test that has an infinite loop in it, you can't control which tests you want to run and say, well, I just want to try running this one. Okay, this one doesn't have an infinite loop. This one is green. Try running these other ones. These ones are red. They halt. They complete.", "tokens": [400, 611, 11, 498, 291, 362, 257, 1500, 300, 575, 364, 13785, 6367, 294, 309, 11, 291, 393, 380, 1969, 597, 6921, 291, 528, 281, 1190, 293, 584, 11, 731, 11, 286, 445, 528, 281, 853, 2614, 341, 472, 13, 1033, 11, 341, 472, 1177, 380, 362, 364, 13785, 6367, 13, 639, 472, 307, 3092, 13, 6526, 2614, 613, 661, 2306, 13, 1981, 2306, 366, 2182, 13, 814, 12479, 13, 814, 3566, 13], "temperature": 0.0, "avg_logprob": -0.2036967711015181, "compression_ratio": 1.694915254237288, "no_speech_prob": 7.5276093411957845e-06}, {"id": 359, "seek": 291400, "start": 2914.0, "end": 2927.0, "text": " And oh, I tried running this one and it infinitely loops. So you wouldn't be able to do that if it was eager because you'd run your test suite and they all just start running and it's an infinite loop and you don't get any feedback.", "tokens": [400, 1954, 11, 286, 3031, 2614, 341, 472, 293, 309, 36227, 16121, 13, 407, 291, 2759, 380, 312, 1075, 281, 360, 300, 498, 309, 390, 18259, 570, 291, 1116, 1190, 428, 1500, 14205, 293, 436, 439, 445, 722, 2614, 293, 309, 311, 364, 13785, 6367, 293, 291, 500, 380, 483, 604, 5824, 13], "temperature": 0.0, "avg_logprob": -0.16982516907809073, "compression_ratio": 1.4967741935483871, "no_speech_prob": 1.0783096513478085e-05}, {"id": 360, "seek": 292700, "start": 2927.0, "end": 2946.0, "text": " The one place where I would see this be very useful, at least I would see it, I would use it a lot, is when I want to potentially compute something only once. If I have a value that I need to compute, that is pretty expensive.", "tokens": [440, 472, 1081, 689, 286, 576, 536, 341, 312, 588, 4420, 11, 412, 1935, 286, 576, 536, 309, 11, 286, 576, 764, 309, 257, 688, 11, 307, 562, 286, 528, 281, 7263, 14722, 746, 787, 1564, 13, 759, 286, 362, 257, 2158, 300, 286, 643, 281, 14722, 11, 300, 307, 1238, 5124, 13], "temperature": 0.0, "avg_logprob": -0.2531565448694062, "compression_ratio": 1.5066666666666666, "no_speech_prob": 9.368183782498818e-06}, {"id": 361, "seek": 294600, "start": 2946.0, "end": 2966.0, "text": " I have the choice in Elm to either do it once, and then it's done for forever, but at the risk of it being computed unnecessarily. If this is done, if this value is passed to a map, for instance, then it's computed once, even if no one will ever reach for it.", "tokens": [286, 362, 264, 3922, 294, 2699, 76, 281, 2139, 360, 309, 1564, 11, 293, 550, 309, 311, 1096, 337, 5680, 11, 457, 412, 264, 3148, 295, 309, 885, 40610, 16799, 3289, 13, 759, 341, 307, 1096, 11, 498, 341, 2158, 307, 4678, 281, 257, 4471, 11, 337, 5197, 11, 550, 309, 311, 40610, 1564, 11, 754, 498, 572, 472, 486, 1562, 2524, 337, 309, 13], "temperature": 0.0, "avg_logprob": -0.18194314707880435, "compression_ratio": 1.5696969696969696, "no_speech_prob": 2.1111833120812662e-05}, {"id": 362, "seek": 296600, "start": 2966.0, "end": 2978.0, "text": " The other option is to compute it every time that I need it, which means that if I never need it, I will never compute it. But if I do need it multiple times, then I will compute it multiple times.", "tokens": [440, 661, 3614, 307, 281, 14722, 309, 633, 565, 300, 286, 643, 309, 11, 597, 1355, 300, 498, 286, 1128, 643, 309, 11, 286, 486, 1128, 14722, 309, 13, 583, 498, 286, 360, 643, 309, 3866, 1413, 11, 550, 286, 486, 14722, 309, 3866, 1413, 13], "temperature": 0.0, "avg_logprob": -0.2002634568647905, "compression_ratio": 1.7197802197802199, "no_speech_prob": 2.6268699002685025e-05}, {"id": 363, "seek": 296600, "start": 2978.0, "end": 2986.0, "text": " I feel like laziness here really helps because it will only be computed once it's needed. So that feels quite nice.", "tokens": [286, 841, 411, 19320, 1324, 510, 534, 3665, 570, 309, 486, 787, 312, 40610, 1564, 309, 311, 2978, 13, 407, 300, 3417, 1596, 1481, 13], "temperature": 0.0, "avg_logprob": -0.2002634568647905, "compression_ratio": 1.7197802197802199, "no_speech_prob": 2.6268699002685025e-05}, {"id": 364, "seek": 298600, "start": 2986.0, "end": 2997.0, "text": " This is something that I've thought about suggesting for the Elm language as well, but I have not come up with a good enough proposal.", "tokens": [639, 307, 746, 300, 286, 600, 1194, 466, 18094, 337, 264, 2699, 76, 2856, 382, 731, 11, 457, 286, 362, 406, 808, 493, 365, 257, 665, 1547, 11494, 13], "temperature": 0.0, "avg_logprob": -0.22729779561360677, "compression_ratio": 1.4976303317535544, "no_speech_prob": 0.00043507645023055375}, {"id": 365, "seek": 298600, "start": 2997.0, "end": 3010.0, "text": " Interesting. Also, maybe Evan explained why Elm is eager by default, but I'm sure there are some technical reasons why he chose to, and it would be interesting to read all of those.", "tokens": [14711, 13, 2743, 11, 1310, 22613, 8825, 983, 2699, 76, 307, 18259, 538, 7576, 11, 457, 286, 478, 988, 456, 366, 512, 6191, 4112, 983, 415, 5111, 281, 11, 293, 309, 576, 312, 1880, 281, 1401, 439, 295, 729, 13], "temperature": 0.0, "avg_logprob": -0.22729779561360677, "compression_ratio": 1.4976303317535544, "no_speech_prob": 0.00043507645023055375}, {"id": 366, "seek": 301000, "start": 3010.0, "end": 3024.0, "text": " I'm guessing because it compiles to JavaScript, that's a big part. JavaScript is eager as well. So if you want to make it lazy, then you have to add a whole lot of lazifying layer.", "tokens": [286, 478, 17939, 570, 309, 715, 4680, 281, 15778, 11, 300, 311, 257, 955, 644, 13, 15778, 307, 18259, 382, 731, 13, 407, 498, 291, 528, 281, 652, 309, 14847, 11, 550, 291, 362, 281, 909, 257, 1379, 688, 295, 19320, 5489, 4583, 13], "temperature": 0.0, "avg_logprob": -0.2516237298647563, "compression_ratio": 1.3533834586466165, "no_speech_prob": 0.00011957783863181248}, {"id": 367, "seek": 302400, "start": 3024.0, "end": 3044.0, "text": " Yeah. And a lot of the Elm philosophy is reducing the barrier to entry and being very simple and obvious. And lazy is just, it's like a powerful thing, but a sharp knife that comes with a lot of caveats and things to be careful about.", "tokens": [865, 13, 400, 257, 688, 295, 264, 2699, 76, 10675, 307, 12245, 264, 13357, 281, 8729, 293, 885, 588, 2199, 293, 6322, 13, 400, 14847, 307, 445, 11, 309, 311, 411, 257, 4005, 551, 11, 457, 257, 8199, 7976, 300, 1487, 365, 257, 688, 295, 11730, 1720, 293, 721, 281, 312, 5026, 466, 13], "temperature": 0.0, "avg_logprob": -0.21374906342605066, "compression_ratio": 1.4444444444444444, "no_speech_prob": 6.920169107615948e-05}, {"id": 368, "seek": 304400, "start": 3044.0, "end": 3058.0, "text": " And that's just kind of counter to the Elm philosophy. So I think it fits in the Elm philosophy to be avoiding that. Because I've heard a lot of people talking about gotchas with lazy.", "tokens": [400, 300, 311, 445, 733, 295, 5682, 281, 264, 2699, 76, 10675, 13, 407, 286, 519, 309, 9001, 294, 264, 2699, 76, 10675, 281, 312, 20220, 300, 13, 1436, 286, 600, 2198, 257, 688, 295, 561, 1417, 466, 658, 41299, 365, 14847, 13], "temperature": 0.0, "avg_logprob": -0.19067417491566052, "compression_ratio": 1.5508982035928143, "no_speech_prob": 2.3917615180835128e-05}, {"id": 369, "seek": 304400, "start": 3058.0, "end": 3063.0, "text": " So it comes with its fair share of caveats and things to be careful about.", "tokens": [407, 309, 1487, 365, 1080, 3143, 2073, 295, 11730, 1720, 293, 721, 281, 312, 5026, 466, 13], "temperature": 0.0, "avg_logprob": -0.19067417491566052, "compression_ratio": 1.5508982035928143, "no_speech_prob": 2.3917615180835128e-05}, {"id": 370, "seek": 306300, "start": 3063.0, "end": 3078.0, "text": " Okay. Effects. So you mentioned effects before. I know that there are some effects in Elm as well, like in the implementation of things like platform.command, maybe of task as well.", "tokens": [1033, 13, 34515, 13, 407, 291, 2835, 5065, 949, 13, 286, 458, 300, 456, 366, 512, 5065, 294, 2699, 76, 382, 731, 11, 411, 294, 264, 11420, 295, 721, 411, 3663, 13, 13278, 474, 11, 1310, 295, 5633, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.23816782633463543, "compression_ratio": 1.371212121212121, "no_speech_prob": 5.862656053068349e-06}, {"id": 371, "seek": 307800, "start": 3078.0, "end": 3096.0, "text": " And people who do Haskell seem to be familiar with that. And I have no clue what it is. I do think there was a blog post explaining that a few years ago for Elm, which was really good, but I've forgotten everything that it said.", "tokens": [400, 561, 567, 360, 8646, 43723, 1643, 281, 312, 4963, 365, 300, 13, 400, 286, 362, 572, 13602, 437, 309, 307, 13, 286, 360, 519, 456, 390, 257, 6968, 2183, 13468, 300, 257, 1326, 924, 2057, 337, 2699, 76, 11, 597, 390, 534, 665, 11, 457, 286, 600, 11832, 1203, 300, 309, 848, 13], "temperature": 0.0, "avg_logprob": -0.20772281325007058, "compression_ratio": 1.5023474178403755, "no_speech_prob": 0.00015831735800020397}, {"id": 372, "seek": 307800, "start": 3096.0, "end": 3103.0, "text": " I should reread it. But yeah, can you explain to me what effects are and what are they for?", "tokens": [286, 820, 46453, 345, 309, 13, 583, 1338, 11, 393, 291, 2903, 281, 385, 437, 5065, 366, 293, 437, 366, 436, 337, 30], "temperature": 0.0, "avg_logprob": -0.20772281325007058, "compression_ratio": 1.5023474178403755, "no_speech_prob": 0.00015831735800020397}, {"id": 373, "seek": 310300, "start": 3103.0, "end": 3117.0, "text": " Well, actually it's kind of an interesting topic because for me, effects are just like things or computations that happen on, for example, like on an input output or on a side effect kind of world.", "tokens": [1042, 11, 767, 309, 311, 733, 295, 364, 1880, 4829, 570, 337, 385, 11, 5065, 366, 445, 411, 721, 420, 2807, 763, 300, 1051, 322, 11, 337, 1365, 11, 411, 322, 364, 4846, 5598, 420, 322, 257, 1252, 1802, 733, 295, 1002, 13], "temperature": 0.0, "avg_logprob": -0.24677759058335247, "compression_ratio": 1.6452991452991452, "no_speech_prob": 0.0010129536967724562}, {"id": 374, "seek": 310300, "start": 3117.0, "end": 3129.0, "text": " But I know that when people refer to effects, they are mostly talking about either effect systems or algebraic effects, which is something that also looks to me really scary and abstract.", "tokens": [583, 286, 458, 300, 562, 561, 2864, 281, 5065, 11, 436, 366, 5240, 1417, 466, 2139, 1802, 3652, 420, 21989, 299, 5065, 11, 597, 307, 746, 300, 611, 1542, 281, 385, 534, 6958, 293, 12649, 13], "temperature": 0.0, "avg_logprob": -0.24677759058335247, "compression_ratio": 1.6452991452991452, "no_speech_prob": 0.0010129536967724562}, {"id": 375, "seek": 312900, "start": 3129.0, "end": 3149.0, "text": " And Haskell, I know there are a few Haskell libraries that try to implement this concept of algebraic effects, but to my knowledge, none of them is like a hundred percent solved all the edge cases and things to deal with those effect systems.", "tokens": [400, 8646, 43723, 11, 286, 458, 456, 366, 257, 1326, 8646, 43723, 15148, 300, 853, 281, 4445, 341, 3410, 295, 21989, 299, 5065, 11, 457, 281, 452, 3601, 11, 6022, 295, 552, 307, 411, 257, 3262, 3043, 13041, 439, 264, 4691, 3331, 293, 721, 281, 2028, 365, 729, 1802, 3652, 13], "temperature": 0.0, "avg_logprob": -0.21714765375310724, "compression_ratio": 1.4491017964071857, "no_speech_prob": 0.00129836390260607}, {"id": 376, "seek": 314900, "start": 3149.0, "end": 3161.0, "text": " But yeah, for example, there is one effects library called Effectful. It's gaining some traction in the Haskell community and the creator happens to work in the same company I do.", "tokens": [583, 1338, 11, 337, 1365, 11, 456, 307, 472, 5065, 6405, 1219, 17764, 906, 13, 467, 311, 19752, 512, 23558, 294, 264, 8646, 43723, 1768, 293, 264, 14181, 2314, 281, 589, 294, 264, 912, 2237, 286, 360, 13], "temperature": 0.0, "avg_logprob": -0.21867255704948702, "compression_ratio": 1.5530973451327434, "no_speech_prob": 0.00029478679061867297}, {"id": 377, "seek": 314900, "start": 3161.0, "end": 3173.0, "text": " So my company is fully switching to, instead of using monad transformers, which is like a way of trying to compose and combine monads, is the de facto standard in Haskell.", "tokens": [407, 452, 2237, 307, 4498, 16493, 281, 11, 2602, 295, 1228, 1108, 345, 4088, 433, 11, 597, 307, 411, 257, 636, 295, 1382, 281, 35925, 293, 10432, 1108, 5834, 11, 307, 264, 368, 42225, 3832, 294, 8646, 43723, 13], "temperature": 0.0, "avg_logprob": -0.21867255704948702, "compression_ratio": 1.5530973451327434, "no_speech_prob": 0.00029478679061867297}, {"id": 378, "seek": 317300, "start": 3173.0, "end": 3188.0, "text": " And then they are switching from this monad transformer stack to Effectful to try to use this effect system in a simple way and in a way that the code looks actually readable and usable without understanding all the machinery behind it.", "tokens": [400, 550, 436, 366, 16493, 490, 341, 1108, 345, 31782, 8630, 281, 17764, 906, 281, 853, 281, 764, 341, 1802, 1185, 294, 257, 2199, 636, 293, 294, 257, 636, 300, 264, 3089, 1542, 767, 49857, 293, 29975, 1553, 3701, 439, 264, 27302, 2261, 309, 13], "temperature": 0.0, "avg_logprob": -0.19640358207152062, "compression_ratio": 1.6024590163934427, "no_speech_prob": 0.00019692412752192467}, {"id": 379, "seek": 317300, "start": 3188.0, "end": 3198.0, "text": " But to be honest, since I haven't dwelled too much into it, I am not an expert in effects at all. So I feel as lost as you both.", "tokens": [583, 281, 312, 3245, 11, 1670, 286, 2378, 380, 274, 826, 5929, 886, 709, 666, 309, 11, 286, 669, 406, 364, 5844, 294, 5065, 412, 439, 13, 407, 286, 841, 382, 2731, 382, 291, 1293, 13], "temperature": 0.0, "avg_logprob": -0.19640358207152062, "compression_ratio": 1.6024590163934427, "no_speech_prob": 0.00019692412752192467}, {"id": 380, "seek": 317300, "start": 3198.0, "end": 3200.0, "text": " That's fair. That's fair.", "tokens": [663, 311, 3143, 13, 663, 311, 3143, 13], "temperature": 0.0, "avg_logprob": -0.19640358207152062, "compression_ratio": 1.6024590163934427, "no_speech_prob": 0.00019692412752192467}, {"id": 381, "seek": 320000, "start": 3200.0, "end": 3211.0, "text": " Is it the same general idea as it is when we use the term effect in Elm, where it's creating a data type that represents a possible effect without executing it?", "tokens": [1119, 309, 264, 912, 2674, 1558, 382, 309, 307, 562, 321, 764, 264, 1433, 1802, 294, 2699, 76, 11, 689, 309, 311, 4084, 257, 1412, 2010, 300, 8855, 257, 1944, 1802, 1553, 32368, 309, 30], "temperature": 0.0, "avg_logprob": -0.17420947298090508, "compression_ratio": 1.7085201793721974, "no_speech_prob": 1.2216871255077422e-05}, {"id": 382, "seek": 320000, "start": 3211.0, "end": 3224.0, "text": " Like a command, if you pass it to update or init in Elm, a command will do something, whereas an effect needs to be given a perform function to turn it into a command.", "tokens": [1743, 257, 5622, 11, 498, 291, 1320, 309, 281, 5623, 420, 3157, 294, 2699, 76, 11, 257, 5622, 486, 360, 746, 11, 9735, 364, 1802, 2203, 281, 312, 2212, 257, 2042, 2445, 281, 1261, 309, 666, 257, 5622, 13], "temperature": 0.0, "avg_logprob": -0.17420947298090508, "compression_ratio": 1.7085201793721974, "no_speech_prob": 1.2216871255077422e-05}, {"id": 383, "seek": 320000, "start": 3224.0, "end": 3227.0, "text": " Is it the same concept or is it a different concept?", "tokens": [1119, 309, 264, 912, 3410, 420, 307, 309, 257, 819, 3410, 30], "temperature": 0.0, "avg_logprob": -0.17420947298090508, "compression_ratio": 1.7085201793721974, "no_speech_prob": 1.2216871255077422e-05}, {"id": 384, "seek": 322700, "start": 3227.0, "end": 3243.0, "text": " Yes, I know there is something along those lines, like declaratively dealing with effects and computations. But it's a term that is also used with the same name in different languages for different things. So it's quite confusing as well.", "tokens": [1079, 11, 286, 458, 456, 307, 746, 2051, 729, 3876, 11, 411, 16694, 19020, 6260, 365, 5065, 293, 2807, 763, 13, 583, 309, 311, 257, 1433, 300, 307, 611, 1143, 365, 264, 912, 1315, 294, 819, 8650, 337, 819, 721, 13, 407, 309, 311, 1596, 13181, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.2514986991882324, "compression_ratio": 1.4422110552763818, "no_speech_prob": 9.599499753676355e-05}, {"id": 385, "seek": 322700, "start": 3243.0, "end": 3246.0, "text": " Oh no, OCaml, what have you done again?", "tokens": [876, 572, 11, 422, 31030, 75, 11, 437, 362, 291, 1096, 797, 30], "temperature": 0.0, "avg_logprob": -0.2514986991882324, "compression_ratio": 1.4422110552763818, "no_speech_prob": 9.599499753676355e-05}, {"id": 386, "seek": 322700, "start": 3246.0, "end": 3252.0, "text": " Exactly.", "tokens": [7587, 13], "temperature": 0.0, "avg_logprob": -0.2514986991882324, "compression_ratio": 1.4422110552763818, "no_speech_prob": 9.599499753676355e-05}, {"id": 387, "seek": 325200, "start": 3252.0, "end": 3266.0, "text": " So on the topic of effects, back to I-O a little bit. One thing that I've wondered, so I've been implementing some effect-y, I-O-y things in Elm Pages.", "tokens": [407, 322, 264, 4829, 295, 5065, 11, 646, 281, 286, 12, 46, 257, 707, 857, 13, 1485, 551, 300, 286, 600, 17055, 11, 370, 286, 600, 668, 18114, 512, 1802, 12, 88, 11, 286, 12, 46, 12, 88, 721, 294, 2699, 76, 430, 1660, 13], "temperature": 0.0, "avg_logprob": -0.25754446270822107, "compression_ratio": 1.508108108108108, "no_speech_prob": 0.00026013876777142286}, {"id": 388, "seek": 325200, "start": 3266.0, "end": 3277.0, "text": " There's a backend task similar to an Elm task, but in Elm Pages v3, it's full stack, so you can do things in a backend context.", "tokens": [821, 311, 257, 38087, 5633, 2531, 281, 364, 2699, 76, 5633, 11, 457, 294, 2699, 76, 430, 1660, 371, 18, 11, 309, 311, 1577, 8630, 11, 370, 291, 393, 360, 721, 294, 257, 38087, 4319, 13], "temperature": 0.0, "avg_logprob": -0.25754446270822107, "compression_ratio": 1.508108108108108, "no_speech_prob": 0.00026013876777142286}, {"id": 389, "seek": 327700, "start": 3277.0, "end": 3289.0, "text": " And so one of the things as I was designing it was I was thinking about Haskell I-O, and I was like, why is there one type variable in I-O?", "tokens": [400, 370, 472, 295, 264, 721, 382, 286, 390, 14685, 309, 390, 286, 390, 1953, 466, 8646, 43723, 286, 12, 46, 11, 293, 286, 390, 411, 11, 983, 307, 456, 472, 2010, 7006, 294, 286, 12, 46, 30], "temperature": 0.0, "avg_logprob": -0.1906125886099679, "compression_ratio": 1.6179775280898876, "no_speech_prob": 0.00025679354439489543}, {"id": 390, "seek": 327700, "start": 3289.0, "end": 3301.0, "text": " So in Haskell, you can chain I-O to, I guess, like read from a file, and then given the thing you read from a file, you can map that into something.", "tokens": [407, 294, 8646, 43723, 11, 291, 393, 5021, 286, 12, 46, 281, 11, 286, 2041, 11, 411, 1401, 490, 257, 3991, 11, 293, 550, 2212, 264, 551, 291, 1401, 490, 257, 3991, 11, 291, 393, 4471, 300, 666, 746, 13], "temperature": 0.0, "avg_logprob": -0.1906125886099679, "compression_ratio": 1.6179775280898876, "no_speech_prob": 0.00025679354439489543}, {"id": 391, "seek": 330100, "start": 3301.0, "end": 3311.0, "text": " But if an error happens, you don't know what type of error data, if I'm understanding correctly, that is erased from the type.", "tokens": [583, 498, 364, 6713, 2314, 11, 291, 500, 380, 458, 437, 2010, 295, 6713, 1412, 11, 498, 286, 478, 3701, 8944, 11, 300, 307, 38359, 490, 264, 2010, 13], "temperature": 0.0, "avg_logprob": -0.17300311724344888, "compression_ratio": 1.542857142857143, "no_speech_prob": 4.399768295115791e-05}, {"id": 392, "seek": 330100, "start": 3311.0, "end": 3324.0, "text": " The possible error data is erased in the I-O type, whereas if you look at the Elm core task type, it's task error value, and you can map error.", "tokens": [440, 1944, 6713, 1412, 307, 38359, 294, 264, 286, 12, 46, 2010, 11, 9735, 498, 291, 574, 412, 264, 2699, 76, 4965, 5633, 2010, 11, 309, 311, 5633, 6713, 2158, 11, 293, 291, 393, 4471, 6713, 13], "temperature": 0.0, "avg_logprob": -0.17300311724344888, "compression_ratio": 1.542857142857143, "no_speech_prob": 4.399768295115791e-05}, {"id": 393, "seek": 332400, "start": 3324.0, "end": 3338.0, "text": " And you can task.perform says it takes a task that never errors, and you can recover from errors in this, you know, I don't want to say monadic style,", "tokens": [400, 291, 393, 5633, 13, 26765, 1619, 309, 2516, 257, 5633, 300, 1128, 13603, 11, 293, 291, 393, 8114, 490, 13603, 294, 341, 11, 291, 458, 11, 286, 500, 380, 528, 281, 584, 1108, 43341, 3758, 11], "temperature": 0.0, "avg_logprob": -0.2239056386445698, "compression_ratio": 1.6111111111111112, "no_speech_prob": 8.664513188705314e-06}, {"id": 394, "seek": 332400, "start": 3338.0, "end": 3349.0, "text": " because I know it's not technically following monadic laws, but that sort of explicit way of chaining things together and knowing the types based on the type signature.", "tokens": [570, 286, 458, 309, 311, 406, 12120, 3480, 1108, 43341, 6064, 11, 457, 300, 1333, 295, 13691, 636, 295, 417, 3686, 721, 1214, 293, 5276, 264, 3467, 2361, 322, 264, 2010, 13397, 13], "temperature": 0.0, "avg_logprob": -0.2239056386445698, "compression_ratio": 1.6111111111111112, "no_speech_prob": 8.664513188705314e-06}, {"id": 395, "seek": 334900, "start": 3349.0, "end": 3357.0, "text": " So what's the deal with that in Haskell? Why does I-O not have an error type represented in its type variables?", "tokens": [407, 437, 311, 264, 2028, 365, 300, 294, 8646, 43723, 30, 1545, 775, 286, 12, 46, 406, 362, 364, 6713, 2010, 10379, 294, 1080, 2010, 9102, 30], "temperature": 0.0, "avg_logprob": -0.24120576330955992, "compression_ratio": 1.5689655172413792, "no_speech_prob": 2.976917130581569e-05}, {"id": 396, "seek": 334900, "start": 3357.0, "end": 3364.0, "text": " So I know that I-O has this type variable because obviously like a monad needs to have it.", "tokens": [407, 286, 458, 300, 286, 12, 46, 575, 341, 2010, 7006, 570, 2745, 411, 257, 1108, 345, 2203, 281, 362, 309, 13], "temperature": 0.0, "avg_logprob": -0.24120576330955992, "compression_ratio": 1.5689655172413792, "no_speech_prob": 2.976917130581569e-05}, {"id": 397, "seek": 334900, "start": 3364.0, "end": 3376.0, "text": " Right? Because you think about maybe or either, well, which is called result in Elm, it needs to have something to wrap around because it's a wrapper in the end.", "tokens": [1779, 30, 1436, 291, 519, 466, 1310, 420, 2139, 11, 731, 11, 597, 307, 1219, 1874, 294, 2699, 76, 11, 309, 2203, 281, 362, 746, 281, 7019, 926, 570, 309, 311, 257, 46906, 294, 264, 917, 13], "temperature": 0.0, "avg_logprob": -0.24120576330955992, "compression_ratio": 1.5689655172413792, "no_speech_prob": 2.976917130581569e-05}, {"id": 398, "seek": 337600, "start": 3376.0, "end": 3383.0, "text": " That's why all the memes of monad being burritos comes from.", "tokens": [663, 311, 983, 439, 264, 29730, 295, 1108, 345, 885, 2779, 42887, 1487, 490, 13], "temperature": 0.0, "avg_logprob": -0.20961783482478216, "compression_ratio": 1.5851063829787233, "no_speech_prob": 0.0002094426890835166}, {"id": 399, "seek": 337600, "start": 3383.0, "end": 3395.0, "text": " But basically, for example, the simplest example of people using the I-O monad to perform side effects or to do stuff like, for example, printing to the command line,", "tokens": [583, 1936, 11, 337, 1365, 11, 264, 22811, 1365, 295, 561, 1228, 264, 286, 12, 46, 1108, 345, 281, 2042, 1252, 5065, 420, 281, 360, 1507, 411, 11, 337, 1365, 11, 14699, 281, 264, 5622, 1622, 11], "temperature": 0.0, "avg_logprob": -0.20961783482478216, "compression_ratio": 1.5851063829787233, "no_speech_prob": 0.0002094426890835166}, {"id": 400, "seek": 337600, "start": 3395.0, "end": 3399.0, "text": " they're using I-O and then open and close bracket, like the unit type.", "tokens": [436, 434, 1228, 286, 12, 46, 293, 550, 1269, 293, 1998, 16904, 11, 411, 264, 4985, 2010, 13], "temperature": 0.0, "avg_logprob": -0.20961783482478216, "compression_ratio": 1.5851063829787233, "no_speech_prob": 0.0002094426890835166}, {"id": 401, "seek": 339900, "start": 3399.0, "end": 3410.0, "text": " So it's like, it's an I-O that is going to perform nothing effect. And you will see these in type signatures all across many Haskell code bases.", "tokens": [407, 309, 311, 411, 11, 309, 311, 364, 286, 12, 46, 300, 307, 516, 281, 2042, 1825, 1802, 13, 400, 291, 486, 536, 613, 294, 2010, 32322, 439, 2108, 867, 8646, 43723, 3089, 17949, 13], "temperature": 0.0, "avg_logprob": -0.2213806955437911, "compression_ratio": 1.5956521739130434, "no_speech_prob": 9.852038056124002e-05}, {"id": 402, "seek": 339900, "start": 3410.0, "end": 3417.0, "text": " Why it doesn't have more than one type variable? I really don't know, but it's an interesting question.", "tokens": [1545, 309, 1177, 380, 362, 544, 813, 472, 2010, 7006, 30, 286, 534, 500, 380, 458, 11, 457, 309, 311, 364, 1880, 1168, 13], "temperature": 0.0, "avg_logprob": -0.2213806955437911, "compression_ratio": 1.5956521739130434, "no_speech_prob": 9.852038056124002e-05}, {"id": 403, "seek": 339900, "start": 3417.0, "end": 3426.0, "text": " Yeah. Well, so if you can throw an exception, like when you catch an exception, do you know the type of the exception?", "tokens": [865, 13, 1042, 11, 370, 498, 291, 393, 3507, 364, 11183, 11, 411, 562, 291, 3745, 364, 11183, 11, 360, 291, 458, 264, 2010, 295, 264, 11183, 30], "temperature": 0.0, "avg_logprob": -0.2213806955437911, "compression_ratio": 1.5956521739130434, "no_speech_prob": 9.852038056124002e-05}, {"id": 404, "seek": 342600, "start": 3426.0, "end": 3432.0, "text": " Do you catch it? Do you catch it through the monad, the I-O monad interface?", "tokens": [1144, 291, 3745, 309, 30, 1144, 291, 3745, 309, 807, 264, 1108, 345, 11, 264, 286, 12, 46, 1108, 345, 9226, 30], "temperature": 0.0, "avg_logprob": -0.20848950136055067, "compression_ratio": 1.7222222222222223, "no_speech_prob": 2.3525059077655897e-05}, {"id": 405, "seek": 342600, "start": 3432.0, "end": 3440.0, "text": " Or is it just a completely separate thing that is not specific to I-O to deal with exception handling?", "tokens": [1610, 307, 309, 445, 257, 2584, 4994, 551, 300, 307, 406, 2685, 281, 286, 12, 46, 281, 2028, 365, 11183, 13175, 30], "temperature": 0.0, "avg_logprob": -0.20848950136055067, "compression_ratio": 1.7222222222222223, "no_speech_prob": 2.3525059077655897e-05}, {"id": 406, "seek": 342600, "start": 3440.0, "end": 3444.0, "text": " Yes, it's specific to I-O and all exceptions are typed.", "tokens": [1079, 11, 309, 311, 2685, 281, 286, 12, 46, 293, 439, 22847, 366, 33941, 13], "temperature": 0.0, "avg_logprob": -0.20848950136055067, "compression_ratio": 1.7222222222222223, "no_speech_prob": 2.3525059077655897e-05}, {"id": 407, "seek": 342600, "start": 3444.0, "end": 3454.0, "text": " So when you catch an exception, the I-O or Elm, you get lots of information from that exception and you can use it to your will as well.", "tokens": [407, 562, 291, 3745, 364, 11183, 11, 264, 286, 12, 46, 420, 2699, 76, 11, 291, 483, 3195, 295, 1589, 490, 300, 11183, 293, 291, 393, 764, 309, 281, 428, 486, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.20848950136055067, "compression_ratio": 1.7222222222222223, "no_speech_prob": 2.3525059077655897e-05}, {"id": 408, "seek": 345400, "start": 3454.0, "end": 3457.0, "text": " You can then use it to your needs.", "tokens": [509, 393, 550, 764, 309, 281, 428, 2203, 13], "temperature": 0.0, "avg_logprob": -0.30367662573373444, "compression_ratio": 1.5668016194331984, "no_speech_prob": 7.96208405517973e-05}, {"id": 409, "seek": 345400, "start": 3457.0, "end": 3461.0, "text": " Interesting. Okay. Well, that's nice that they're typed.", "tokens": [14711, 13, 1033, 13, 1042, 11, 300, 311, 1481, 300, 436, 434, 1104, 3452, 13], "temperature": 0.0, "avg_logprob": -0.30367662573373444, "compression_ratio": 1.5668016194331984, "no_speech_prob": 7.96208405517973e-05}, {"id": 410, "seek": 345400, "start": 3461.0, "end": 3472.0, "text": " That's always like the most frustrating thing for me in TypeScript is that you catch an exception and it just completely forgot what might have happened along the chain.", "tokens": [663, 311, 1009, 411, 264, 881, 16522, 551, 337, 385, 294, 15576, 14237, 307, 300, 291, 3745, 364, 11183, 293, 309, 445, 2584, 5298, 437, 1062, 362, 2011, 2051, 264, 5021, 13], "temperature": 0.0, "avg_logprob": -0.30367662573373444, "compression_ratio": 1.5668016194331984, "no_speech_prob": 7.96208405517973e-05}, {"id": 411, "seek": 345400, "start": 3472.0, "end": 3475.0, "text": " You know nothing about it nearly, right?", "tokens": [509, 458, 1825, 466, 309, 6217, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.30367662573373444, "compression_ratio": 1.5668016194331984, "no_speech_prob": 7.96208405517973e-05}, {"id": 412, "seek": 345400, "start": 3475.0, "end": 3480.0, "text": " Right, right. Are you forced to acknowledge that something could throw an exception?", "tokens": [1779, 11, 558, 13, 2014, 291, 7579, 281, 10692, 300, 746, 727, 3507, 364, 11183, 30], "temperature": 0.0, "avg_logprob": -0.30367662573373444, "compression_ratio": 1.5668016194331984, "no_speech_prob": 7.96208405517973e-05}, {"id": 413, "seek": 348000, "start": 3480.0, "end": 3487.0, "text": " And I'm guessing no, anything can just throw an exception and you don't have to annotate it or allow it to fail in any way.", "tokens": [400, 286, 478, 17939, 572, 11, 1340, 393, 445, 3507, 364, 11183, 293, 291, 500, 380, 362, 281, 25339, 473, 309, 420, 2089, 309, 281, 3061, 294, 604, 636, 13], "temperature": 0.0, "avg_logprob": -0.2235584491636695, "compression_ratio": 1.5302325581395348, "no_speech_prob": 6.596023740712553e-05}, {"id": 414, "seek": 348000, "start": 3487.0, "end": 3496.0, "text": " Yeah, that's the thing, like the Haskell etiquette or the standards that we try when we do pull request reviews and all that.", "tokens": [865, 11, 300, 311, 264, 551, 11, 411, 264, 8646, 43723, 42177, 3007, 420, 264, 7787, 300, 321, 853, 562, 321, 360, 2235, 5308, 10229, 293, 439, 300, 13], "temperature": 0.0, "avg_logprob": -0.2235584491636695, "compression_ratio": 1.5302325581395348, "no_speech_prob": 6.596023740712553e-05}, {"id": 415, "seek": 348000, "start": 3496.0, "end": 3500.0, "text": " Obviously, you should know do things without signifying this in type signature.", "tokens": [7580, 11, 291, 820, 458, 360, 721, 1553, 1465, 5489, 341, 294, 2010, 13397, 13], "temperature": 0.0, "avg_logprob": -0.2235584491636695, "compression_ratio": 1.5302325581395348, "no_speech_prob": 6.596023740712553e-05}, {"id": 416, "seek": 350000, "start": 3500.0, "end": 3512.0, "text": " But it's kind of like a paradox or like strange that some prelude functions because of legacy or inherited reasons do throw exceptions when you don't.", "tokens": [583, 309, 311, 733, 295, 411, 257, 26221, 420, 411, 5861, 300, 512, 659, 32334, 6828, 570, 295, 11711, 420, 27091, 4112, 360, 3507, 22847, 562, 291, 500, 380, 13], "temperature": 0.0, "avg_logprob": -0.19806747436523436, "compression_ratio": 1.6307053941908713, "no_speech_prob": 0.00015071108646225184}, {"id": 417, "seek": 350000, "start": 3512.0, "end": 3516.0, "text": " But it's like, okay, there's a few catches.", "tokens": [583, 309, 311, 411, 11, 1392, 11, 456, 311, 257, 1326, 25496, 13], "temperature": 0.0, "avg_logprob": -0.19806747436523436, "compression_ratio": 1.6307053941908713, "no_speech_prob": 0.00015071108646225184}, {"id": 418, "seek": 350000, "start": 3516.0, "end": 3519.0, "text": " People know about those functions. They are known to be dangerous.", "tokens": [3432, 458, 466, 729, 6828, 13, 814, 366, 2570, 281, 312, 5795, 13], "temperature": 0.0, "avg_logprob": -0.19806747436523436, "compression_ratio": 1.6307053941908713, "no_speech_prob": 0.00015071108646225184}, {"id": 419, "seek": 350000, "start": 3519.0, "end": 3528.0, "text": " So either they use them with care or they don't use them at all and they use some safe alternative from a well-established library.", "tokens": [407, 2139, 436, 764, 552, 365, 1127, 420, 436, 500, 380, 764, 552, 412, 439, 293, 436, 764, 512, 3273, 8535, 490, 257, 731, 12, 33542, 4173, 6405, 13], "temperature": 0.0, "avg_logprob": -0.19806747436523436, "compression_ratio": 1.6307053941908713, "no_speech_prob": 0.00015071108646225184}, {"id": 420, "seek": 352800, "start": 3528.0, "end": 3534.0, "text": " But obviously, yeah, you are doing Haskell for the same reason you would like to do Elm.", "tokens": [583, 2745, 11, 1338, 11, 291, 366, 884, 8646, 43723, 337, 264, 912, 1778, 291, 576, 411, 281, 360, 2699, 76, 13], "temperature": 0.0, "avg_logprob": -0.22093148134192642, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0004796606954187155}, {"id": 421, "seek": 352800, "start": 3534.0, "end": 3541.0, "text": " You would like to trust 100% in purity and not having to worry about strange stuff.", "tokens": [509, 576, 411, 281, 3361, 2319, 4, 294, 34382, 293, 406, 1419, 281, 3292, 466, 5861, 1507, 13], "temperature": 0.0, "avg_logprob": -0.22093148134192642, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0004796606954187155}, {"id": 422, "seek": 352800, "start": 3541.0, "end": 3552.0, "text": " But for example, there is a placeholder called undefined, which is like the debug.todoElm thing that you can just give a name and don't implement thing.", "tokens": [583, 337, 1365, 11, 456, 307, 257, 1081, 20480, 1219, 674, 5666, 2001, 11, 597, 307, 411, 264, 24083, 13, 83, 17423, 17356, 76, 551, 300, 291, 393, 445, 976, 257, 1315, 293, 500, 380, 4445, 551, 13], "temperature": 0.0, "avg_logprob": -0.22093148134192642, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0004796606954187155}, {"id": 423, "seek": 352800, "start": 3552.0, "end": 3555.0, "text": " So that's a keyword called undefined.", "tokens": [407, 300, 311, 257, 20428, 1219, 674, 5666, 2001, 13], "temperature": 0.0, "avg_logprob": -0.22093148134192642, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0004796606954187155}, {"id": 424, "seek": 355500, "start": 3555.0, "end": 3560.0, "text": " Undefined takes a string. Is that it?", "tokens": [2719, 5666, 2001, 2516, 257, 6798, 13, 1119, 300, 309, 30], "temperature": 0.0, "avg_logprob": -0.25453010870485887, "compression_ratio": 1.689265536723164, "no_speech_prob": 0.0003901640302501619}, {"id": 425, "seek": 355500, "start": 3560.0, "end": 3563.0, "text": " No, no. Undefined is a value on itself.", "tokens": [883, 11, 572, 13, 2719, 5666, 2001, 307, 257, 2158, 322, 2564, 13], "temperature": 0.0, "avg_logprob": -0.25453010870485887, "compression_ratio": 1.689265536723164, "no_speech_prob": 0.0003901640302501619}, {"id": 426, "seek": 355500, "start": 3563.0, "end": 3565.0, "text": " But it's not a function.", "tokens": [583, 309, 311, 406, 257, 2445, 13], "temperature": 0.0, "avg_logprob": -0.25453010870485887, "compression_ratio": 1.689265536723164, "no_speech_prob": 0.0003901640302501619}, {"id": 427, "seek": 355500, "start": 3565.0, "end": 3567.0, "text": " Yeah, no, it's not a function.", "tokens": [865, 11, 572, 11, 309, 311, 406, 257, 2445, 13], "temperature": 0.0, "avg_logprob": -0.25453010870485887, "compression_ratio": 1.689265536723164, "no_speech_prob": 0.0003901640302501619}, {"id": 428, "seek": 355500, "start": 3567.0, "end": 3572.0, "text": " Undefined is not a function in Haskell.", "tokens": [2719, 5666, 2001, 307, 406, 257, 2445, 294, 8646, 43723, 13], "temperature": 0.0, "avg_logprob": -0.25453010870485887, "compression_ratio": 1.689265536723164, "no_speech_prob": 0.0003901640302501619}, {"id": 429, "seek": 355500, "start": 3572.0, "end": 3580.0, "text": " But there is an undefined and it's considered to be the bottom value is, you know, you're not meant to to ship code using it.", "tokens": [583, 456, 307, 364, 674, 5666, 2001, 293, 309, 311, 4888, 281, 312, 264, 2767, 2158, 307, 11, 291, 458, 11, 291, 434, 406, 4140, 281, 281, 5374, 3089, 1228, 309, 13], "temperature": 0.0, "avg_logprob": -0.25453010870485887, "compression_ratio": 1.689265536723164, "no_speech_prob": 0.0003901640302501619}, {"id": 430, "seek": 358000, "start": 3580.0, "end": 3587.0, "text": " But you can signal that something is not implemented by just putting an undefined there in the code base.", "tokens": [583, 291, 393, 6358, 300, 746, 307, 406, 12270, 538, 445, 3372, 364, 674, 5666, 2001, 456, 294, 264, 3089, 3096, 13], "temperature": 0.0, "avg_logprob": -0.2129852423507176, "compression_ratio": 1.599078341013825, "no_speech_prob": 1.519532179372618e-05}, {"id": 431, "seek": 358000, "start": 3587.0, "end": 3590.0, "text": " Gotcha. OK. Yeah, that's useful.", "tokens": [42109, 13, 2264, 13, 865, 11, 300, 311, 4420, 13], "temperature": 0.0, "avg_logprob": -0.2129852423507176, "compression_ratio": 1.599078341013825, "no_speech_prob": 1.519532179372618e-05}, {"id": 432, "seek": 358000, "start": 3590.0, "end": 3595.0, "text": " You're not meant to ship code with that, but you could ship code with that.", "tokens": [509, 434, 406, 4140, 281, 5374, 3089, 365, 300, 11, 457, 291, 727, 5374, 3089, 365, 300, 13], "temperature": 0.0, "avg_logprob": -0.2129852423507176, "compression_ratio": 1.599078341013825, "no_speech_prob": 1.519532179372618e-05}, {"id": 433, "seek": 358000, "start": 3595.0, "end": 3597.0, "text": " Exactly. I think so.", "tokens": [7587, 13, 286, 519, 370, 13], "temperature": 0.0, "avg_logprob": -0.2129852423507176, "compression_ratio": 1.599078341013825, "no_speech_prob": 1.519532179372618e-05}, {"id": 434, "seek": 358000, "start": 3597.0, "end": 3603.0, "text": " Like there's no checking the package registry or something that prevents you from shipping code with undefined.", "tokens": [1743, 456, 311, 572, 8568, 264, 7372, 36468, 420, 746, 300, 22367, 291, 490, 14122, 3089, 365, 674, 5666, 2001, 13], "temperature": 0.0, "avg_logprob": -0.2129852423507176, "compression_ratio": 1.599078341013825, "no_speech_prob": 1.519532179372618e-05}, {"id": 435, "seek": 360300, "start": 3603.0, "end": 3613.0, "text": " It's so interesting because like in a way you would you would tend to think of like Haskell as the purists, not Elm.", "tokens": [467, 311, 370, 1880, 570, 411, 294, 257, 636, 291, 576, 291, 576, 3928, 281, 519, 295, 411, 8646, 43723, 382, 264, 1864, 1751, 11, 406, 2699, 76, 13], "temperature": 0.0, "avg_logprob": -0.20247316934976234, "compression_ratio": 1.7470588235294118, "no_speech_prob": 4.9832342483568937e-05}, {"id": 436, "seek": 360300, "start": 3613.0, "end": 3620.0, "text": " But in a way like Elm really the thing that Elm is a purist about is purity.", "tokens": [583, 294, 257, 636, 411, 2699, 76, 534, 264, 551, 300, 2699, 76, 307, 257, 1864, 468, 466, 307, 34382, 13], "temperature": 0.0, "avg_logprob": -0.20247316934976234, "compression_ratio": 1.7470588235294118, "no_speech_prob": 4.9832342483568937e-05}, {"id": 437, "seek": 360300, "start": 3620.0, "end": 3629.0, "text": " And Haskell is like less of a purist about that, but maybe more of a purist about like category theory.", "tokens": [400, 8646, 43723, 307, 411, 1570, 295, 257, 1864, 468, 466, 300, 11, 457, 1310, 544, 295, 257, 1864, 468, 466, 411, 7719, 5261, 13], "temperature": 0.0, "avg_logprob": -0.20247316934976234, "compression_ratio": 1.7470588235294118, "no_speech_prob": 4.9832342483568937e-05}, {"id": 438, "seek": 362900, "start": 3629.0, "end": 3634.0, "text": " I mean, I guess to some extent, if it's roots in academia, right.", "tokens": [286, 914, 11, 286, 2041, 281, 512, 8396, 11, 498, 309, 311, 10669, 294, 28937, 11, 558, 13], "temperature": 0.0, "avg_logprob": -0.23977284150965072, "compression_ratio": 1.6439024390243901, "no_speech_prob": 8.139166311593726e-06}, {"id": 439, "seek": 362900, "start": 3634.0, "end": 3640.0, "text": " And researchers, they try to design a language with language extensions.", "tokens": [400, 10309, 11, 436, 853, 281, 1715, 257, 2856, 365, 2856, 25129, 13], "temperature": 0.0, "avg_logprob": -0.23977284150965072, "compression_ratio": 1.6439024390243901, "no_speech_prob": 8.139166311593726e-06}, {"id": 440, "seek": 362900, "start": 3640.0, "end": 3643.0, "text": " Well, they don't have to think about all the edge cases.", "tokens": [1042, 11, 436, 500, 380, 362, 281, 519, 466, 439, 264, 4691, 3331, 13], "temperature": 0.0, "avg_logprob": -0.23977284150965072, "compression_ratio": 1.6439024390243901, "no_speech_prob": 8.139166311593726e-06}, {"id": 441, "seek": 362900, "start": 3643.0, "end": 3650.0, "text": " They care mostly about some area of computation of some area of research.", "tokens": [814, 1127, 5240, 466, 512, 1859, 295, 24903, 295, 512, 1859, 295, 2132, 13], "temperature": 0.0, "avg_logprob": -0.23977284150965072, "compression_ratio": 1.6439024390243901, "no_speech_prob": 8.139166311593726e-06}, {"id": 442, "seek": 362900, "start": 3650.0, "end": 3654.0, "text": " And whether you handle all the edge cases is doesn't really matter.", "tokens": [400, 1968, 291, 4813, 439, 264, 4691, 3331, 307, 1177, 380, 534, 1871, 13], "temperature": 0.0, "avg_logprob": -0.23977284150965072, "compression_ratio": 1.6439024390243901, "no_speech_prob": 8.139166311593726e-06}, {"id": 443, "seek": 365400, "start": 3654.0, "end": 3664.0, "text": " So it's fine to have a few undefined in a language if you're only trying to to figure out to answer a specific question where this is not going to happen.", "tokens": [407, 309, 311, 2489, 281, 362, 257, 1326, 674, 5666, 2001, 294, 257, 2856, 498, 291, 434, 787, 1382, 281, 281, 2573, 484, 281, 1867, 257, 2685, 1168, 689, 341, 307, 406, 516, 281, 1051, 13], "temperature": 0.0, "avg_logprob": -0.21891749483867756, "compression_ratio": 1.562992125984252, "no_speech_prob": 5.649179729516618e-05}, {"id": 444, "seek": 365400, "start": 3664.0, "end": 3670.0, "text": " And Elm is really more pragmatic or meant for production.", "tokens": [400, 2699, 76, 307, 534, 544, 46904, 420, 4140, 337, 4265, 13], "temperature": 0.0, "avg_logprob": -0.21891749483867756, "compression_ratio": 1.562992125984252, "no_speech_prob": 5.649179729516618e-05}, {"id": 445, "seek": 365400, "start": 3670.0, "end": 3679.0, "text": " So it makes sense that we have it there, though, I guess some people would say, well, if you can't just call JavaScript through FFI, then you're not very pragmatic.", "tokens": [407, 309, 1669, 2020, 300, 321, 362, 309, 456, 11, 1673, 11, 286, 2041, 512, 561, 576, 584, 11, 731, 11, 498, 291, 393, 380, 445, 818, 15778, 807, 479, 38568, 11, 550, 291, 434, 406, 588, 46904, 13], "temperature": 0.0, "avg_logprob": -0.21891749483867756, "compression_ratio": 1.562992125984252, "no_speech_prob": 5.649179729516618e-05}, {"id": 446, "seek": 365400, "start": 3679.0, "end": 3682.0, "text": " But that's a topic.", "tokens": [583, 300, 311, 257, 4829, 13], "temperature": 0.0, "avg_logprob": -0.21891749483867756, "compression_ratio": 1.562992125984252, "no_speech_prob": 5.649179729516618e-05}, {"id": 447, "seek": 368200, "start": 3682.0, "end": 3693.0, "text": " Yeah. Also, I think there is some kind of check in the Elm package registry that prevents you from publishing code with debug.to on it.", "tokens": [865, 13, 2743, 11, 286, 519, 456, 307, 512, 733, 295, 1520, 294, 264, 2699, 76, 7372, 36468, 300, 22367, 291, 490, 17832, 3089, 365, 24083, 13, 1353, 322, 309, 13], "temperature": 0.0, "avg_logprob": -0.26127007742908515, "compression_ratio": 1.5153846153846153, "no_speech_prob": 1.9522487491485663e-05}, {"id": 448, "seek": 368200, "start": 3693.0, "end": 3696.0, "text": " Right. So it's not happening, basically.", "tokens": [1779, 13, 407, 309, 311, 406, 2737, 11, 1936, 13], "temperature": 0.0, "avg_logprob": -0.26127007742908515, "compression_ratio": 1.5153846153846153, "no_speech_prob": 1.9522487491485663e-05}, {"id": 449, "seek": 368200, "start": 3696.0, "end": 3699.0, "text": " So there are security guards against that.", "tokens": [407, 456, 366, 3825, 17652, 1970, 300, 13], "temperature": 0.0, "avg_logprob": -0.26127007742908515, "compression_ratio": 1.5153846153846153, "no_speech_prob": 1.9522487491485663e-05}, {"id": 450, "seek": 368200, "start": 3699.0, "end": 3700.0, "text": " Yeah. Thankfully.", "tokens": [865, 13, 28344, 13], "temperature": 0.0, "avg_logprob": -0.26127007742908515, "compression_ratio": 1.5153846153846153, "no_speech_prob": 1.9522487491485663e-05}, {"id": 451, "seek": 368200, "start": 3700.0, "end": 3703.0, "text": " I don't know when it appeared, though. I'm guessing it was pretty recent.", "tokens": [286, 500, 380, 458, 562, 309, 8516, 11, 1673, 13, 286, 478, 17939, 309, 390, 1238, 5162, 13], "temperature": 0.0, "avg_logprob": -0.26127007742908515, "compression_ratio": 1.5153846153846153, "no_speech_prob": 1.9522487491485663e-05}, {"id": 452, "seek": 368200, "start": 3703.0, "end": 3710.0, "text": " But because you could at least have applications with debug.crash in 0.18 or 0.17.", "tokens": [583, 570, 291, 727, 412, 1935, 362, 5821, 365, 24083, 13, 10757, 1299, 294, 1958, 13, 6494, 420, 1958, 13, 7773, 13], "temperature": 0.0, "avg_logprob": -0.26127007742908515, "compression_ratio": 1.5153846153846153, "no_speech_prob": 1.9522487491485663e-05}, {"id": 453, "seek": 371000, "start": 3710.0, "end": 3713.0, "text": " Right. Yeah, I remember that, actually.", "tokens": [1779, 13, 865, 11, 286, 1604, 300, 11, 767, 13], "temperature": 0.0, "avg_logprob": -0.24143589626659046, "compression_ratio": 1.5235849056603774, "no_speech_prob": 5.063103890279308e-05}, {"id": 454, "seek": 371000, "start": 3713.0, "end": 3718.0, "text": " Yeah. But I don't know if you could have them in packages. That I don't remember.", "tokens": [865, 13, 583, 286, 500, 380, 458, 498, 291, 727, 362, 552, 294, 17401, 13, 663, 286, 500, 380, 1604, 13], "temperature": 0.0, "avg_logprob": -0.24143589626659046, "compression_ratio": 1.5235849056603774, "no_speech_prob": 5.063103890279308e-05}, {"id": 455, "seek": 371000, "start": 3718.0, "end": 3723.0, "text": " I was worried about it because recently I contributed to Elm format.", "tokens": [286, 390, 5804, 466, 309, 570, 3938, 286, 18434, 281, 2699, 76, 7877, 13], "temperature": 0.0, "avg_logprob": -0.24143589626659046, "compression_ratio": 1.5235849056603774, "no_speech_prob": 5.063103890279308e-05}, {"id": 456, "seek": 371000, "start": 3723.0, "end": 3726.0, "text": " I added a few linear parser things.", "tokens": [286, 3869, 257, 1326, 8213, 21156, 260, 721, 13], "temperature": 0.0, "avg_logprob": -0.24143589626659046, "compression_ratio": 1.5235849056603774, "no_speech_prob": 5.063103890279308e-05}, {"id": 457, "seek": 371000, "start": 3726.0, "end": 3734.0, "text": " And then someone told me, hey, you are parsing this fat arrow into this slim arrow lambda thing.", "tokens": [400, 550, 1580, 1907, 385, 11, 4177, 11, 291, 366, 21156, 278, 341, 4046, 11610, 666, 341, 25357, 11610, 13607, 551, 13], "temperature": 0.0, "avg_logprob": -0.24143589626659046, "compression_ratio": 1.5235849056603774, "no_speech_prob": 5.063103890279308e-05}, {"id": 458, "seek": 373400, "start": 3734.0, "end": 3740.0, "text": " But prior to Elm 19, someone could have an infix operator being a fat arrow.", "tokens": [583, 4059, 281, 2699, 76, 1294, 11, 1580, 727, 362, 364, 1536, 970, 12973, 885, 257, 4046, 11610, 13], "temperature": 0.0, "avg_logprob": -0.191195718173323, "compression_ratio": 1.4337899543378996, "no_speech_prob": 0.00015335904026869684}, {"id": 459, "seek": 373400, "start": 3740.0, "end": 3750.0, "text": " And I was so scared about my PR not being correct, because the only version of Elm I've used is just 0.19 onwards.", "tokens": [400, 286, 390, 370, 5338, 466, 452, 11568, 406, 885, 3006, 11, 570, 264, 787, 3037, 295, 2699, 76, 286, 600, 1143, 307, 445, 1958, 13, 3405, 34230, 13], "temperature": 0.0, "avg_logprob": -0.191195718173323, "compression_ratio": 1.4337899543378996, "no_speech_prob": 0.00015335904026869684}, {"id": 460, "seek": 373400, "start": 3750.0, "end": 3760.0, "text": " And it's like, wow. So I really do need to extend now my PR and add a test for this specific case that I wasn't expecting.", "tokens": [400, 309, 311, 411, 11, 6076, 13, 407, 286, 534, 360, 643, 281, 10101, 586, 452, 11568, 293, 909, 257, 1500, 337, 341, 2685, 1389, 300, 286, 2067, 380, 9650, 13], "temperature": 0.0, "avg_logprob": -0.191195718173323, "compression_ratio": 1.4337899543378996, "no_speech_prob": 0.00015335904026869684}, {"id": 461, "seek": 376000, "start": 3760.0, "end": 3766.0, "text": " I remember the convention was to define the fat arrow as creating a tuple.", "tokens": [286, 1604, 264, 10286, 390, 281, 6964, 264, 4046, 11610, 382, 4084, 257, 2604, 781, 13], "temperature": 0.0, "avg_logprob": -0.23824312269073172, "compression_ratio": 1.8586387434554974, "no_speech_prob": 1.863050420070067e-05}, {"id": 462, "seek": 376000, "start": 3766.0, "end": 3769.0, "text": " So you could have key value pairs.", "tokens": [407, 291, 727, 362, 2141, 2158, 15494, 13], "temperature": 0.0, "avg_logprob": -0.23824312269073172, "compression_ratio": 1.8586387434554974, "no_speech_prob": 1.863050420070067e-05}, {"id": 463, "seek": 376000, "start": 3769.0, "end": 3777.0, "text": " And instead of doing, you know, like if you did dict from list with a literal list,", "tokens": [400, 2602, 295, 884, 11, 291, 458, 11, 411, 498, 291, 630, 12569, 490, 1329, 365, 257, 20411, 1329, 11], "temperature": 0.0, "avg_logprob": -0.23824312269073172, "compression_ratio": 1.8586387434554974, "no_speech_prob": 1.863050420070067e-05}, {"id": 464, "seek": 376000, "start": 3777.0, "end": 3788.0, "text": " and then you give a list of tuples, instead of doing dict from list, a list with tuple, some value, comma, some value, next tuple, some value, comma, some value,", "tokens": [293, 550, 291, 976, 257, 1329, 295, 2604, 2622, 11, 2602, 295, 884, 12569, 490, 1329, 11, 257, 1329, 365, 2604, 781, 11, 512, 2158, 11, 22117, 11, 512, 2158, 11, 958, 2604, 781, 11, 512, 2158, 11, 22117, 11, 512, 2158, 11], "temperature": 0.0, "avg_logprob": -0.23824312269073172, "compression_ratio": 1.8586387434554974, "no_speech_prob": 1.863050420070067e-05}, {"id": 465, "seek": 378800, "start": 3788.0, "end": 3798.0, "text": " you would do list value, fat arrow value, comma, key, fat arrow value.", "tokens": [291, 576, 360, 1329, 2158, 11, 4046, 11610, 2158, 11, 22117, 11, 2141, 11, 4046, 11610, 2158, 13], "temperature": 0.0, "avg_logprob": -0.3125827478808026, "compression_ratio": 1.586021505376344, "no_speech_prob": 4.9076661525759846e-05}, {"id": 466, "seek": 378800, "start": 3798.0, "end": 3799.0, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.3125827478808026, "compression_ratio": 1.586021505376344, "no_speech_prob": 4.9076661525759846e-05}, {"id": 467, "seek": 378800, "start": 3799.0, "end": 3801.0, "text": " So it would be like tuple.pair?", "tokens": [407, 309, 576, 312, 411, 2604, 781, 13, 79, 1246, 30], "temperature": 0.0, "avg_logprob": -0.3125827478808026, "compression_ratio": 1.586021505376344, "no_speech_prob": 4.9076661525759846e-05}, {"id": 468, "seek": 378800, "start": 3801.0, "end": 3804.0, "text": " Yep, it was exactly like that.", "tokens": [7010, 11, 309, 390, 2293, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.3125827478808026, "compression_ratio": 1.586021505376344, "no_speech_prob": 4.9076661525759846e-05}, {"id": 469, "seek": 378800, "start": 3804.0, "end": 3810.0, "text": " Wasn't there like the daughter sign for the same purpose?", "tokens": [28782, 380, 456, 411, 264, 4653, 1465, 337, 264, 912, 4334, 30], "temperature": 0.0, "avg_logprob": -0.3125827478808026, "compression_ratio": 1.586021505376344, "no_speech_prob": 4.9076661525759846e-05}, {"id": 470, "seek": 378800, "start": 3810.0, "end": 3816.0, "text": " Like, I remember that people did a model daughter sign command at none or something, quite a lot.", "tokens": [1743, 11, 286, 1604, 300, 561, 630, 257, 2316, 4653, 1465, 5622, 412, 6022, 420, 746, 11, 1596, 257, 688, 13], "temperature": 0.0, "avg_logprob": -0.3125827478808026, "compression_ratio": 1.586021505376344, "no_speech_prob": 4.9076661525759846e-05}, {"id": 471, "seek": 381600, "start": 3816.0, "end": 3819.0, "text": " Oh, gosh, I'd forgotten about that.", "tokens": [876, 11, 6502, 11, 286, 1116, 11832, 466, 300, 13], "temperature": 0.0, "avg_logprob": -0.21443044222318208, "compression_ratio": 1.5833333333333333, "no_speech_prob": 3.64775478374213e-05}, {"id": 472, "seek": 381600, "start": 3819.0, "end": 3822.0, "text": " It's completely left my memory now.", "tokens": [467, 311, 2584, 1411, 452, 4675, 586, 13], "temperature": 0.0, "avg_logprob": -0.21443044222318208, "compression_ratio": 1.5833333333333333, "no_speech_prob": 3.64775478374213e-05}, {"id": 473, "seek": 381600, "start": 3822.0, "end": 3827.0, "text": " But there was something about getting something with no command or whatever.", "tokens": [583, 456, 390, 746, 466, 1242, 746, 365, 572, 5622, 420, 2035, 13], "temperature": 0.0, "avg_logprob": -0.21443044222318208, "compression_ratio": 1.5833333333333333, "no_speech_prob": 3.64775478374213e-05}, {"id": 474, "seek": 381600, "start": 3827.0, "end": 3828.0, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.21443044222318208, "compression_ratio": 1.5833333333333333, "no_speech_prob": 3.64775478374213e-05}, {"id": 475, "seek": 381600, "start": 3828.0, "end": 3837.0, "text": " Actually, I think, Flavio, in one of your blog posts, you say something like, oh, in Haskell, you can use the comma operator to make a tuple.", "tokens": [5135, 11, 286, 519, 11, 3235, 706, 1004, 11, 294, 472, 295, 428, 6968, 12300, 11, 291, 584, 746, 411, 11, 1954, 11, 294, 8646, 43723, 11, 291, 393, 764, 264, 22117, 12973, 281, 652, 257, 2604, 781, 13], "temperature": 0.0, "avg_logprob": -0.21443044222318208, "compression_ratio": 1.5833333333333333, "no_speech_prob": 3.64775478374213e-05}, {"id": 476, "seek": 381600, "start": 3837.0, "end": 3841.0, "text": " Well, I think it was there in Elm, and it was the daughter sign,", "tokens": [1042, 11, 286, 519, 309, 390, 456, 294, 2699, 76, 11, 293, 309, 390, 264, 4653, 1465, 11], "temperature": 0.0, "avg_logprob": -0.21443044222318208, "compression_ratio": 1.5833333333333333, "no_speech_prob": 3.64775478374213e-05}, {"id": 477, "seek": 384100, "start": 3841.0, "end": 3848.0, "text": " which I guess was even more confusing for people who use Haskell because the daughter sign is something very different.", "tokens": [597, 286, 2041, 390, 754, 544, 13181, 337, 561, 567, 764, 8646, 43723, 570, 264, 4653, 1465, 307, 746, 588, 819, 13], "temperature": 0.0, "avg_logprob": -0.2554357721564475, "compression_ratio": 1.555, "no_speech_prob": 4.0601160435471684e-05}, {"id": 478, "seek": 384100, "start": 3848.0, "end": 3852.0, "text": " I think it's the function composition.", "tokens": [286, 519, 309, 311, 264, 2445, 12686, 13], "temperature": 0.0, "avg_logprob": -0.2554357721564475, "compression_ratio": 1.555, "no_speech_prob": 4.0601160435471684e-05}, {"id": 479, "seek": 384100, "start": 3852.0, "end": 3855.0, "text": " The daughter sign is the left pipe in Elm.", "tokens": [440, 4653, 1465, 307, 264, 1411, 11240, 294, 2699, 76, 13], "temperature": 0.0, "avg_logprob": -0.2554357721564475, "compression_ratio": 1.555, "no_speech_prob": 4.0601160435471684e-05}, {"id": 480, "seek": 384100, "start": 3855.0, "end": 3856.0, "text": " Oh, it's a pipe, yeah.", "tokens": [876, 11, 309, 311, 257, 11240, 11, 1338, 13], "temperature": 0.0, "avg_logprob": -0.2554357721564475, "compression_ratio": 1.555, "no_speech_prob": 4.0601160435471684e-05}, {"id": 481, "seek": 384100, "start": 3856.0, "end": 3858.0, "text": " Yeah, daughter is used a lot.", "tokens": [865, 11, 4653, 307, 1143, 257, 688, 13], "temperature": 0.0, "avg_logprob": -0.2554357721564475, "compression_ratio": 1.555, "no_speech_prob": 4.0601160435471684e-05}, {"id": 482, "seek": 384100, "start": 3858.0, "end": 3859.0, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.2554357721564475, "compression_ratio": 1.555, "no_speech_prob": 4.0601160435471684e-05}, {"id": 483, "seek": 384100, "start": 3859.0, "end": 3861.0, "text": " To prevent the usage of parentheses.", "tokens": [1407, 4871, 264, 14924, 295, 34153, 13], "temperature": 0.0, "avg_logprob": -0.2554357721564475, "compression_ratio": 1.555, "no_speech_prob": 4.0601160435471684e-05}, {"id": 484, "seek": 384100, "start": 3861.0, "end": 3863.0, "text": " Right, right.", "tokens": [1779, 11, 558, 13], "temperature": 0.0, "avg_logprob": -0.2554357721564475, "compression_ratio": 1.555, "no_speech_prob": 4.0601160435471684e-05}, {"id": 485, "seek": 386300, "start": 3863.0, "end": 3872.0, "text": " Yeah, and there also used to be the parentheses comma parentheses operator to create a tuple in Elm.", "tokens": [865, 11, 293, 456, 611, 1143, 281, 312, 264, 34153, 22117, 34153, 12973, 281, 1884, 257, 2604, 781, 294, 2699, 76, 13], "temperature": 0.0, "avg_logprob": -0.23864964936908922, "compression_ratio": 1.6, "no_speech_prob": 6.048670456948457e-06}, {"id": 486, "seek": 386300, "start": 3872.0, "end": 3873.0, "text": " As well?", "tokens": [1018, 731, 30], "temperature": 0.0, "avg_logprob": -0.23864964936908922, "compression_ratio": 1.6, "no_speech_prob": 6.048670456948457e-06}, {"id": 487, "seek": 386300, "start": 3873.0, "end": 3876.0, "text": " Or with two commas to create a triple.", "tokens": [1610, 365, 732, 800, 296, 281, 1884, 257, 15508, 13], "temperature": 0.0, "avg_logprob": -0.23864964936908922, "compression_ratio": 1.6, "no_speech_prob": 6.048670456948457e-06}, {"id": 488, "seek": 386300, "start": 3876.0, "end": 3877.0, "text": " Hmm.", "tokens": [8239, 13], "temperature": 0.0, "avg_logprob": -0.23864964936908922, "compression_ratio": 1.6, "no_speech_prob": 6.048670456948457e-06}, {"id": 489, "seek": 386300, "start": 3877.0, "end": 3879.0, "text": " That used to be there, and now it's tupled up here.", "tokens": [663, 1143, 281, 312, 456, 11, 293, 586, 309, 311, 2604, 15551, 493, 510, 13], "temperature": 0.0, "avg_logprob": -0.23864964936908922, "compression_ratio": 1.6, "no_speech_prob": 6.048670456948457e-06}, {"id": 490, "seek": 386300, "start": 3879.0, "end": 3887.0, "text": " But yeah, so all these things, I mean, it is a very different, like, what makes idiomatic Haskell is so different.", "tokens": [583, 1338, 11, 370, 439, 613, 721, 11, 286, 914, 11, 309, 307, 257, 588, 819, 11, 411, 11, 437, 1669, 18014, 13143, 8646, 43723, 307, 370, 819, 13], "temperature": 0.0, "avg_logprob": -0.23864964936908922, "compression_ratio": 1.6, "no_speech_prob": 6.048670456948457e-06}, {"id": 491, "seek": 388700, "start": 3887.0, "end": 3895.0, "text": " And it definitely seems like in the Haskell ecosystem, people really like being able to express things tersely with operators.", "tokens": [400, 309, 2138, 2544, 411, 294, 264, 8646, 43723, 11311, 11, 561, 534, 411, 885, 1075, 281, 5109, 721, 256, 433, 736, 365, 19077, 13], "temperature": 0.0, "avg_logprob": -0.19108479817708332, "compression_ratio": 1.3670886075949367, "no_speech_prob": 1.653631443332415e-06}, {"id": 492, "seek": 388700, "start": 3895.0, "end": 3898.0, "text": " And in Elm, we shy away from that.", "tokens": [400, 294, 2699, 76, 11, 321, 12685, 1314, 490, 300, 13], "temperature": 0.0, "avg_logprob": -0.19108479817708332, "compression_ratio": 1.3670886075949367, "no_speech_prob": 1.653631443332415e-06}, {"id": 493, "seek": 388700, "start": 3898.0, "end": 3901.0, "text": " Yeah, we don't use those Greek letters as well.", "tokens": [865, 11, 321, 500, 380, 764, 729, 10281, 7825, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.19108479817708332, "compression_ratio": 1.3670886075949367, "no_speech_prob": 1.653631443332415e-06}, {"id": 494, "seek": 388700, "start": 3901.0, "end": 3904.0, "text": " Right.", "tokens": [1779, 13], "temperature": 0.0, "avg_logprob": -0.19108479817708332, "compression_ratio": 1.3670886075949367, "no_speech_prob": 1.653631443332415e-06}, {"id": 495, "seek": 390400, "start": 3904.0, "end": 3923.0, "text": " One thing you mentioned in your blog post on Functors Flavio is about function composition and about how any chain of list.map with functions or any sort of chain of maps can be turned into a single map with the composition operator.", "tokens": [1485, 551, 291, 2835, 294, 428, 6968, 2183, 322, 11166, 5547, 3235, 706, 1004, 307, 466, 2445, 12686, 293, 466, 577, 604, 5021, 295, 1329, 13, 24223, 365, 6828, 420, 604, 1333, 295, 5021, 295, 11317, 393, 312, 3574, 666, 257, 2167, 4471, 365, 264, 12686, 12973, 13], "temperature": 0.0, "avg_logprob": -0.24213950241668314, "compression_ratio": 1.8297872340425532, "no_speech_prob": 1.39511776069412e-05}, {"id": 496, "seek": 390400, "start": 3923.0, "end": 3929.0, "text": " Like greater than, greater than operator, or less than, less than operator, if you're into that sort of thing.", "tokens": [1743, 5044, 813, 11, 5044, 813, 12973, 11, 420, 1570, 813, 11, 1570, 813, 12973, 11, 498, 291, 434, 666, 300, 1333, 295, 551, 13], "temperature": 0.0, "avg_logprob": -0.24213950241668314, "compression_ratio": 1.8297872340425532, "no_speech_prob": 1.39511776069412e-05}, {"id": 497, "seek": 392900, "start": 3929.0, "end": 3938.0, "text": " But some people in Elm I've noticed shy away from the composition operator.", "tokens": [583, 512, 561, 294, 2699, 76, 286, 600, 5694, 12685, 1314, 490, 264, 12686, 12973, 13], "temperature": 0.0, "avg_logprob": -0.19673489361274532, "compression_ratio": 1.45662100456621, "no_speech_prob": 0.00019046358647756279}, {"id": 498, "seek": 392900, "start": 3938.0, "end": 3945.0, "text": " And sometimes I myself find it difficult to reason about things in a pipeline versus a lambda.", "tokens": [400, 2171, 286, 2059, 915, 309, 2252, 281, 1778, 466, 721, 294, 257, 15517, 5717, 257, 13607, 13], "temperature": 0.0, "avg_logprob": -0.19673489361274532, "compression_ratio": 1.45662100456621, "no_speech_prob": 0.00019046358647756279}, {"id": 499, "seek": 392900, "start": 3945.0, "end": 3948.0, "text": " So I'll opt for doing a lambda.", "tokens": [407, 286, 603, 2427, 337, 884, 257, 13607, 13], "temperature": 0.0, "avg_logprob": -0.19673489361274532, "compression_ratio": 1.45662100456621, "no_speech_prob": 0.00019046358647756279}, {"id": 500, "seek": 392900, "start": 3948.0, "end": 3952.0, "text": " What are your thoughts on this sort of like point-free style?", "tokens": [708, 366, 428, 4598, 322, 341, 1333, 295, 411, 935, 12, 10792, 3758, 30], "temperature": 0.0, "avg_logprob": -0.19673489361274532, "compression_ratio": 1.45662100456621, "no_speech_prob": 0.00019046358647756279}, {"id": 501, "seek": 392900, "start": 3952.0, "end": 3955.0, "text": " From what I understand, that's very common in Haskell.", "tokens": [3358, 437, 286, 1223, 11, 300, 311, 588, 2689, 294, 8646, 43723, 13], "temperature": 0.0, "avg_logprob": -0.19673489361274532, "compression_ratio": 1.45662100456621, "no_speech_prob": 0.00019046358647756279}, {"id": 502, "seek": 395500, "start": 3955.0, "end": 3963.0, "text": " Yeah, even within Haskell, there is like a fight, you know, that people prefer Terrace programming or Taft programming.", "tokens": [865, 11, 754, 1951, 8646, 43723, 11, 456, 307, 411, 257, 2092, 11, 291, 458, 11, 300, 561, 4382, 314, 260, 81, 617, 9410, 420, 314, 2792, 83, 9410, 13], "temperature": 0.0, "avg_logprob": -0.24070491393407187, "compression_ratio": 1.561904761904762, "no_speech_prob": 0.0023852845188230276}, {"id": 503, "seek": 395500, "start": 3963.0, "end": 3966.0, "text": " Some of them prefer point-free and some of them don't.", "tokens": [2188, 295, 552, 4382, 935, 12, 10792, 293, 512, 295, 552, 500, 380, 13], "temperature": 0.0, "avg_logprob": -0.24070491393407187, "compression_ratio": 1.561904761904762, "no_speech_prob": 0.0023852845188230276}, {"id": 504, "seek": 395500, "start": 3966.0, "end": 3969.0, "text": " But personally, I'm a bit of a point-free freak.", "tokens": [583, 5665, 11, 286, 478, 257, 857, 295, 257, 935, 12, 10792, 21853, 13], "temperature": 0.0, "avg_logprob": -0.24070491393407187, "compression_ratio": 1.561904761904762, "no_speech_prob": 0.0023852845188230276}, {"id": 505, "seek": 395500, "start": 3969.0, "end": 3974.0, "text": " So I need to refrain myself from using too much point-free code.", "tokens": [407, 286, 643, 281, 46177, 2059, 490, 1228, 886, 709, 935, 12, 10792, 3089, 13], "temperature": 0.0, "avg_logprob": -0.24070491393407187, "compression_ratio": 1.561904761904762, "no_speech_prob": 0.0023852845188230276}, {"id": 506, "seek": 395500, "start": 3974.0, "end": 3976.0, "text": " And I have this issue with Elm as well.", "tokens": [400, 286, 362, 341, 2734, 365, 2699, 76, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.24070491393407187, "compression_ratio": 1.561904761904762, "no_speech_prob": 0.0023852845188230276}, {"id": 507, "seek": 397600, "start": 3976.0, "end": 3988.0, "text": " So I reach for the composition operators very often, and only when I get some complaints from my Elm colleagues saying this is unreadable or this is not maintainable or blah, blah, blah.", "tokens": [407, 286, 2524, 337, 264, 12686, 19077, 588, 2049, 11, 293, 787, 562, 286, 483, 512, 19585, 490, 452, 2699, 76, 7734, 1566, 341, 307, 517, 2538, 712, 420, 341, 307, 406, 6909, 712, 420, 12288, 11, 12288, 11, 12288, 13], "temperature": 0.0, "avg_logprob": -0.2512131996874539, "compression_ratio": 1.6264150943396227, "no_speech_prob": 0.00041938366484828293}, {"id": 508, "seek": 397600, "start": 3988.0, "end": 3991.0, "text": " Then I will change the code to use Python, for example.", "tokens": [1396, 286, 486, 1319, 264, 3089, 281, 764, 9953, 392, 266, 11, 337, 1365, 13], "temperature": 0.0, "avg_logprob": -0.2512131996874539, "compression_ratio": 1.6264150943396227, "no_speech_prob": 0.00041938366484828293}, {"id": 509, "seek": 397600, "start": 3991.0, "end": 4003.0, "text": " But yeah, the thing I wanted to say or to convey in my post that I think I a little bit failed is when you cannot talk about functors or applicatives or monads without speaking about laws.", "tokens": [583, 1338, 11, 264, 551, 286, 1415, 281, 584, 420, 281, 16965, 294, 452, 2183, 300, 286, 519, 286, 257, 707, 857, 7612, 307, 562, 291, 2644, 751, 466, 1019, 5547, 420, 2580, 4884, 420, 1108, 5834, 1553, 4124, 466, 6064, 13], "temperature": 0.0, "avg_logprob": -0.2512131996874539, "compression_ratio": 1.6264150943396227, "no_speech_prob": 0.00041938366484828293}, {"id": 510, "seek": 400300, "start": 4003.0, "end": 4006.0, "text": " So they must fulfill certain laws.", "tokens": [407, 436, 1633, 13875, 1629, 6064, 13], "temperature": 0.0, "avg_logprob": -0.1905039459911745, "compression_ratio": 1.6022727272727273, "no_speech_prob": 0.00011018219083780423}, {"id": 511, "seek": 400300, "start": 4006.0, "end": 4011.0, "text": " And one of the very simple laws for functors is that they need to preserve composition.", "tokens": [400, 472, 295, 264, 588, 2199, 6064, 337, 1019, 5547, 307, 300, 436, 643, 281, 15665, 12686, 13], "temperature": 0.0, "avg_logprob": -0.1905039459911745, "compression_ratio": 1.6022727272727273, "no_speech_prob": 0.00011018219083780423}, {"id": 512, "seek": 400300, "start": 4011.0, "end": 4019.0, "text": " So if you compose things that do nothing, for example, if you compose with the identity function, nothing should happen.", "tokens": [407, 498, 291, 35925, 721, 300, 360, 1825, 11, 337, 1365, 11, 498, 291, 35925, 365, 264, 6575, 2445, 11, 1825, 820, 1051, 13], "temperature": 0.0, "avg_logprob": -0.1905039459911745, "compression_ratio": 1.6022727272727273, "no_speech_prob": 0.00011018219083780423}, {"id": 513, "seek": 400300, "start": 4019.0, "end": 4022.0, "text": " It's equal to doing basically nothing.", "tokens": [467, 311, 2681, 281, 884, 1936, 1825, 13], "temperature": 0.0, "avg_logprob": -0.1905039459911745, "compression_ratio": 1.6022727272727273, "no_speech_prob": 0.00011018219083780423}, {"id": 514, "seek": 402200, "start": 4022.0, "end": 4034.0, "text": " And this little law is what makes possible that you can either map n times or just compose n times and then map once, which in JavaScript tends to be like a performance optimization.", "tokens": [400, 341, 707, 2101, 307, 437, 1669, 1944, 300, 291, 393, 2139, 4471, 297, 1413, 420, 445, 35925, 297, 1413, 293, 550, 4471, 1564, 11, 597, 294, 15778, 12258, 281, 312, 411, 257, 3389, 19618, 13], "temperature": 0.0, "avg_logprob": -0.19888756491921164, "compression_ratio": 1.6134453781512605, "no_speech_prob": 2.6680312657845207e-05}, {"id": 515, "seek": 402200, "start": 4034.0, "end": 4038.0, "text": " But it depends on how your language implements these things.", "tokens": [583, 309, 5946, 322, 577, 428, 2856, 704, 17988, 613, 721, 13], "temperature": 0.0, "avg_logprob": -0.19888756491921164, "compression_ratio": 1.6134453781512605, "no_speech_prob": 2.6680312657845207e-05}, {"id": 516, "seek": 402200, "start": 4038.0, "end": 4040.0, "text": " Right. Right.", "tokens": [1779, 13, 1779, 13], "temperature": 0.0, "avg_logprob": -0.19888756491921164, "compression_ratio": 1.6134453781512605, "no_speech_prob": 2.6680312657845207e-05}, {"id": 517, "seek": 402200, "start": 4040.0, "end": 4049.0, "text": " So what would be your pitch to somebody to consider using point-free style or something closer to point-free style more often?", "tokens": [407, 437, 576, 312, 428, 7293, 281, 2618, 281, 1949, 1228, 935, 12, 10792, 3758, 420, 746, 4966, 281, 935, 12, 10792, 3758, 544, 2049, 30], "temperature": 0.0, "avg_logprob": -0.19888756491921164, "compression_ratio": 1.6134453781512605, "no_speech_prob": 2.6680312657845207e-05}, {"id": 518, "seek": 404900, "start": 4049.0, "end": 4054.0, "text": " Well, it depends on the case by case scenario.", "tokens": [1042, 11, 309, 5946, 322, 264, 1389, 538, 1389, 9005, 13], "temperature": 0.0, "avg_logprob": -0.18776661157608032, "compression_ratio": 1.5195530726256983, "no_speech_prob": 0.0001071159858838655}, {"id": 519, "seek": 404900, "start": 4054.0, "end": 4068.0, "text": " But, for example, when you're using mapping functions or functions that return a Boolean, like in a condition to some other function, sometimes I feel like by adding a lambda with an extra argument adds a little bit of noise.", "tokens": [583, 11, 337, 1365, 11, 562, 291, 434, 1228, 18350, 6828, 420, 6828, 300, 2736, 257, 23351, 28499, 11, 411, 294, 257, 4188, 281, 512, 661, 2445, 11, 2171, 286, 841, 411, 538, 5127, 257, 13607, 365, 364, 2857, 6770, 10860, 257, 707, 857, 295, 5658, 13], "temperature": 0.0, "avg_logprob": -0.18776661157608032, "compression_ratio": 1.5195530726256983, "no_speech_prob": 0.0001071159858838655}, {"id": 520, "seek": 406800, "start": 4068.0, "end": 4080.0, "text": " And if you get used to composition and you, for example, in Elm, the composition operators read really nicely because you can either do left to right composition or right to left composition.", "tokens": [400, 498, 291, 483, 1143, 281, 12686, 293, 291, 11, 337, 1365, 11, 294, 2699, 76, 11, 264, 12686, 19077, 1401, 534, 9594, 570, 291, 393, 2139, 360, 1411, 281, 558, 12686, 420, 558, 281, 1411, 12686, 13], "temperature": 0.0, "avg_logprob": -0.1832453075208162, "compression_ratio": 1.9518072289156627, "no_speech_prob": 0.0001532632450107485}, {"id": 521, "seek": 406800, "start": 4080.0, "end": 4088.0, "text": " And when you see the functions, you clearly you can read in the code, oh, we are running this function, then the next one and then the next one.", "tokens": [400, 562, 291, 536, 264, 6828, 11, 291, 4448, 291, 393, 1401, 294, 264, 3089, 11, 1954, 11, 321, 366, 2614, 341, 2445, 11, 550, 264, 958, 472, 293, 550, 264, 958, 472, 13], "temperature": 0.0, "avg_logprob": -0.1832453075208162, "compression_ratio": 1.9518072289156627, "no_speech_prob": 0.0001532632450107485}, {"id": 522, "seek": 406800, "start": 4088.0, "end": 4096.0, "text": " And I don't really care what the name of the argument or of the lambda is, because I just don't care because it's a function that expects a function.", "tokens": [400, 286, 500, 380, 534, 1127, 437, 264, 1315, 295, 264, 6770, 420, 295, 264, 13607, 307, 11, 570, 286, 445, 500, 380, 1127, 570, 309, 311, 257, 2445, 300, 33280, 257, 2445, 13], "temperature": 0.0, "avg_logprob": -0.1832453075208162, "compression_ratio": 1.9518072289156627, "no_speech_prob": 0.0001532632450107485}, {"id": 523, "seek": 409600, "start": 4096.0, "end": 4106.0, "text": " So I would find that sometimes it reads a little bit better, but it's totally a personal choice and a matter of usage and about a personal intuition.", "tokens": [407, 286, 576, 915, 300, 2171, 309, 15700, 257, 707, 857, 1101, 11, 457, 309, 311, 3879, 257, 2973, 3922, 293, 257, 1871, 295, 14924, 293, 466, 257, 2973, 24002, 13], "temperature": 0.0, "avg_logprob": -0.20239375388785585, "compression_ratio": 1.5445544554455446, "no_speech_prob": 0.00016600573144387454}, {"id": 524, "seek": 409600, "start": 4106.0, "end": 4112.0, "text": " So I would not force it on my colleagues where they are learning functional programming, for example.", "tokens": [407, 286, 576, 406, 3464, 309, 322, 452, 7734, 689, 436, 366, 2539, 11745, 9410, 11, 337, 1365, 13], "temperature": 0.0, "avg_logprob": -0.20239375388785585, "compression_ratio": 1.5445544554455446, "no_speech_prob": 0.00016600573144387454}, {"id": 525, "seek": 409600, "start": 4112.0, "end": 4118.0, "text": " You need to be very, very soft and very not strict about it.", "tokens": [509, 643, 281, 312, 588, 11, 588, 2787, 293, 588, 406, 10910, 466, 309, 13], "temperature": 0.0, "avg_logprob": -0.20239375388785585, "compression_ratio": 1.5445544554455446, "no_speech_prob": 0.00016600573144387454}, {"id": 526, "seek": 411800, "start": 4118.0, "end": 4126.0, "text": " I see. So you think that giving names to parameters in anonymous functions is pointless or point free?", "tokens": [286, 536, 13, 407, 291, 519, 300, 2902, 5288, 281, 9834, 294, 24932, 6828, 307, 32824, 420, 935, 1737, 30], "temperature": 0.0, "avg_logprob": -0.2920086804558249, "compression_ratio": 1.326086956521739, "no_speech_prob": 0.00011749950499506667}, {"id": 527, "seek": 411800, "start": 4126.0, "end": 4128.0, "text": " It's pointless.", "tokens": [467, 311, 32824, 13], "temperature": 0.0, "avg_logprob": -0.2920086804558249, "compression_ratio": 1.326086956521739, "no_speech_prob": 0.00011749950499506667}, {"id": 528, "seek": 411800, "start": 4128.0, "end": 4135.0, "text": " Only if you're a point freak.", "tokens": [5686, 498, 291, 434, 257, 935, 21853, 13], "temperature": 0.0, "avg_logprob": -0.2920086804558249, "compression_ratio": 1.326086956521739, "no_speech_prob": 0.00011749950499506667}, {"id": 529, "seek": 411800, "start": 4135.0, "end": 4140.0, "text": " Exactly. All the puns were coming.", "tokens": [7587, 13, 1057, 264, 4468, 82, 645, 1348, 13], "temperature": 0.0, "avg_logprob": -0.2920086804558249, "compression_ratio": 1.326086956521739, "no_speech_prob": 0.00011749950499506667}, {"id": 530, "seek": 414000, "start": 4140.0, "end": 4148.0, "text": " Yeah, it depends on the scenario. But yeah, I think sometimes the lambdas add a little bit noise and they are a bit pointless.", "tokens": [865, 11, 309, 5946, 322, 264, 9005, 13, 583, 1338, 11, 286, 519, 2171, 264, 10097, 27476, 909, 257, 707, 857, 5658, 293, 436, 366, 257, 857, 32824, 13], "temperature": 0.0, "avg_logprob": -0.24030803811961207, "compression_ratio": 1.6142857142857143, "no_speech_prob": 0.0002095257368637249}, {"id": 531, "seek": 414000, "start": 4148.0, "end": 4151.0, "text": " So then I prefer point free.", "tokens": [407, 550, 286, 4382, 935, 1737, 13], "temperature": 0.0, "avg_logprob": -0.24030803811961207, "compression_ratio": 1.6142857142857143, "no_speech_prob": 0.0002095257368637249}, {"id": 532, "seek": 414000, "start": 4151.0, "end": 4164.0, "text": " I see. That's interesting. Yeah, I think that makes sense. I would say on the other side of that, you know, sometimes I think about like certain designs and idioms resist refactoring.", "tokens": [286, 536, 13, 663, 311, 1880, 13, 865, 11, 286, 519, 300, 1669, 2020, 13, 286, 576, 584, 322, 264, 661, 1252, 295, 300, 11, 291, 458, 11, 2171, 286, 519, 466, 411, 1629, 11347, 293, 18014, 4785, 4597, 1895, 578, 3662, 13], "temperature": 0.0, "avg_logprob": -0.24030803811961207, "compression_ratio": 1.6142857142857143, "no_speech_prob": 0.0002095257368637249}, {"id": 533, "seek": 416400, "start": 4164.0, "end": 4175.0, "text": " I remember in my Ruby days, people talked a lot about this with certain language constructs that like using unless instead of if.", "tokens": [286, 1604, 294, 452, 19907, 1708, 11, 561, 2825, 257, 688, 466, 341, 365, 1629, 2856, 7690, 82, 300, 411, 1228, 5969, 2602, 295, 498, 13], "temperature": 0.0, "avg_logprob": -0.21884986029730902, "compression_ratio": 1.5427350427350428, "no_speech_prob": 0.00020004530961159617}, {"id": 534, "seek": 416400, "start": 4175.0, "end": 4185.0, "text": " And it's just like, well, OK, you can use unless, but you're introducing potentially a lot of churn if that condition changes in the future.", "tokens": [400, 309, 311, 445, 411, 11, 731, 11, 2264, 11, 291, 393, 764, 5969, 11, 457, 291, 434, 15424, 7263, 257, 688, 295, 417, 925, 498, 300, 4188, 2962, 294, 264, 2027, 13], "temperature": 0.0, "avg_logprob": -0.21884986029730902, "compression_ratio": 1.5427350427350428, "no_speech_prob": 0.00020004530961159617}, {"id": 535, "seek": 416400, "start": 4185.0, "end": 4191.0, "text": " Or if you add an else clause, now are you going to have an unless else? That's just weird.", "tokens": [1610, 498, 291, 909, 364, 1646, 25925, 11, 586, 366, 291, 516, 281, 362, 364, 5969, 1646, 30, 663, 311, 445, 3657, 13], "temperature": 0.0, "avg_logprob": -0.21884986029730902, "compression_ratio": 1.5427350427350428, "no_speech_prob": 0.00020004530961159617}, {"id": 536, "seek": 419100, "start": 4191.0, "end": 4198.0, "text": " So some people just say, let's just not use unless because it's prone to churn.", "tokens": [407, 512, 561, 445, 584, 11, 718, 311, 445, 406, 764, 5969, 570, 309, 311, 25806, 281, 417, 925, 13], "temperature": 0.0, "avg_logprob": -0.18668257805608934, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.0001609004830243066}, {"id": 537, "seek": 419100, "start": 4198.0, "end": 4208.0, "text": " And one thing that I've found is that like using the composition operator greater than greater than is convenient in some cases.", "tokens": [400, 472, 551, 300, 286, 600, 1352, 307, 300, 411, 1228, 264, 12686, 12973, 5044, 813, 5044, 813, 307, 10851, 294, 512, 3331, 13], "temperature": 0.0, "avg_logprob": -0.18668257805608934, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.0001609004830243066}, {"id": 538, "seek": 419100, "start": 4208.0, "end": 4210.0, "text": " And in some cases I do reach for it.", "tokens": [400, 294, 512, 3331, 286, 360, 2524, 337, 309, 13], "temperature": 0.0, "avg_logprob": -0.18668257805608934, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.0001609004830243066}, {"id": 539, "seek": 421000, "start": 4210.0, "end": 4223.0, "text": " But I do find myself flipping that to a lambda with an explicitly named argument pretty often, and it creates a little bit of churn in the code when I'm refactoring.", "tokens": [583, 286, 360, 915, 2059, 26886, 300, 281, 257, 13607, 365, 364, 20803, 4926, 6770, 1238, 2049, 11, 293, 309, 7829, 257, 707, 857, 295, 417, 925, 294, 264, 3089, 562, 286, 478, 1895, 578, 3662, 13], "temperature": 0.0, "avg_logprob": -0.142622559935182, "compression_ratio": 1.5726141078838174, "no_speech_prob": 1.9221855836804025e-05}, {"id": 540, "seek": 421000, "start": 4223.0, "end": 4235.0, "text": " So that would be one argument against it. Also, it's like there's a certain point where you're like, well, I'm having to think pretty hard about what this is doing when you're chaining like enough things together.", "tokens": [407, 300, 576, 312, 472, 6770, 1970, 309, 13, 2743, 11, 309, 311, 411, 456, 311, 257, 1629, 935, 689, 291, 434, 411, 11, 731, 11, 286, 478, 1419, 281, 519, 1238, 1152, 466, 437, 341, 307, 884, 562, 291, 434, 417, 3686, 411, 1547, 721, 1214, 13], "temperature": 0.0, "avg_logprob": -0.142622559935182, "compression_ratio": 1.5726141078838174, "no_speech_prob": 1.9221855836804025e-05}, {"id": 541, "seek": 423500, "start": 4235.0, "end": 4241.0, "text": " And you're like, if I just if this was just like a lambda, I wouldn't have to think quite so hard.", "tokens": [400, 291, 434, 411, 11, 498, 286, 445, 498, 341, 390, 445, 411, 257, 13607, 11, 286, 2759, 380, 362, 281, 519, 1596, 370, 1152, 13], "temperature": 0.0, "avg_logprob": -0.2134785036886892, "compression_ratio": 1.6517241379310346, "no_speech_prob": 2.7102290914626792e-05}, {"id": 542, "seek": 423500, "start": 4241.0, "end": 4245.0, "text": " So I think like that's one argument I've heard in the opposite direction.", "tokens": [407, 286, 519, 411, 300, 311, 472, 6770, 286, 600, 2198, 294, 264, 6182, 3513, 13], "temperature": 0.0, "avg_logprob": -0.2134785036886892, "compression_ratio": 1.6517241379310346, "no_speech_prob": 2.7102290914626792e-05}, {"id": 543, "seek": 423500, "start": 4245.0, "end": 4248.0, "text": " I think I think there's a reason for both sides.", "tokens": [286, 519, 286, 519, 456, 311, 257, 1778, 337, 1293, 4881, 13], "temperature": 0.0, "avg_logprob": -0.2134785036886892, "compression_ratio": 1.6517241379310346, "no_speech_prob": 2.7102290914626792e-05}, {"id": 544, "seek": 423500, "start": 4248.0, "end": 4250.0, "text": " Maybe the right answer is somewhere in the middle.", "tokens": [2704, 264, 558, 1867, 307, 4079, 294, 264, 2808, 13], "temperature": 0.0, "avg_logprob": -0.2134785036886892, "compression_ratio": 1.6517241379310346, "no_speech_prob": 2.7102290914626792e-05}, {"id": 545, "seek": 423500, "start": 4250.0, "end": 4260.0, "text": " Yeah, for me, it was there's a talk called Tacit Programming Point Free or Die or something like that that was given at Strange Loop some years ago.", "tokens": [865, 11, 337, 385, 11, 309, 390, 456, 311, 257, 751, 1219, 38848, 270, 8338, 2810, 12387, 11551, 420, 3229, 420, 746, 411, 300, 300, 390, 2212, 412, 29068, 45660, 512, 924, 2057, 13], "temperature": 0.0, "avg_logprob": -0.2134785036886892, "compression_ratio": 1.6517241379310346, "no_speech_prob": 2.7102290914626792e-05}, {"id": 546, "seek": 423500, "start": 4260.0, "end": 4264.0, "text": " And it is more reasonable than the title makes you think.", "tokens": [400, 309, 307, 544, 10585, 813, 264, 4876, 1669, 291, 519, 13], "temperature": 0.0, "avg_logprob": -0.2134785036886892, "compression_ratio": 1.6517241379310346, "no_speech_prob": 2.7102290914626792e-05}, {"id": 547, "seek": 426400, "start": 4264.0, "end": 4267.0, "text": " But it is basically Haskell code.", "tokens": [583, 309, 307, 1936, 8646, 43723, 3089, 13], "temperature": 0.0, "avg_logprob": -0.20562283376629434, "compression_ratio": 1.6231884057971016, "no_speech_prob": 0.0013837460428476334}, {"id": 548, "seek": 426400, "start": 4267.0, "end": 4276.0, "text": " And for example, you want you you're used to seeing JavaScript code when people will just open a lambda, say X lambda, then console log of X.", "tokens": [400, 337, 1365, 11, 291, 528, 291, 291, 434, 1143, 281, 2577, 15778, 3089, 562, 561, 486, 445, 1269, 257, 13607, 11, 584, 1783, 13607, 11, 550, 11076, 3565, 295, 1783, 13], "temperature": 0.0, "avg_logprob": -0.20562283376629434, "compression_ratio": 1.6231884057971016, "no_speech_prob": 0.0013837460428476334}, {"id": 549, "seek": 426400, "start": 4276.0, "end": 4283.0, "text": " Right. So functions with one point, you see that and you say, oh, the point is pointless.", "tokens": [1779, 13, 407, 6828, 365, 472, 935, 11, 291, 536, 300, 293, 291, 584, 11, 1954, 11, 264, 935, 307, 32824, 13], "temperature": 0.0, "avg_logprob": -0.20562283376629434, "compression_ratio": 1.6231884057971016, "no_speech_prob": 0.0013837460428476334}, {"id": 550, "seek": 426400, "start": 4283.0, "end": 4288.0, "text": " So the X is pointless. And you can just say console log as a function.", "tokens": [407, 264, 1783, 307, 32824, 13, 400, 291, 393, 445, 584, 11076, 3565, 382, 257, 2445, 13], "temperature": 0.0, "avg_logprob": -0.20562283376629434, "compression_ratio": 1.6231884057971016, "no_speech_prob": 0.0013837460428476334}, {"id": 551, "seek": 428800, "start": 4288.0, "end": 4294.0, "text": " Right. But when it gets crazier in Haskell is when you do not have one function argument, you have two.", "tokens": [1779, 13, 583, 562, 309, 2170, 2094, 33352, 294, 8646, 43723, 307, 562, 291, 360, 406, 362, 472, 2445, 6770, 11, 291, 362, 732, 13], "temperature": 0.0, "avg_logprob": -0.1927222034387421, "compression_ratio": 1.7662835249042146, "no_speech_prob": 0.00045059967669658363}, {"id": 552, "seek": 428800, "start": 4294.0, "end": 4299.0, "text": " And they're passed as they are giving A and B to the next function A and B.", "tokens": [400, 436, 434, 4678, 382, 436, 366, 2902, 316, 293, 363, 281, 264, 958, 2445, 316, 293, 363, 13], "temperature": 0.0, "avg_logprob": -0.1927222034387421, "compression_ratio": 1.7662835249042146, "no_speech_prob": 0.00045059967669658363}, {"id": 553, "seek": 428800, "start": 4299.0, "end": 4302.0, "text": " And you cannot you cannot do this the same way.", "tokens": [400, 291, 2644, 291, 2644, 360, 341, 264, 912, 636, 13], "temperature": 0.0, "avg_logprob": -0.1927222034387421, "compression_ratio": 1.7662835249042146, "no_speech_prob": 0.00045059967669658363}, {"id": 554, "seek": 428800, "start": 4302.0, "end": 4312.0, "text": " But there is an operator called the Blackbird operator, which I just learned about like a month ago that allows you to pass these two point function the next function.", "tokens": [583, 456, 307, 364, 12973, 1219, 264, 4076, 18080, 12973, 11, 597, 286, 445, 3264, 466, 411, 257, 1618, 2057, 300, 4045, 291, 281, 1320, 613, 732, 935, 2445, 264, 958, 2445, 13], "temperature": 0.0, "avg_logprob": -0.1927222034387421, "compression_ratio": 1.7662835249042146, "no_speech_prob": 0.00045059967669658363}, {"id": 555, "seek": 428800, "start": 4312.0, "end": 4316.0, "text": " But the code starts to get really, really messy and really crazy.", "tokens": [583, 264, 3089, 3719, 281, 483, 534, 11, 534, 16191, 293, 534, 3219, 13], "temperature": 0.0, "avg_logprob": -0.1927222034387421, "compression_ratio": 1.7662835249042146, "no_speech_prob": 0.00045059967669658363}, {"id": 556, "seek": 431600, "start": 4316.0, "end": 4320.0, "text": " And that's why it says, you know what, do what's readable.", "tokens": [400, 300, 311, 983, 309, 1619, 11, 291, 458, 437, 11, 360, 437, 311, 49857, 13], "temperature": 0.0, "avg_logprob": -0.25293036869594027, "compression_ratio": 1.614678899082569, "no_speech_prob": 0.0002775944594759494}, {"id": 557, "seek": 431600, "start": 4320.0, "end": 4324.0, "text": " If if that's the programming reads better, sometimes just use it.", "tokens": [759, 498, 300, 311, 264, 9410, 15700, 1101, 11, 2171, 445, 764, 309, 13], "temperature": 0.0, "avg_logprob": -0.25293036869594027, "compression_ratio": 1.614678899082569, "no_speech_prob": 0.0002775944594759494}, {"id": 558, "seek": 431600, "start": 4324.0, "end": 4328.0, "text": " If it doesn't, please don't overuse it. Basically, but it's a really great talk.", "tokens": [759, 309, 1177, 380, 11, 1767, 500, 380, 670, 438, 309, 13, 8537, 11, 457, 309, 311, 257, 534, 869, 751, 13], "temperature": 0.0, "avg_logprob": -0.25293036869594027, "compression_ratio": 1.614678899082569, "no_speech_prob": 0.0002775944594759494}, {"id": 559, "seek": 431600, "start": 4328.0, "end": 4339.0, "text": " Right. Yeah. I mean, at the point that you start reaching for for flip, then you might consider just naming that argument in a lambda.", "tokens": [1779, 13, 865, 13, 286, 914, 11, 412, 264, 935, 300, 291, 722, 9906, 337, 337, 7929, 11, 550, 291, 1062, 1949, 445, 25290, 300, 6770, 294, 257, 13607, 13], "temperature": 0.0, "avg_logprob": -0.25293036869594027, "compression_ratio": 1.614678899082569, "no_speech_prob": 0.0002775944594759494}, {"id": 560, "seek": 431600, "start": 4339.0, "end": 4341.0, "text": " Yeah. Yeah.", "tokens": [865, 13, 865, 13], "temperature": 0.0, "avg_logprob": -0.25293036869594027, "compression_ratio": 1.614678899082569, "no_speech_prob": 0.0002775944594759494}, {"id": 561, "seek": 434100, "start": 4341.0, "end": 4346.0, "text": " I miss flip a lot of times in Elm.", "tokens": [286, 1713, 7929, 257, 688, 295, 1413, 294, 2699, 76, 13], "temperature": 0.0, "avg_logprob": -0.24845143022208377, "compression_ratio": 1.4639175257731958, "no_speech_prob": 6.619911437155679e-05}, {"id": 562, "seek": 434100, "start": 4346.0, "end": 4351.0, "text": " Yeah, but it's because of me being a pointless freak.", "tokens": [865, 11, 457, 309, 311, 570, 295, 385, 885, 257, 32824, 21853, 13], "temperature": 0.0, "avg_logprob": -0.24845143022208377, "compression_ratio": 1.4639175257731958, "no_speech_prob": 6.619911437155679e-05}, {"id": 563, "seek": 434100, "start": 4351.0, "end": 4355.0, "text": " Right.", "tokens": [1779, 13], "temperature": 0.0, "avg_logprob": -0.24845143022208377, "compression_ratio": 1.4639175257731958, "no_speech_prob": 6.619911437155679e-05}, {"id": 564, "seek": 434100, "start": 4355.0, "end": 4361.0, "text": " I guess that's why carry and uncarry and flip were removed from the prelude of Elm, you know.", "tokens": [286, 2041, 300, 311, 983, 3985, 293, 6219, 25516, 293, 7929, 645, 7261, 490, 264, 659, 32334, 295, 2699, 76, 11, 291, 458, 13], "temperature": 0.0, "avg_logprob": -0.24845143022208377, "compression_ratio": 1.4639175257731958, "no_speech_prob": 6.619911437155679e-05}, {"id": 565, "seek": 434100, "start": 4361.0, "end": 4367.0, "text": " Right. Now, OK, why don't you go ahead and define those for those of us who haven't used them?", "tokens": [1779, 13, 823, 11, 2264, 11, 983, 500, 380, 291, 352, 2286, 293, 6964, 729, 337, 729, 295, 505, 567, 2378, 380, 1143, 552, 30], "temperature": 0.0, "avg_logprob": -0.24845143022208377, "compression_ratio": 1.4639175257731958, "no_speech_prob": 6.619911437155679e-05}, {"id": 566, "seek": 436700, "start": 4367.0, "end": 4374.0, "text": " I don't think I ever used I don't think I ever used any of those, actually, even back in the 18 days when it was around.", "tokens": [286, 500, 380, 519, 286, 1562, 1143, 286, 500, 380, 519, 286, 1562, 1143, 604, 295, 729, 11, 767, 11, 754, 646, 294, 264, 2443, 1708, 562, 309, 390, 926, 13], "temperature": 0.0, "avg_logprob": -0.23229771215938827, "compression_ratio": 1.812785388127854, "no_speech_prob": 1.0129743714060169e-05}, {"id": 567, "seek": 436700, "start": 4374.0, "end": 4383.0, "text": " I'm sure I did either. But I started basically with 0.19 as well, even though I did it back a little bit back in 0.16.", "tokens": [286, 478, 988, 286, 630, 2139, 13, 583, 286, 1409, 1936, 365, 1958, 13, 3405, 382, 731, 11, 754, 1673, 286, 630, 309, 646, 257, 707, 857, 646, 294, 1958, 13, 6866, 13], "temperature": 0.0, "avg_logprob": -0.23229771215938827, "compression_ratio": 1.812785388127854, "no_speech_prob": 1.0129743714060169e-05}, {"id": 568, "seek": 436700, "start": 4383.0, "end": 4393.0, "text": " Flip is a function that, for example, expects a function that takes is a function that expects a function that takes two arguments and then returns a result.", "tokens": [28210, 307, 257, 2445, 300, 11, 337, 1365, 11, 33280, 257, 2445, 300, 2516, 307, 257, 2445, 300, 33280, 257, 2445, 300, 2516, 732, 12869, 293, 550, 11247, 257, 1874, 13], "temperature": 0.0, "avg_logprob": -0.23229771215938827, "compression_ratio": 1.812785388127854, "no_speech_prob": 1.0129743714060169e-05}, {"id": 569, "seek": 439300, "start": 4393.0, "end": 4404.0, "text": " So you have a B and the result would be C. So sometimes the order of the arguments you expect for a certain function is B, A and then X.", "tokens": [407, 291, 362, 257, 363, 293, 264, 1874, 576, 312, 383, 13, 407, 2171, 264, 1668, 295, 264, 12869, 291, 2066, 337, 257, 1629, 2445, 307, 363, 11, 316, 293, 550, 1783, 13], "temperature": 0.0, "avg_logprob": -0.1983455022176107, "compression_ratio": 1.8384279475982532, "no_speech_prob": 0.0001605529396329075}, {"id": 570, "seek": 439300, "start": 4404.0, "end": 4408.0, "text": " But you you cannot change the order because of the way your code works or whatever.", "tokens": [583, 291, 291, 2644, 1319, 264, 1668, 570, 295, 264, 636, 428, 3089, 1985, 420, 2035, 13], "temperature": 0.0, "avg_logprob": -0.1983455022176107, "compression_ratio": 1.8384279475982532, "no_speech_prob": 0.0001605529396329075}, {"id": 571, "seek": 439300, "start": 4408.0, "end": 4414.0, "text": " So this flip function is very convenient because it lets you flip the arguments of the function you're calling.", "tokens": [407, 341, 7929, 2445, 307, 588, 10851, 570, 309, 6653, 291, 7929, 264, 12869, 295, 264, 2445, 291, 434, 5141, 13], "temperature": 0.0, "avg_logprob": -0.1983455022176107, "compression_ratio": 1.8384279475982532, "no_speech_prob": 0.0001605529396329075}, {"id": 572, "seek": 439300, "start": 4414.0, "end": 4419.0, "text": " And it's also a mathematical concept because you can also flip functions mathematically.", "tokens": [400, 309, 311, 611, 257, 18894, 3410, 570, 291, 393, 611, 7929, 6828, 44003, 13], "temperature": 0.0, "avg_logprob": -0.1983455022176107, "compression_ratio": 1.8384279475982532, "no_speech_prob": 0.0001605529396329075}, {"id": 573, "seek": 441900, "start": 4419.0, "end": 4425.0, "text": " But it is kind of magic that this does that this works. But if you see the function implementation, it's not magic at all.", "tokens": [583, 309, 307, 733, 295, 5585, 300, 341, 775, 300, 341, 1985, 13, 583, 498, 291, 536, 264, 2445, 11420, 11, 309, 311, 406, 5585, 412, 439, 13], "temperature": 0.0, "avg_logprob": -0.2696602127768777, "compression_ratio": 1.7729468599033817, "no_speech_prob": 0.0001938579516718164}, {"id": 574, "seek": 441900, "start": 4425.0, "end": 4430.0, "text": " You know, right. So flip does that. And there there's uncarry.", "tokens": [509, 458, 11, 558, 13, 407, 7929, 775, 300, 13, 400, 456, 456, 311, 6219, 25516, 13], "temperature": 0.0, "avg_logprob": -0.2696602127768777, "compression_ratio": 1.7729468599033817, "no_speech_prob": 0.0001938579516718164}, {"id": 575, "seek": 441900, "start": 4430.0, "end": 4441.0, "text": " You know that all the functions are carried in Elm, which means that they all receive just one argument and return a function that also returns expects one argument and returns one.", "tokens": [509, 458, 300, 439, 264, 6828, 366, 9094, 294, 2699, 76, 11, 597, 1355, 300, 436, 439, 4774, 445, 472, 6770, 293, 2736, 257, 2445, 300, 611, 11247, 33280, 472, 6770, 293, 11247, 472, 13], "temperature": 0.0, "avg_logprob": -0.2696602127768777, "compression_ratio": 1.7729468599033817, "no_speech_prob": 0.0001938579516718164}, {"id": 576, "seek": 444100, "start": 4441.0, "end": 4449.0, "text": " And there is a case in which you might want to uncarry a function so that it receives all of the arguments at the same time.", "tokens": [400, 456, 307, 257, 1389, 294, 597, 291, 1062, 528, 281, 6219, 25516, 257, 2445, 370, 300, 309, 20717, 439, 295, 264, 12869, 412, 264, 912, 565, 13], "temperature": 0.0, "avg_logprob": -0.20847980792705828, "compression_ratio": 1.6851063829787234, "no_speech_prob": 6.399506673915312e-05}, {"id": 577, "seek": 444100, "start": 4449.0, "end": 4458.0, "text": " And the only way to do this in Elm is to use uncarry. And now instead of expecting arguments one by one, it will just expect a tuple of arguments.", "tokens": [400, 264, 787, 636, 281, 360, 341, 294, 2699, 76, 307, 281, 764, 6219, 25516, 13, 400, 586, 2602, 295, 9650, 12869, 472, 538, 472, 11, 309, 486, 445, 2066, 257, 2604, 781, 295, 12869, 13], "temperature": 0.0, "avg_logprob": -0.20847980792705828, "compression_ratio": 1.6851063829787234, "no_speech_prob": 6.399506673915312e-05}, {"id": 578, "seek": 444100, "start": 4458.0, "end": 4461.0, "text": " And then it will give you a result.", "tokens": [400, 550, 309, 486, 976, 291, 257, 1874, 13], "temperature": 0.0, "avg_logprob": -0.20847980792705828, "compression_ratio": 1.6851063829787234, "no_speech_prob": 6.399506673915312e-05}, {"id": 579, "seek": 444100, "start": 4461.0, "end": 4468.0, "text": " Right. Interesting. And most mostly useful for for chaining things in a point freestyle.", "tokens": [1779, 13, 14711, 13, 400, 881, 5240, 4420, 337, 337, 417, 3686, 721, 294, 257, 935, 2130, 279, 874, 306, 13], "temperature": 0.0, "avg_logprob": -0.20847980792705828, "compression_ratio": 1.6851063829787234, "no_speech_prob": 6.399506673915312e-05}, {"id": 580, "seek": 446800, "start": 4468.0, "end": 4474.0, "text": " Yes, I tend to reach for those basically when you are doing crazy point free stuff.", "tokens": [1079, 11, 286, 3928, 281, 2524, 337, 729, 1936, 562, 291, 366, 884, 3219, 935, 1737, 1507, 13], "temperature": 0.0, "avg_logprob": -0.23222793416774018, "compression_ratio": 1.6825396825396826, "no_speech_prob": 0.00031871075043454766}, {"id": 581, "seek": 446800, "start": 4474.0, "end": 4483.0, "text": " You find that you haven't defined your functions in the best order possible because for composition to work properly, the functions need to be data last.", "tokens": [509, 915, 300, 291, 2378, 380, 7642, 428, 6828, 294, 264, 1151, 1668, 1944, 570, 337, 12686, 281, 589, 6108, 11, 264, 6828, 643, 281, 312, 1412, 1036, 13], "temperature": 0.0, "avg_logprob": -0.23222793416774018, "compression_ratio": 1.6825396825396826, "no_speech_prob": 0.00031871075043454766}, {"id": 582, "seek": 446800, "start": 4483.0, "end": 4491.0, "text": " Right. And for functions that have expect more than one argument, you sometimes do not choose the correct or the order that you were expecting.", "tokens": [1779, 13, 400, 337, 6828, 300, 362, 2066, 544, 813, 472, 6770, 11, 291, 2171, 360, 406, 2826, 264, 3006, 420, 264, 1668, 300, 291, 645, 9650, 13], "temperature": 0.0, "avg_logprob": -0.23222793416774018, "compression_ratio": 1.6825396825396826, "no_speech_prob": 0.00031871075043454766}, {"id": 583, "seek": 446800, "start": 4491.0, "end": 4494.0, "text": " And you end up flipping lots of functions.", "tokens": [400, 291, 917, 493, 26886, 3195, 295, 6828, 13], "temperature": 0.0, "avg_logprob": -0.23222793416774018, "compression_ratio": 1.6825396825396826, "no_speech_prob": 0.00031871075043454766}, {"id": 584, "seek": 449400, "start": 4494.0, "end": 4503.0, "text": " Yeah. Things like dig.union or set.diff. Probably more the diff than union.", "tokens": [865, 13, 9514, 411, 2528, 13, 42137, 420, 992, 13, 67, 3661, 13, 9210, 544, 264, 7593, 813, 11671, 13], "temperature": 0.0, "avg_logprob": -0.40073866922347273, "compression_ratio": 1.4759036144578312, "no_speech_prob": 0.0002512145147193223}, {"id": 585, "seek": 449400, "start": 4503.0, "end": 4514.0, "text": " For diff is really tricky because you think that you're doing the same thing, but depending on the order, you might be diffing two completely different, getting two out.", "tokens": [1171, 7593, 307, 534, 12414, 570, 291, 519, 300, 291, 434, 884, 264, 912, 551, 11, 457, 5413, 322, 264, 1668, 11, 291, 1062, 312, 7593, 278, 732, 2584, 819, 11, 1242, 732, 484, 13], "temperature": 0.0, "avg_logprob": -0.40073866922347273, "compression_ratio": 1.4759036144578312, "no_speech_prob": 0.0002512145147193223}, {"id": 586, "seek": 451400, "start": 4514.0, "end": 4524.0, "text": " Yeah. So that one definitely I tried to avoid using composition because it's difficult enough already.", "tokens": [865, 13, 407, 300, 472, 2138, 286, 3031, 281, 5042, 1228, 12686, 570, 309, 311, 2252, 1547, 1217, 13], "temperature": 0.0, "avg_logprob": -0.2770134972744301, "compression_ratio": 1.3895348837209303, "no_speech_prob": 0.00018434194498695433}, {"id": 587, "seek": 451400, "start": 4524.0, "end": 4526.0, "text": " Yes, it's true.", "tokens": [1079, 11, 309, 311, 2074, 13], "temperature": 0.0, "avg_logprob": -0.2770134972744301, "compression_ratio": 1.3895348837209303, "no_speech_prob": 0.00018434194498695433}, {"id": 588, "seek": 451400, "start": 4526.0, "end": 4533.0, "text": " So maybe to round off, we've seen that Elm and Haskell are very similar languages where they look a lot like each other.", "tokens": [407, 1310, 281, 3098, 766, 11, 321, 600, 1612, 300, 2699, 76, 293, 8646, 43723, 366, 588, 2531, 8650, 689, 436, 574, 257, 688, 411, 1184, 661, 13], "temperature": 0.0, "avg_logprob": -0.2770134972744301, "compression_ratio": 1.3895348837209303, "no_speech_prob": 0.00018434194498695433}, {"id": 589, "seek": 453300, "start": 4533.0, "end": 4544.0, "text": " So it's pretty easy to jump from Elm to Haskell relatively compared to other languages at least. And Haskell has quite a large learning curve.", "tokens": [407, 309, 311, 1238, 1858, 281, 3012, 490, 2699, 76, 281, 8646, 43723, 7226, 5347, 281, 661, 8650, 412, 1935, 13, 400, 8646, 43723, 575, 1596, 257, 2416, 2539, 7605, 13], "temperature": 0.0, "avg_logprob": -0.1927967304136695, "compression_ratio": 1.6847290640394088, "no_speech_prob": 7.248580368468538e-05}, {"id": 590, "seek": 453300, "start": 4544.0, "end": 4549.0, "text": " So we've talked about category theory. We've talked about laziness. We've talked about language extensions.", "tokens": [407, 321, 600, 2825, 466, 7719, 5261, 13, 492, 600, 2825, 466, 19320, 1324, 13, 492, 600, 2825, 466, 2856, 25129, 13], "temperature": 0.0, "avg_logprob": -0.1927967304136695, "compression_ratio": 1.6847290640394088, "no_speech_prob": 7.248580368468538e-05}, {"id": 591, "seek": 453300, "start": 4549.0, "end": 4559.0, "text": " Well, we kind of did talk about category theory and you also told us to shut up about that.", "tokens": [1042, 11, 321, 733, 295, 630, 751, 466, 7719, 5261, 293, 291, 611, 1907, 505, 281, 5309, 493, 466, 300, 13], "temperature": 0.0, "avg_logprob": -0.1927967304136695, "compression_ratio": 1.6847290640394088, "no_speech_prob": 7.248580368468538e-05}, {"id": 592, "seek": 455900, "start": 4559.0, "end": 4571.0, "text": " But yeah, what other concepts are useful to learn in Haskell? Or would someone who goes from Elm, who would go to Haskell, what would they need to learn on top of these?", "tokens": [583, 1338, 11, 437, 661, 10392, 366, 4420, 281, 1466, 294, 8646, 43723, 30, 1610, 576, 1580, 567, 1709, 490, 2699, 76, 11, 567, 576, 352, 281, 8646, 43723, 11, 437, 576, 436, 643, 281, 1466, 322, 1192, 295, 613, 30], "temperature": 0.0, "avg_logprob": -0.2386679750807742, "compression_ratio": 1.6118721461187215, "no_speech_prob": 0.00019354427058715373}, {"id": 593, "seek": 455900, "start": 4571.0, "end": 4576.0, "text": " Or in other words, what could your next blog post be about?", "tokens": [1610, 294, 661, 2283, 11, 437, 727, 428, 958, 6968, 2183, 312, 466, 30], "temperature": 0.0, "avg_logprob": -0.2386679750807742, "compression_ratio": 1.6118721461187215, "no_speech_prob": 0.00019354427058715373}, {"id": 594, "seek": 455900, "start": 4576.0, "end": 4583.0, "text": " Nice. So there are a couple of things. For example, we talked a little bit, well, I talk in my posts about infix operators.", "tokens": [5490, 13, 407, 456, 366, 257, 1916, 295, 721, 13, 1171, 1365, 11, 321, 2825, 257, 707, 857, 11, 731, 11, 286, 751, 294, 452, 12300, 466, 1536, 970, 19077, 13], "temperature": 0.0, "avg_logprob": -0.2386679750807742, "compression_ratio": 1.6118721461187215, "no_speech_prob": 0.00019354427058715373}, {"id": 595, "seek": 458300, "start": 4583.0, "end": 4589.0, "text": " Elm has some of those, but you cannot user define them anymore.", "tokens": [2699, 76, 575, 512, 295, 729, 11, 457, 291, 2644, 4195, 6964, 552, 3602, 13], "temperature": 0.0, "avg_logprob": -0.1923285893031529, "compression_ratio": 1.6790123456790123, "no_speech_prob": 0.0003293435147497803}, {"id": 596, "seek": 458300, "start": 4589.0, "end": 4601.0, "text": " So the most famous ones in Haskell are the ones in the Lens library, which is a library that is very famous because it produced a set of Lens libraries for many other languages.", "tokens": [407, 264, 881, 4618, 2306, 294, 8646, 43723, 366, 264, 2306, 294, 264, 441, 694, 6405, 11, 597, 307, 257, 6405, 300, 307, 588, 4618, 570, 309, 7126, 257, 992, 295, 441, 694, 15148, 337, 867, 661, 8650, 13], "temperature": 0.0, "avg_logprob": -0.1923285893031529, "compression_ratio": 1.6790123456790123, "no_speech_prob": 0.0003293435147497803}, {"id": 597, "seek": 458300, "start": 4601.0, "end": 4611.0, "text": " A Lens is basically something that allows you to, it's a functional getter and setter that allows you to manipulate data on a deeply nested data structure, basically.", "tokens": [316, 441, 694, 307, 1936, 746, 300, 4045, 291, 281, 11, 309, 311, 257, 11745, 483, 391, 293, 992, 391, 300, 4045, 291, 281, 20459, 1412, 322, 257, 8760, 15646, 292, 1412, 3877, 11, 1936, 13], "temperature": 0.0, "avg_logprob": -0.1923285893031529, "compression_ratio": 1.6790123456790123, "no_speech_prob": 0.0003293435147497803}, {"id": 598, "seek": 461100, "start": 4611.0, "end": 4621.0, "text": " And they come from Haskell and they are useful in JavaScript, for example, to traversing JSON, really huge nested JSONs and doing things on the level you want.", "tokens": [400, 436, 808, 490, 8646, 43723, 293, 436, 366, 4420, 294, 15778, 11, 337, 1365, 11, 281, 23149, 278, 31828, 11, 534, 2603, 15646, 292, 31828, 82, 293, 884, 721, 322, 264, 1496, 291, 528, 13], "temperature": 0.0, "avg_logprob": -0.19468694028601183, "compression_ratio": 1.5912408759124088, "no_speech_prob": 6.602601933991536e-05}, {"id": 599, "seek": 461100, "start": 4621.0, "end": 4635.0, "text": " And we don't have, unfortunately, per se, Lenses in Elm, but I know that there are people who build their own Lens libraries or they're building code generators for Elm that are able to use Lenses in Elm.", "tokens": [400, 321, 500, 380, 362, 11, 7015, 11, 680, 369, 11, 441, 9085, 294, 2699, 76, 11, 457, 286, 458, 300, 456, 366, 561, 567, 1322, 641, 1065, 441, 694, 15148, 420, 436, 434, 2390, 3089, 38662, 337, 2699, 76, 300, 366, 1075, 281, 764, 441, 9085, 294, 2699, 76, 13], "temperature": 0.0, "avg_logprob": -0.19468694028601183, "compression_ratio": 1.5912408759124088, "no_speech_prob": 6.602601933991536e-05}, {"id": 600, "seek": 461100, "start": 4635.0, "end": 4638.0, "text": " But it's not like a common pattern that it's used in the Elm community.", "tokens": [583, 309, 311, 406, 411, 257, 2689, 5102, 300, 309, 311, 1143, 294, 264, 2699, 76, 1768, 13], "temperature": 0.0, "avg_logprob": -0.19468694028601183, "compression_ratio": 1.5912408759124088, "no_speech_prob": 6.602601933991536e-05}, {"id": 601, "seek": 463800, "start": 4638.0, "end": 4641.0, "text": " There are a few packages out there.", "tokens": [821, 366, 257, 1326, 17401, 484, 456, 13], "temperature": 0.0, "avg_logprob": -0.1999573759980254, "compression_ratio": 1.539906103286385, "no_speech_prob": 0.00044994920608587563}, {"id": 602, "seek": 463800, "start": 4641.0, "end": 4643.0, "text": " At least a couple, right?", "tokens": [1711, 1935, 257, 1916, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.1999573759980254, "compression_ratio": 1.539906103286385, "no_speech_prob": 0.00044994920608587563}, {"id": 603, "seek": 463800, "start": 4643.0, "end": 4648.0, "text": " At least a couple, which is a lot for the Elm community.", "tokens": [1711, 1935, 257, 1916, 11, 597, 307, 257, 688, 337, 264, 2699, 76, 1768, 13], "temperature": 0.0, "avg_logprob": -0.1999573759980254, "compression_ratio": 1.539906103286385, "no_speech_prob": 0.00044994920608587563}, {"id": 604, "seek": 463800, "start": 4648.0, "end": 4653.0, "text": " In terms of packages and for something that is sometimes frowned upon.", "tokens": [682, 2115, 295, 17401, 293, 337, 746, 300, 307, 2171, 431, 14683, 3564, 13], "temperature": 0.0, "avg_logprob": -0.1999573759980254, "compression_ratio": 1.539906103286385, "no_speech_prob": 0.00044994920608587563}, {"id": 605, "seek": 463800, "start": 4653.0, "end": 4657.0, "text": " You have your set of choices.", "tokens": [509, 362, 428, 992, 295, 7994, 13], "temperature": 0.0, "avg_logprob": -0.1999573759980254, "compression_ratio": 1.539906103286385, "no_speech_prob": 0.00044994920608587563}, {"id": 606, "seek": 463800, "start": 4657.0, "end": 4660.0, "text": " So Lenses would be one thing.", "tokens": [407, 441, 9085, 576, 312, 472, 551, 13], "temperature": 0.0, "avg_logprob": -0.1999573759980254, "compression_ratio": 1.539906103286385, "no_speech_prob": 0.00044994920608587563}, {"id": 607, "seek": 463800, "start": 4660.0, "end": 4665.0, "text": " Well, getting acquainted with a lot of crazy infix operators is another thing.", "tokens": [1042, 11, 1242, 50224, 365, 257, 688, 295, 3219, 1536, 970, 19077, 307, 1071, 551, 13], "temperature": 0.0, "avg_logprob": -0.1999573759980254, "compression_ratio": 1.539906103286385, "no_speech_prob": 0.00044994920608587563}, {"id": 608, "seek": 466500, "start": 4665.0, "end": 4670.0, "text": " And also just knowing that there are many ways to do the same thing.", "tokens": [400, 611, 445, 5276, 300, 456, 366, 867, 2098, 281, 360, 264, 912, 551, 13], "temperature": 0.0, "avg_logprob": -0.2102855635278019, "compression_ratio": 1.6231155778894473, "no_speech_prob": 0.0003299301315564662}, {"id": 609, "seek": 466500, "start": 4670.0, "end": 4676.0, "text": " Like, for example, there are two or three ways of doing pattern matching in Haskell, whereas in Elm there's only one.", "tokens": [1743, 11, 337, 1365, 11, 456, 366, 732, 420, 1045, 2098, 295, 884, 5102, 14324, 294, 8646, 43723, 11, 9735, 294, 2699, 76, 456, 311, 787, 472, 13], "temperature": 0.0, "avg_logprob": -0.2102855635278019, "compression_ratio": 1.6231155778894473, "no_speech_prob": 0.0003299301315564662}, {"id": 610, "seek": 466500, "start": 4676.0, "end": 4678.0, "text": " The case of syntax.", "tokens": [440, 1389, 295, 28431, 13], "temperature": 0.0, "avg_logprob": -0.2102855635278019, "compression_ratio": 1.6231155778894473, "no_speech_prob": 0.0003299301315564662}, {"id": 611, "seek": 466500, "start": 4678.0, "end": 4685.0, "text": " There are pattern guards and pattern synonyms, which are things that are meant to help you simplify pattern matches.", "tokens": [821, 366, 5102, 17652, 293, 5102, 5451, 2526, 2592, 11, 597, 366, 721, 300, 366, 4140, 281, 854, 291, 20460, 5102, 10676, 13], "temperature": 0.0, "avg_logprob": -0.2102855635278019, "compression_ratio": 1.6231155778894473, "no_speech_prob": 0.0003299301315564662}, {"id": 612, "seek": 468500, "start": 4685.0, "end": 4695.0, "text": " And many other constructs that we don't have, but I would bet you don't really actually need in Elm.", "tokens": [400, 867, 661, 7690, 82, 300, 321, 500, 380, 362, 11, 457, 286, 576, 778, 291, 500, 380, 534, 767, 643, 294, 2699, 76, 13], "temperature": 0.0, "avg_logprob": -0.22337841406101133, "compression_ratio": 1.5658536585365854, "no_speech_prob": 0.0004929048009216785}, {"id": 613, "seek": 468500, "start": 4695.0, "end": 4701.0, "text": " Also, I'd like to say that even though it's not language related, but ecosystem related.", "tokens": [2743, 11, 286, 1116, 411, 281, 584, 300, 754, 1673, 309, 311, 406, 2856, 4077, 11, 457, 11311, 4077, 13], "temperature": 0.0, "avg_logprob": -0.22337841406101133, "compression_ratio": 1.5658536585365854, "no_speech_prob": 0.0004929048009216785}, {"id": 614, "seek": 468500, "start": 4701.0, "end": 4711.0, "text": " Because of the Haskell academia nature, there is no formatter that came by default with the language as we do have with Elm format.", "tokens": [1436, 295, 264, 8646, 43723, 28937, 3687, 11, 456, 307, 572, 1254, 1161, 300, 1361, 538, 7576, 365, 264, 2856, 382, 321, 360, 362, 365, 2699, 76, 7877, 13], "temperature": 0.0, "avg_logprob": -0.22337841406101133, "compression_ratio": 1.5658536585365854, "no_speech_prob": 0.0004929048009216785}, {"id": 615, "seek": 471100, "start": 4711.0, "end": 4715.0, "text": " And in the build tool, which is Cabal, there's also a war.", "tokens": [400, 294, 264, 1322, 2290, 11, 597, 307, 14704, 304, 11, 456, 311, 611, 257, 1516, 13], "temperature": 0.0, "avg_logprob": -0.235962421522228, "compression_ratio": 1.7261410788381744, "no_speech_prob": 0.0003404574526939541}, {"id": 616, "seek": 471100, "start": 4715.0, "end": 4718.0, "text": " There's one called Cabal and one called Stack.", "tokens": [821, 311, 472, 1219, 14704, 304, 293, 472, 1219, 37649, 13], "temperature": 0.0, "avg_logprob": -0.235962421522228, "compression_ratio": 1.7261410788381744, "no_speech_prob": 0.0003404574526939541}, {"id": 617, "seek": 471100, "start": 4718.0, "end": 4723.0, "text": " And both of them work, but both of them have serious deficiencies.", "tokens": [400, 1293, 295, 552, 589, 11, 457, 1293, 295, 552, 362, 3156, 19248, 31294, 13], "temperature": 0.0, "avg_logprob": -0.235962421522228, "compression_ratio": 1.7261410788381744, "no_speech_prob": 0.0003404574526939541}, {"id": 618, "seek": 471100, "start": 4723.0, "end": 4734.0, "text": " So it's such a bless to have something like the Elm compiler or something that is curated and that comes by default with a formatter with one single style to rule them all.", "tokens": [407, 309, 311, 1270, 257, 272, 1832, 281, 362, 746, 411, 264, 2699, 76, 31958, 420, 746, 300, 307, 47851, 293, 300, 1487, 538, 7576, 365, 257, 1254, 1161, 365, 472, 2167, 3758, 281, 4978, 552, 439, 13], "temperature": 0.0, "avg_logprob": -0.235962421522228, "compression_ratio": 1.7261410788381744, "no_speech_prob": 0.0003404574526939541}, {"id": 619, "seek": 471100, "start": 4734.0, "end": 4739.0, "text": " And it's something I really, really, really miss in Haskell sometimes.", "tokens": [400, 309, 311, 746, 286, 534, 11, 534, 11, 534, 1713, 294, 8646, 43723, 2171, 13], "temperature": 0.0, "avg_logprob": -0.235962421522228, "compression_ratio": 1.7261410788381744, "no_speech_prob": 0.0003404574526939541}, {"id": 620, "seek": 473900, "start": 4739.0, "end": 4744.0, "text": " I would be invited on a Haskell podcast to teach Elm for Haskellers.", "tokens": [286, 576, 312, 9185, 322, 257, 8646, 43723, 7367, 281, 2924, 2699, 76, 337, 8646, 43723, 433, 13], "temperature": 0.0, "avg_logprob": -0.2498577318693462, "compression_ratio": 1.5450236966824644, "no_speech_prob": 0.00033502982114441693}, {"id": 621, "seek": 473900, "start": 4744.0, "end": 4749.0, "text": " Flavio would be a much better person to be on that podcast episode as well.", "tokens": [3235, 706, 1004, 576, 312, 257, 709, 1101, 954, 281, 312, 322, 300, 7367, 3500, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.2498577318693462, "compression_ratio": 1.5450236966824644, "no_speech_prob": 0.00033502982114441693}, {"id": 622, "seek": 473900, "start": 4749.0, "end": 4752.0, "text": " I mean, the episode would be pretty short.", "tokens": [286, 914, 11, 264, 3500, 576, 312, 1238, 2099, 13], "temperature": 0.0, "avg_logprob": -0.2498577318693462, "compression_ratio": 1.5450236966824644, "no_speech_prob": 0.00033502982114441693}, {"id": 623, "seek": 473900, "start": 4752.0, "end": 4758.0, "text": " Like, take Haskell, remove everything, and you've got Elm, basically.", "tokens": [1743, 11, 747, 8646, 43723, 11, 4159, 1203, 11, 293, 291, 600, 658, 2699, 76, 11, 1936, 13], "temperature": 0.0, "avg_logprob": -0.2498577318693462, "compression_ratio": 1.5450236966824644, "no_speech_prob": 0.00033502982114441693}, {"id": 624, "seek": 473900, "start": 4758.0, "end": 4761.0, "text": " And please use a formatter.", "tokens": [400, 1767, 764, 257, 1254, 1161, 13], "temperature": 0.0, "avg_logprob": -0.2498577318693462, "compression_ratio": 1.5450236966824644, "no_speech_prob": 0.00033502982114441693}, {"id": 625, "seek": 473900, "start": 4761.0, "end": 4766.0, "text": " You know functions? Yeah, we have those.", "tokens": [509, 458, 6828, 30, 865, 11, 321, 362, 729, 13], "temperature": 0.0, "avg_logprob": -0.2498577318693462, "compression_ratio": 1.5450236966824644, "no_speech_prob": 0.00033502982114441693}, {"id": 626, "seek": 476600, "start": 4766.0, "end": 4770.0, "text": " Functions over data? Yeah, that's Elm.", "tokens": [11166, 3916, 670, 1412, 30, 865, 11, 300, 311, 2699, 76, 13], "temperature": 0.0, "avg_logprob": -0.2385159073589004, "compression_ratio": 1.5954545454545455, "no_speech_prob": 0.00014345090312417597}, {"id": 627, "seek": 476600, "start": 4770.0, "end": 4778.0, "text": " I guess something I hear a lot is GADTs, but I don't know if that's a language extension.", "tokens": [286, 2041, 746, 286, 1568, 257, 688, 307, 460, 6112, 33424, 11, 457, 286, 500, 380, 458, 498, 300, 311, 257, 2856, 10320, 13], "temperature": 0.0, "avg_logprob": -0.2385159073589004, "compression_ratio": 1.5954545454545455, "no_speech_prob": 0.00014345090312417597}, {"id": 628, "seek": 476600, "start": 4778.0, "end": 4781.0, "text": " Yeah, it is a language extension.", "tokens": [865, 11, 309, 307, 257, 2856, 10320, 13], "temperature": 0.0, "avg_logprob": -0.2385159073589004, "compression_ratio": 1.5954545454545455, "no_speech_prob": 0.00014345090312417597}, {"id": 629, "seek": 476600, "start": 4781.0, "end": 4783.0, "text": " Generalized algebraic data types.", "tokens": [6996, 1602, 21989, 299, 1412, 3467, 13], "temperature": 0.0, "avg_logprob": -0.2385159073589004, "compression_ratio": 1.5954545454545455, "no_speech_prob": 0.00014345090312417597}, {"id": 630, "seek": 476600, "start": 4783.0, "end": 4787.0, "text": " Which is like our custom types, but more powerful.", "tokens": [3013, 307, 411, 527, 2375, 3467, 11, 457, 544, 4005, 13], "temperature": 0.0, "avg_logprob": -0.2385159073589004, "compression_ratio": 1.5954545454545455, "no_speech_prob": 0.00014345090312417597}, {"id": 631, "seek": 476600, "start": 4787.0, "end": 4793.0, "text": " It's a custom type, but it's a polymorphic custom type that you can parametrize just as OCaml functors.", "tokens": [467, 311, 257, 2375, 2010, 11, 457, 309, 311, 257, 6754, 76, 18191, 299, 2375, 2010, 300, 291, 393, 6220, 302, 470, 1381, 445, 382, 422, 31030, 75, 1019, 5547, 13], "temperature": 0.0, "avg_logprob": -0.2385159073589004, "compression_ratio": 1.5954545454545455, "no_speech_prob": 0.00014345090312417597}, {"id": 632, "seek": 479300, "start": 4793.0, "end": 4801.0, "text": " So I haven't really reached for GADTs in Haskell,", "tokens": [407, 286, 2378, 380, 534, 6488, 337, 460, 6112, 33424, 294, 8646, 43723, 11], "temperature": 0.0, "avg_logprob": -0.18476981208437965, "compression_ratio": 1.4658385093167703, "no_speech_prob": 0.0013690160121768713}, {"id": 633, "seek": 479300, "start": 4801.0, "end": 4806.0, "text": " because they come up when you really need to do really abstract, really complex stuff.", "tokens": [570, 436, 808, 493, 562, 291, 534, 643, 281, 360, 534, 12649, 11, 534, 3997, 1507, 13], "temperature": 0.0, "avg_logprob": -0.18476981208437965, "compression_ratio": 1.4658385093167703, "no_speech_prob": 0.0013690160121768713}, {"id": 634, "seek": 479300, "start": 4806.0, "end": 4812.0, "text": " But for many library authors and compiler creators as well,", "tokens": [583, 337, 867, 6405, 16552, 293, 31958, 16039, 382, 731, 11], "temperature": 0.0, "avg_logprob": -0.18476981208437965, "compression_ratio": 1.4658385093167703, "no_speech_prob": 0.0013690160121768713}, {"id": 635, "seek": 479300, "start": 4812.0, "end": 4816.0, "text": " I know they reach for GADTs very often.", "tokens": [286, 458, 436, 2524, 337, 460, 6112, 33424, 588, 2049, 13], "temperature": 0.0, "avg_logprob": -0.18476981208437965, "compression_ratio": 1.4658385093167703, "no_speech_prob": 0.0013690160121768713}, {"id": 636, "seek": 481600, "start": 4816.0, "end": 4823.0, "text": " And I know there are some measures, some things similar to GADTs in OCaml as well.", "tokens": [400, 286, 458, 456, 366, 512, 8000, 11, 512, 721, 2531, 281, 460, 6112, 33424, 294, 422, 31030, 75, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.1855100154876709, "compression_ratio": 1.6398305084745763, "no_speech_prob": 0.0007412540726363659}, {"id": 637, "seek": 481600, "start": 4823.0, "end": 4825.0, "text": " And people are really crazy about GADTs.", "tokens": [400, 561, 366, 534, 3219, 466, 460, 6112, 33424, 13], "temperature": 0.0, "avg_logprob": -0.1855100154876709, "compression_ratio": 1.6398305084745763, "no_speech_prob": 0.0007412540726363659}, {"id": 638, "seek": 481600, "start": 4825.0, "end": 4831.0, "text": " But for the average programmer, even the concept of it, even for me, it's crazy.", "tokens": [583, 337, 264, 4274, 32116, 11, 754, 264, 3410, 295, 309, 11, 754, 337, 385, 11, 309, 311, 3219, 13], "temperature": 0.0, "avg_logprob": -0.1855100154876709, "compression_ratio": 1.6398305084745763, "no_speech_prob": 0.0007412540726363659}, {"id": 639, "seek": 481600, "start": 4831.0, "end": 4835.0, "text": " It's very hard to grasp, very hard to use, and very hard to understand.", "tokens": [467, 311, 588, 1152, 281, 21743, 11, 588, 1152, 281, 764, 11, 293, 588, 1152, 281, 1223, 13], "temperature": 0.0, "avg_logprob": -0.1855100154876709, "compression_ratio": 1.6398305084745763, "no_speech_prob": 0.0007412540726363659}, {"id": 640, "seek": 481600, "start": 4835.0, "end": 4838.0, "text": " But yeah, there are GADTs.", "tokens": [583, 1338, 11, 456, 366, 460, 6112, 33424, 13], "temperature": 0.0, "avg_logprob": -0.1855100154876709, "compression_ratio": 1.6398305084745763, "no_speech_prob": 0.0007412540726363659}, {"id": 641, "seek": 481600, "start": 4838.0, "end": 4840.0, "text": " Gotcha.", "tokens": [42109, 13], "temperature": 0.0, "avg_logprob": -0.1855100154876709, "compression_ratio": 1.6398305084745763, "no_speech_prob": 0.0007412540726363659}, {"id": 642, "seek": 481600, "start": 4840.0, "end": 4845.0, "text": " I'm sure Dillon would use GADTs in Elm pages or in the Elm GraphQL for sure.", "tokens": [286, 478, 988, 28160, 576, 764, 460, 6112, 33424, 294, 2699, 76, 7183, 420, 294, 264, 2699, 76, 21884, 13695, 337, 988, 13], "temperature": 0.0, "avg_logprob": -0.1855100154876709, "compression_ratio": 1.6398305084745763, "no_speech_prob": 0.0007412540726363659}, {"id": 643, "seek": 484500, "start": 4845.0, "end": 4848.0, "text": " I've definitely thought about some of these things.", "tokens": [286, 600, 2138, 1194, 466, 512, 295, 613, 721, 13], "temperature": 0.0, "avg_logprob": -0.20833079879348343, "compression_ratio": 1.5336538461538463, "no_speech_prob": 6.204561941558495e-05}, {"id": 644, "seek": 484500, "start": 4848.0, "end": 4853.0, "text": " There are definitely certain compromises to Elm's simplicity.", "tokens": [821, 366, 2138, 1629, 11482, 3598, 281, 2699, 76, 311, 25632, 13], "temperature": 0.0, "avg_logprob": -0.20833079879348343, "compression_ratio": 1.5336538461538463, "no_speech_prob": 6.204561941558495e-05}, {"id": 645, "seek": 484500, "start": 4853.0, "end": 4861.0, "text": " And it's actually impressive how often we can get by without running into limitations", "tokens": [400, 309, 311, 767, 8992, 577, 2049, 321, 393, 483, 538, 1553, 2614, 666, 15705], "temperature": 0.0, "avg_logprob": -0.20833079879348343, "compression_ratio": 1.5336538461538463, "no_speech_prob": 6.204561941558495e-05}, {"id": 646, "seek": 484500, "start": 4861.0, "end": 4865.0, "text": " with the number of language features that Elm gives us and their simplicity.", "tokens": [365, 264, 1230, 295, 2856, 4122, 300, 2699, 76, 2709, 505, 293, 641, 25632, 13], "temperature": 0.0, "avg_logprob": -0.20833079879348343, "compression_ratio": 1.5336538461538463, "no_speech_prob": 6.204561941558495e-05}, {"id": 647, "seek": 484500, "start": 4865.0, "end": 4870.0, "text": " Like a custom type is such a simple thing.", "tokens": [1743, 257, 2375, 2010, 307, 1270, 257, 2199, 551, 13], "temperature": 0.0, "avg_logprob": -0.20833079879348343, "compression_ratio": 1.5336538461538463, "no_speech_prob": 6.204561941558495e-05}, {"id": 648, "seek": 487000, "start": 4870.0, "end": 4875.0, "text": " And there's an extreme elegance to just how little there is to that concept.", "tokens": [400, 456, 311, 364, 8084, 14459, 719, 281, 445, 577, 707, 456, 307, 281, 300, 3410, 13], "temperature": 0.0, "avg_logprob": -0.177607334021366, "compression_ratio": 1.6043478260869566, "no_speech_prob": 1.2029267054458614e-05}, {"id": 649, "seek": 487000, "start": 4875.0, "end": 4880.0, "text": " But I definitely have thought as a package and framework author,", "tokens": [583, 286, 2138, 362, 1194, 382, 257, 7372, 293, 8388, 3793, 11], "temperature": 0.0, "avg_logprob": -0.177607334021366, "compression_ratio": 1.6043478260869566, "no_speech_prob": 1.2029267054458614e-05}, {"id": 650, "seek": 487000, "start": 4880.0, "end": 4885.0, "text": " at times I'm like, hmm, yeah, if there was some way to have a more general way", "tokens": [412, 1413, 286, 478, 411, 11, 16478, 11, 1338, 11, 498, 456, 390, 512, 636, 281, 362, 257, 544, 2674, 636], "temperature": 0.0, "avg_logprob": -0.177607334021366, "compression_ratio": 1.6043478260869566, "no_speech_prob": 1.2029267054458614e-05}, {"id": 651, "seek": 487000, "start": 4885.0, "end": 4891.0, "text": " to deal with this, like to be able to let users have a more customizable", "tokens": [281, 2028, 365, 341, 11, 411, 281, 312, 1075, 281, 718, 5022, 362, 257, 544, 47922], "temperature": 0.0, "avg_logprob": -0.177607334021366, "compression_ratio": 1.6043478260869566, "no_speech_prob": 1.2029267054458614e-05}, {"id": 652, "seek": 487000, "start": 4891.0, "end": 4895.0, "text": " custom markdown block type.", "tokens": [2375, 1491, 5093, 3461, 2010, 13], "temperature": 0.0, "avg_logprob": -0.177607334021366, "compression_ratio": 1.6043478260869566, "no_speech_prob": 1.2029267054458614e-05}, {"id": 653, "seek": 487000, "start": 4895.0, "end": 4898.0, "text": " We don't have a lot of tools for extensibility.", "tokens": [492, 500, 380, 362, 257, 688, 295, 3873, 337, 1279, 694, 2841, 13], "temperature": 0.0, "avg_logprob": -0.177607334021366, "compression_ratio": 1.6043478260869566, "no_speech_prob": 1.2029267054458614e-05}, {"id": 654, "seek": 489800, "start": 4898.0, "end": 4903.0, "text": " So we end up using a lot of code generation as framework and tooling authors", "tokens": [407, 321, 917, 493, 1228, 257, 688, 295, 3089, 5125, 382, 8388, 293, 46593, 16552], "temperature": 0.0, "avg_logprob": -0.18288277680019163, "compression_ratio": 1.6385542168674698, "no_speech_prob": 2.0145549569861032e-05}, {"id": 655, "seek": 489800, "start": 4903.0, "end": 4908.0, "text": " to create extension points or very clever design.", "tokens": [281, 1884, 10320, 2793, 420, 588, 13494, 1715, 13], "temperature": 0.0, "avg_logprob": -0.18288277680019163, "compression_ratio": 1.6385542168674698, "no_speech_prob": 2.0145549569861032e-05}, {"id": 656, "seek": 489800, "start": 4908.0, "end": 4913.0, "text": " But we've actually managed to figure out a lot of clever tricks to do these things", "tokens": [583, 321, 600, 767, 6453, 281, 2573, 484, 257, 688, 295, 13494, 11733, 281, 360, 613, 721], "temperature": 0.0, "avg_logprob": -0.18288277680019163, "compression_ratio": 1.6385542168674698, "no_speech_prob": 2.0145549569861032e-05}, {"id": 657, "seek": 489800, "start": 4913.0, "end": 4916.0, "text": " and give a pretty good experience to the user at the end of the day.", "tokens": [293, 976, 257, 1238, 665, 1752, 281, 264, 4195, 412, 264, 917, 295, 264, 786, 13], "temperature": 0.0, "avg_logprob": -0.18288277680019163, "compression_ratio": 1.6385542168674698, "no_speech_prob": 2.0145549569861032e-05}, {"id": 658, "seek": 489800, "start": 4916.0, "end": 4919.0, "text": " But it takes a lot of love as a designer of these tools.", "tokens": [583, 309, 2516, 257, 688, 295, 959, 382, 257, 11795, 295, 613, 3873, 13], "temperature": 0.0, "avg_logprob": -0.18288277680019163, "compression_ratio": 1.6385542168674698, "no_speech_prob": 2.0145549569861032e-05}, {"id": 659, "seek": 489800, "start": 4919.0, "end": 4921.0, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.18288277680019163, "compression_ratio": 1.6385542168674698, "no_speech_prob": 2.0145549569861032e-05}, {"id": 660, "seek": 489800, "start": 4921.0, "end": 4924.0, "text": " I'm guessing in your case, a Haskell person would come in and say,", "tokens": [286, 478, 17939, 294, 428, 1389, 11, 257, 8646, 43723, 954, 576, 808, 294, 293, 584, 11], "temperature": 0.0, "avg_logprob": -0.18288277680019163, "compression_ratio": 1.6385542168674698, "no_speech_prob": 2.0145549569861032e-05}, {"id": 661, "seek": 492400, "start": 4924.0, "end": 4928.0, "text": " hey, I have a language extension for this.", "tokens": [4177, 11, 286, 362, 257, 2856, 10320, 337, 341, 13], "temperature": 0.0, "avg_logprob": -0.20433030930240598, "compression_ratio": 1.6625, "no_speech_prob": 1.7768825273378752e-05}, {"id": 662, "seek": 492400, "start": 4928.0, "end": 4933.0, "text": " Or it's just baked in that a type class would solve this problem for you maybe.", "tokens": [1610, 309, 311, 445, 19453, 294, 300, 257, 2010, 1508, 576, 5039, 341, 1154, 337, 291, 1310, 13], "temperature": 0.0, "avg_logprob": -0.20433030930240598, "compression_ratio": 1.6625, "no_speech_prob": 1.7768825273378752e-05}, {"id": 663, "seek": 492400, "start": 4933.0, "end": 4936.0, "text": " Exactly. Yes. How could I forget about type classes?", "tokens": [7587, 13, 1079, 13, 1012, 727, 286, 2870, 466, 2010, 5359, 30], "temperature": 0.0, "avg_logprob": -0.20433030930240598, "compression_ratio": 1.6625, "no_speech_prob": 1.7768825273378752e-05}, {"id": 664, "seek": 492400, "start": 4936.0, "end": 4939.0, "text": " This is the main thing that you need to learn from Haskell,", "tokens": [639, 307, 264, 2135, 551, 300, 291, 643, 281, 1466, 490, 8646, 43723, 11], "temperature": 0.0, "avg_logprob": -0.20433030930240598, "compression_ratio": 1.6625, "no_speech_prob": 1.7768825273378752e-05}, {"id": 665, "seek": 492400, "start": 4939.0, "end": 4943.0, "text": " for Haskell if you are coming from Elm, basically.", "tokens": [337, 8646, 43723, 498, 291, 366, 1348, 490, 2699, 76, 11, 1936, 13], "temperature": 0.0, "avg_logprob": -0.20433030930240598, "compression_ratio": 1.6625, "no_speech_prob": 1.7768825273378752e-05}, {"id": 666, "seek": 492400, "start": 4943.0, "end": 4946.0, "text": " And it's also the crown of Haskell, right? Type classes.", "tokens": [400, 309, 311, 611, 264, 11841, 295, 8646, 43723, 11, 558, 30, 15576, 5359, 13], "temperature": 0.0, "avg_logprob": -0.20433030930240598, "compression_ratio": 1.6625, "no_speech_prob": 1.7768825273378752e-05}, {"id": 667, "seek": 492400, "start": 4946.0, "end": 4950.0, "text": " And it's an idea that I think it was born with Haskell,", "tokens": [400, 309, 311, 364, 1558, 300, 286, 519, 309, 390, 4232, 365, 8646, 43723, 11], "temperature": 0.0, "avg_logprob": -0.20433030930240598, "compression_ratio": 1.6625, "no_speech_prob": 1.7768825273378752e-05}, {"id": 668, "seek": 495000, "start": 4950.0, "end": 4955.0, "text": " and it's extended to traits in Rust, and it influenced greatly many other languages.", "tokens": [293, 309, 311, 10913, 281, 19526, 294, 34952, 11, 293, 309, 15269, 14147, 867, 661, 8650, 13], "temperature": 0.0, "avg_logprob": -0.2720716948150307, "compression_ratio": 1.6866952789699572, "no_speech_prob": 8.265474025392905e-05}, {"id": 669, "seek": 495000, "start": 4955.0, "end": 4958.0, "text": " Because it's such a great thing as well.", "tokens": [1436, 309, 311, 1270, 257, 869, 551, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.2720716948150307, "compression_ratio": 1.6866952789699572, "no_speech_prob": 8.265474025392905e-05}, {"id": 670, "seek": 495000, "start": 4958.0, "end": 4965.0, "text": " Right. So would a type class allow you to say that this function takes a data structure", "tokens": [1779, 13, 407, 576, 257, 2010, 1508, 2089, 291, 281, 584, 300, 341, 2445, 2516, 257, 1412, 3877], "temperature": 0.0, "avg_logprob": -0.2720716948150307, "compression_ratio": 1.6866952789699572, "no_speech_prob": 8.265474025392905e-05}, {"id": 671, "seek": 495000, "start": 4965.0, "end": 4974.0, "text": " that you can index into, but you could use an ordered dictionary or an unordered dictionary,", "tokens": [300, 291, 393, 8186, 666, 11, 457, 291, 727, 764, 364, 8866, 25890, 420, 364, 517, 765, 4073, 25890, 11], "temperature": 0.0, "avg_logprob": -0.2720716948150307, "compression_ratio": 1.6866952789699572, "no_speech_prob": 8.265474025392905e-05}, {"id": 672, "seek": 495000, "start": 4974.0, "end": 4979.0, "text": " and it would support operations on both because it needs a certain class of functions?", "tokens": [293, 309, 576, 1406, 7705, 322, 1293, 570, 309, 2203, 257, 1629, 1508, 295, 6828, 30], "temperature": 0.0, "avg_logprob": -0.2720716948150307, "compression_ratio": 1.6866952789699572, "no_speech_prob": 8.265474025392905e-05}, {"id": 673, "seek": 497900, "start": 4979.0, "end": 4983.0, "text": " Exactly. Yeah. Some people compare them to interfaces in object-oriented programming,", "tokens": [7587, 13, 865, 13, 2188, 561, 6794, 552, 281, 28416, 294, 2657, 12, 27414, 9410, 11], "temperature": 0.0, "avg_logprob": -0.18597394769841974, "compression_ratio": 1.6583629893238434, "no_speech_prob": 0.0002119388518622145}, {"id": 674, "seek": 497900, "start": 4983.0, "end": 4986.0, "text": " but they're a little bit more powerful than interfaces.", "tokens": [457, 436, 434, 257, 707, 857, 544, 4005, 813, 28416, 13], "temperature": 0.0, "avg_logprob": -0.18597394769841974, "compression_ratio": 1.6583629893238434, "no_speech_prob": 0.0002119388518622145}, {"id": 675, "seek": 497900, "start": 4986.0, "end": 4991.0, "text": " So, for example, we've discussed about monad and functor and applicative functor.", "tokens": [407, 11, 337, 1365, 11, 321, 600, 7152, 466, 1108, 345, 293, 1019, 1672, 293, 2580, 1166, 1019, 1672, 13], "temperature": 0.0, "avg_logprob": -0.18597394769841974, "compression_ratio": 1.6583629893238434, "no_speech_prob": 0.0002119388518622145}, {"id": 676, "seek": 497900, "start": 4991.0, "end": 4994.0, "text": " Those are basically type classes in Haskell.", "tokens": [3950, 366, 1936, 2010, 5359, 294, 8646, 43723, 13], "temperature": 0.0, "avg_logprob": -0.18597394769841974, "compression_ratio": 1.6583629893238434, "no_speech_prob": 0.0002119388518622145}, {"id": 677, "seek": 497900, "start": 4994.0, "end": 4997.0, "text": " You can define them, define the methods that they need to implement", "tokens": [509, 393, 6964, 552, 11, 6964, 264, 7150, 300, 436, 643, 281, 4445], "temperature": 0.0, "avg_logprob": -0.18597394769841974, "compression_ratio": 1.6583629893238434, "no_speech_prob": 0.0002119388518622145}, {"id": 678, "seek": 497900, "start": 4997.0, "end": 5000.0, "text": " to be considered instance of a certain type class.", "tokens": [281, 312, 4888, 5197, 295, 257, 1629, 2010, 1508, 13], "temperature": 0.0, "avg_logprob": -0.18597394769841974, "compression_ratio": 1.6583629893238434, "no_speech_prob": 0.0002119388518622145}, {"id": 679, "seek": 497900, "start": 5000.0, "end": 5005.0, "text": " And also we have type class tests and property tests that we can check against", "tokens": [400, 611, 321, 362, 2010, 1508, 6921, 293, 4707, 6921, 300, 321, 393, 1520, 1970], "temperature": 0.0, "avg_logprob": -0.18597394769841974, "compression_ratio": 1.6583629893238434, "no_speech_prob": 0.0002119388518622145}, {"id": 680, "seek": 500500, "start": 5005.0, "end": 5011.0, "text": " to make sure that a type is a semi-group, a monoid, or whatever type class.", "tokens": [281, 652, 988, 300, 257, 2010, 307, 257, 12909, 12, 17377, 11, 257, 1108, 17079, 11, 420, 2035, 2010, 1508, 13], "temperature": 0.0, "avg_logprob": -0.18158064569745744, "compression_ratio": 1.4328358208955223, "no_speech_prob": 6.747679435648024e-06}, {"id": 681, "seek": 500500, "start": 5011.0, "end": 5015.0, "text": " Yeah. So much stuff to discuss.", "tokens": [865, 13, 407, 709, 1507, 281, 2248, 13], "temperature": 0.0, "avg_logprob": -0.18158064569745744, "compression_ratio": 1.4328358208955223, "no_speech_prob": 6.747679435648024e-06}, {"id": 682, "seek": 500500, "start": 5015.0, "end": 5020.0, "text": " So if somebody wants to do a deeper dive into Haskell,", "tokens": [407, 498, 2618, 2738, 281, 360, 257, 7731, 9192, 666, 8646, 43723, 11], "temperature": 0.0, "avg_logprob": -0.18158064569745744, "compression_ratio": 1.4328358208955223, "no_speech_prob": 6.747679435648024e-06}, {"id": 683, "seek": 500500, "start": 5020.0, "end": 5023.0, "text": " do you have any favorite resources to point them to?", "tokens": [360, 291, 362, 604, 2954, 3593, 281, 935, 552, 281, 30], "temperature": 0.0, "avg_logprob": -0.18158064569745744, "compression_ratio": 1.4328358208955223, "no_speech_prob": 6.747679435648024e-06}, {"id": 684, "seek": 500500, "start": 5023.0, "end": 5027.0, "text": " I think there's the Elm Guide, which is a good introduction.", "tokens": [286, 519, 456, 311, 264, 2699, 76, 18727, 11, 597, 307, 257, 665, 9339, 13], "temperature": 0.0, "avg_logprob": -0.18158064569745744, "compression_ratio": 1.4328358208955223, "no_speech_prob": 6.747679435648024e-06}, {"id": 685, "seek": 500500, "start": 5027.0, "end": 5029.0, "text": " Definitely.", "tokens": [12151, 13], "temperature": 0.0, "avg_logprob": -0.18158064569745744, "compression_ratio": 1.4328358208955223, "no_speech_prob": 6.747679435648024e-06}, {"id": 686, "seek": 502900, "start": 5029.0, "end": 5035.0, "text": " Actually, for me, the ideal learning path would be, for example, learning JavaScript.", "tokens": [5135, 11, 337, 385, 11, 264, 7157, 2539, 3100, 576, 312, 11, 337, 1365, 11, 2539, 15778, 13], "temperature": 0.0, "avg_logprob": -0.18674274853297643, "compression_ratio": 1.6477732793522266, "no_speech_prob": 0.00015100282325875014}, {"id": 687, "seek": 502900, "start": 5035.0, "end": 5039.0, "text": " And then, for example, I read Richard Feldman's Elm in Action,", "tokens": [400, 550, 11, 337, 1365, 11, 286, 1401, 9809, 42677, 1601, 311, 2699, 76, 294, 16261, 11], "temperature": 0.0, "avg_logprob": -0.18674274853297643, "compression_ratio": 1.6477732793522266, "no_speech_prob": 0.00015100282325875014}, {"id": 688, "seek": 502900, "start": 5039.0, "end": 5044.0, "text": " which I think it does a pretty good job teaching Elm to a JavaScript mindset.", "tokens": [597, 286, 519, 309, 775, 257, 1238, 665, 1691, 4571, 2699, 76, 281, 257, 15778, 12543, 13], "temperature": 0.0, "avg_logprob": -0.18674274853297643, "compression_ratio": 1.6477732793522266, "no_speech_prob": 0.00015100282325875014}, {"id": 689, "seek": 502900, "start": 5044.0, "end": 5049.0, "text": " And then from Elm to Haskell, well, I obviously would recommend my blog posts,", "tokens": [400, 550, 490, 2699, 76, 281, 8646, 43723, 11, 731, 11, 286, 2745, 576, 2748, 452, 6968, 12300, 11], "temperature": 0.0, "avg_logprob": -0.18674274853297643, "compression_ratio": 1.6477732793522266, "no_speech_prob": 0.00015100282325875014}, {"id": 690, "seek": 502900, "start": 5049.0, "end": 5051.0, "text": " my series of blog posts.", "tokens": [452, 2638, 295, 6968, 12300, 13], "temperature": 0.0, "avg_logprob": -0.18674274853297643, "compression_ratio": 1.6477732793522266, "no_speech_prob": 0.00015100282325875014}, {"id": 691, "seek": 502900, "start": 5051.0, "end": 5052.0, "text": " Yes.", "tokens": [1079, 13], "temperature": 0.0, "avg_logprob": -0.18674274853297643, "compression_ratio": 1.6477732793522266, "no_speech_prob": 0.00015100282325875014}, {"id": 692, "seek": 502900, "start": 5052.0, "end": 5057.0, "text": " But as well, this Haskell book, Learning Haskell from First Principles,", "tokens": [583, 382, 731, 11, 341, 8646, 43723, 1446, 11, 15205, 8646, 43723, 490, 2386, 38372, 2622, 11], "temperature": 0.0, "avg_logprob": -0.18674274853297643, "compression_ratio": 1.6477732793522266, "no_speech_prob": 0.00015100282325875014}, {"id": 693, "seek": 505700, "start": 5057.0, "end": 5060.0, "text": " it's an excellent resource, even though it's a little bit long.", "tokens": [309, 311, 364, 7103, 7684, 11, 754, 1673, 309, 311, 257, 707, 857, 938, 13], "temperature": 0.0, "avg_logprob": -0.25746458827859103, "compression_ratio": 1.51417004048583, "no_speech_prob": 0.00024873120128177106}, {"id": 694, "seek": 505700, "start": 5060.0, "end": 5066.0, "text": " But it just does a perfect job of explaining from almost ground zero what you need to know.", "tokens": [583, 309, 445, 775, 257, 2176, 1691, 295, 13468, 490, 1920, 2727, 4018, 437, 291, 643, 281, 458, 13], "temperature": 0.0, "avg_logprob": -0.25746458827859103, "compression_ratio": 1.51417004048583, "no_speech_prob": 0.00024873120128177106}, {"id": 695, "seek": 505700, "start": 5066.0, "end": 5070.0, "text": " It almost teaches you what the string is and a function is", "tokens": [467, 1920, 16876, 291, 437, 264, 6798, 307, 293, 257, 2445, 307], "temperature": 0.0, "avg_logprob": -0.25746458827859103, "compression_ratio": 1.51417004048583, "no_speech_prob": 0.00024873120128177106}, {"id": 696, "seek": 505700, "start": 5070.0, "end": 5075.0, "text": " before dipping dive into... diving deep, sorry, into Haskell.", "tokens": [949, 35584, 9192, 666, 485, 20241, 2452, 11, 2597, 11, 666, 8646, 43723, 13], "temperature": 0.0, "avg_logprob": -0.25746458827859103, "compression_ratio": 1.51417004048583, "no_speech_prob": 0.00024873120128177106}, {"id": 697, "seek": 505700, "start": 5075.0, "end": 5079.0, "text": " Is it one of those books where Hello World is chapter 12?", "tokens": [1119, 309, 472, 295, 729, 3642, 689, 2425, 3937, 307, 7187, 2272, 30], "temperature": 0.0, "avg_logprob": -0.25746458827859103, "compression_ratio": 1.51417004048583, "no_speech_prob": 0.00024873120128177106}, {"id": 698, "seek": 505700, "start": 5079.0, "end": 5082.0, "text": " Exactly. Yes. Or chapter 20. Yes.", "tokens": [7587, 13, 1079, 13, 1610, 7187, 945, 13, 1079, 13], "temperature": 0.0, "avg_logprob": -0.25746458827859103, "compression_ratio": 1.51417004048583, "no_speech_prob": 0.00024873120128177106}, {"id": 699, "seek": 505700, "start": 5082.0, "end": 5085.0, "text": " Okay.", "tokens": [1033, 13], "temperature": 0.0, "avg_logprob": -0.25746458827859103, "compression_ratio": 1.51417004048583, "no_speech_prob": 0.00024873120128177106}, {"id": 700, "seek": 508500, "start": 5085.0, "end": 5089.0, "text": " I think Monads, I think Functors is chapter 12,", "tokens": [286, 519, 4713, 5834, 11, 286, 519, 11166, 5547, 307, 7187, 2272, 11], "temperature": 0.0, "avg_logprob": -0.22409635909060213, "compression_ratio": 1.6519607843137254, "no_speech_prob": 7.250093040056527e-05}, {"id": 701, "seek": 508500, "start": 5089.0, "end": 5095.0, "text": " and then Applicatives 13, and then Monads is chapter 16 or something like that.", "tokens": [293, 550, 26519, 4884, 3705, 11, 293, 550, 4713, 5834, 307, 7187, 3165, 420, 746, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.22409635909060213, "compression_ratio": 1.6519607843137254, "no_speech_prob": 7.250093040056527e-05}, {"id": 702, "seek": 508500, "start": 5095.0, "end": 5101.0, "text": " I have to confess, I read chapter one of this book years ago,", "tokens": [286, 362, 281, 19367, 11, 286, 1401, 7187, 472, 295, 341, 1446, 924, 2057, 11], "temperature": 0.0, "avg_logprob": -0.22409635909060213, "compression_ratio": 1.6519607843137254, "no_speech_prob": 7.250093040056527e-05}, {"id": 703, "seek": 508500, "start": 5101.0, "end": 5104.0, "text": " like six years ago, about lambda calculus.", "tokens": [411, 2309, 924, 2057, 11, 466, 13607, 33400, 13], "temperature": 0.0, "avg_logprob": -0.22409635909060213, "compression_ratio": 1.6519607843137254, "no_speech_prob": 7.250093040056527e-05}, {"id": 704, "seek": 508500, "start": 5104.0, "end": 5106.0, "text": " And I diligently went through...", "tokens": [400, 286, 49013, 1437, 807, 485], "temperature": 0.0, "avg_logprob": -0.22409635909060213, "compression_ratio": 1.6519607843137254, "no_speech_prob": 7.250093040056527e-05}, {"id": 705, "seek": 508500, "start": 5106.0, "end": 5110.0, "text": " Skip chapter one. You can skip it.", "tokens": [46405, 7187, 472, 13, 509, 393, 10023, 309, 13], "temperature": 0.0, "avg_logprob": -0.22409635909060213, "compression_ratio": 1.6519607843137254, "no_speech_prob": 7.250093040056527e-05}, {"id": 706, "seek": 508500, "start": 5110.0, "end": 5112.0, "text": " I diligently went through all of it.", "tokens": [286, 49013, 1437, 807, 439, 295, 309, 13], "temperature": 0.0, "avg_logprob": -0.22409635909060213, "compression_ratio": 1.6519607843137254, "no_speech_prob": 7.250093040056527e-05}, {"id": 707, "seek": 511200, "start": 5112.0, "end": 5116.0, "text": " I had my pencil and paper and I did those lambda calculus exercises", "tokens": [286, 632, 452, 10985, 293, 3035, 293, 286, 630, 729, 13607, 33400, 11900], "temperature": 0.0, "avg_logprob": -0.19582439769398083, "compression_ratio": 1.7107438016528926, "no_speech_prob": 0.00036645165528170764}, {"id": 708, "seek": 511200, "start": 5116.0, "end": 5118.0, "text": " and I understood lambda calculus a little better.", "tokens": [293, 286, 7320, 13607, 33400, 257, 707, 1101, 13], "temperature": 0.0, "avg_logprob": -0.19582439769398083, "compression_ratio": 1.7107438016528926, "no_speech_prob": 0.00036645165528170764}, {"id": 709, "seek": 511200, "start": 5118.0, "end": 5121.0, "text": " And then I'm like, okay, I think that's all.", "tokens": [400, 550, 286, 478, 411, 11, 1392, 11, 286, 519, 300, 311, 439, 13], "temperature": 0.0, "avg_logprob": -0.19582439769398083, "compression_ratio": 1.7107438016528926, "no_speech_prob": 0.00036645165528170764}, {"id": 710, "seek": 511200, "start": 5121.0, "end": 5123.0, "text": " That's it.", "tokens": [663, 311, 309, 13], "temperature": 0.0, "avg_logprob": -0.19582439769398083, "compression_ratio": 1.7107438016528926, "no_speech_prob": 0.00036645165528170764}, {"id": 711, "seek": 511200, "start": 5123.0, "end": 5126.0, "text": " Exhausted my energy for going through it.", "tokens": [2111, 1641, 6589, 452, 2281, 337, 516, 807, 309, 13], "temperature": 0.0, "avg_logprob": -0.19582439769398083, "compression_ratio": 1.7107438016528926, "no_speech_prob": 0.00036645165528170764}, {"id": 712, "seek": 511200, "start": 5126.0, "end": 5132.0, "text": " Yeah, I think I kind of understand why they decided to put lambda calculus on the first chapter.", "tokens": [865, 11, 286, 519, 286, 733, 295, 1223, 983, 436, 3047, 281, 829, 13607, 33400, 322, 264, 700, 7187, 13], "temperature": 0.0, "avg_logprob": -0.19582439769398083, "compression_ratio": 1.7107438016528926, "no_speech_prob": 0.00036645165528170764}, {"id": 713, "seek": 511200, "start": 5132.0, "end": 5136.0, "text": " But I know that many people haven't gone through the first chapter.", "tokens": [583, 286, 458, 300, 867, 561, 2378, 380, 2780, 807, 264, 700, 7187, 13], "temperature": 0.0, "avg_logprob": -0.19582439769398083, "compression_ratio": 1.7107438016528926, "no_speech_prob": 0.00036645165528170764}, {"id": 714, "seek": 511200, "start": 5136.0, "end": 5138.0, "text": " So it's a terrible entry barrier.", "tokens": [407, 309, 311, 257, 6237, 8729, 13357, 13], "temperature": 0.0, "avg_logprob": -0.19582439769398083, "compression_ratio": 1.7107438016528926, "no_speech_prob": 0.00036645165528170764}, {"id": 715, "seek": 513800, "start": 5138.0, "end": 5142.0, "text": " You can pretty much read the book without reading the first chapter.", "tokens": [509, 393, 1238, 709, 1401, 264, 1446, 1553, 3760, 264, 700, 7187, 13], "temperature": 0.0, "avg_logprob": -0.2100631683830201, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0001484645326854661}, {"id": 716, "seek": 513800, "start": 5142.0, "end": 5148.0, "text": " But it's basically like we do in Elm, programming with expressions, not statements.", "tokens": [583, 309, 311, 1936, 411, 321, 360, 294, 2699, 76, 11, 9410, 365, 15277, 11, 406, 12363, 13], "temperature": 0.0, "avg_logprob": -0.2100631683830201, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0001484645326854661}, {"id": 717, "seek": 513800, "start": 5148.0, "end": 5153.0, "text": " So this is an invaluable skill, in my opinion, that will get you really, really far,", "tokens": [407, 341, 307, 364, 40367, 5389, 11, 294, 452, 4800, 11, 300, 486, 483, 291, 534, 11, 534, 1400, 11], "temperature": 0.0, "avg_logprob": -0.2100631683830201, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0001484645326854661}, {"id": 718, "seek": 513800, "start": 5153.0, "end": 5155.0, "text": " understanding the whole expressions thing.", "tokens": [3701, 264, 1379, 15277, 551, 13], "temperature": 0.0, "avg_logprob": -0.2100631683830201, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0001484645326854661}, {"id": 719, "seek": 513800, "start": 5155.0, "end": 5158.0, "text": " Right. Yeah. Well, great stuff.", "tokens": [1779, 13, 865, 13, 1042, 11, 869, 1507, 13], "temperature": 0.0, "avg_logprob": -0.2100631683830201, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0001484645326854661}, {"id": 720, "seek": 513800, "start": 5158.0, "end": 5160.0, "text": " And Flavio, thanks again for joining us.", "tokens": [400, 3235, 706, 1004, 11, 3231, 797, 337, 5549, 505, 13], "temperature": 0.0, "avg_logprob": -0.2100631683830201, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0001484645326854661}, {"id": 721, "seek": 513800, "start": 5160.0, "end": 5162.0, "text": " And thanks for your blog posts.", "tokens": [400, 3231, 337, 428, 6968, 12300, 13], "temperature": 0.0, "avg_logprob": -0.2100631683830201, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0001484645326854661}, {"id": 722, "seek": 513800, "start": 5162.0, "end": 5164.0, "text": " And looking forward to hearing more in the future.", "tokens": [400, 1237, 2128, 281, 4763, 544, 294, 264, 2027, 13], "temperature": 0.0, "avg_logprob": -0.2100631683830201, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0001484645326854661}, {"id": 723, "seek": 513800, "start": 5164.0, "end": 5167.0, "text": " My pleasure. Thank you. Thank you both for having me.", "tokens": [1222, 6834, 13, 1044, 291, 13, 1044, 291, 1293, 337, 1419, 385, 13], "temperature": 0.0, "avg_logprob": -0.2100631683830201, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0001484645326854661}, {"id": 724, "seek": 516700, "start": 5167.0, "end": 5168.0, "text": " Thank you for coming.", "tokens": [1044, 291, 337, 1348, 13], "temperature": 0.0, "avg_logprob": -0.16318086624145509, "compression_ratio": 1.0806451612903225, "no_speech_prob": 0.00025634607300162315}, {"id": 725, "seek": 516700, "start": 5168.0, "end": 5170.0, "text": " And Jeroen, until next time.", "tokens": [400, 508, 2032, 268, 11, 1826, 958, 565, 13], "temperature": 0.0, "avg_logprob": -0.16318086624145509, "compression_ratio": 1.0806451612903225, "no_speech_prob": 0.00025634607300162315}, {"id": 726, "seek": 517000, "start": 5170.0, "end": 5198.0, "text": " Music.", "tokens": [50364, 7609, 13, 51764], "temperature": 0.0, "avg_logprob": -0.9438485145568848, "compression_ratio": 0.42857142857142855, "no_speech_prob": 8.851083111949265e-05}], "language": "en"}